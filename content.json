{"meta":{"title":"Old Stone","subtitle":"","description":"","author":"uklar","url":"https://clarenceyk.github.io","root":"/"},"pages":[],"posts":[{"title":"使用 QEMU 启动 ARM aarch64 架构 Ubuntu 虚拟机","slug":"QEMU-安装-Ubuntu-ARM64-架构操作系统","date":"2021-03-01T01:35:03.000Z","updated":"2021-03-03T03:15:19.000Z","comments":true,"path":"2021/03/01/QEMU-安装-Ubuntu-ARM64-架构操作系统/","link":"","permalink":"https://clarenceyk.github.io/2021/03/01/QEMU-%E5%AE%89%E8%A3%85-Ubuntu-ARM64-%E6%9E%B6%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。","text":"本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。 环境本文所有操作均在 Ubuntu20.04 操作系统上完成。 安装 QEMU安装启动 aarch64 ubuntu 所需的依赖程序： 1234sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager qemusudo apt install qemu-system-aarch64sudo apt install qemu-efi-aarch64sudo apt install qemu-utils 创建镜像创建启动必备的 flash 镜像： 123dd if=/dev/zero of=flash1.img bs=1M count=64dd if=/dev/zero of=flash0.img bs=1M count=64dd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=flash0.img conv=notrunc 下载想要启动的镜像，本文选用 Ubuntu16.04： 1wget http://ports.ubuntu.com/ubuntu-ports/dists/xenial-updates/main/installer-arm64/current/images/netboot/mini.iso 创建空硬盘镜像，此镜像用于安装操作系统： 1qemu-img create ubuntu-image.img 20G 至此准备工作完成。 安装系统启动系统安装器： 12345qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 512M -cpu max -smp 4 \\-netdev user,id=vnet,hostfwd=:127.0.0.1:0-:22 -device virtio-net-pci,netdev=vnet \\-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \\-drive file=mini.iso,if=none,id=drive1,cache=writeback -device virtio-blk,drive=drive1,bootindex=1 \\-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 根据提示信息完成操作系统安装。 安装完成之后通过 Ctrl-a x 退出 QEMU 。 启动镜像这里我们希望将虚拟机接入宿主机所在网络，如下图： 网络连接图+-----------------------------------------------------------------+| Host || +---------------------+ || | | || | br0: | || | 192.168.199.32&#x2F;24 +-----+ || | | | || +----+----------------+ | +-------------------------+ || | | | Guest | || | | | +---------------------+ | || +----+----------------+ +--+---+ | | | | || | | | | | | eth0: | | || | enp3s0: | | tap0 | | | 192.168.199.33&#x2F;24 | | || | 192.168.199.30&#x2F;24 | | +-----+ | | || | | | | | +---------------------+ | || +---------------------+ +------+ +-------------------------+ |+-----------------------------------------------------------------+ 配置网桥 br0： 12345sudo ip link add name br0 type bridgesudo ip link set dev br0 downsudo ip addr flush dev br0sudo ip addr add 192.168.199.32/24 dev br0sudo ip link set dev br0 up 配置 tap 设备 tap0： 12sudo ip tuntap add name tap0 mode tapsudo ip link set dev tap0 up 将宿主机网络接口 enp3s0 和 tap0 接入网桥 br0： 12sudo ip link set enp3s0 master br0sudo ip link set tap0 master br0 启动虚拟机系统： 123456sudo qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 1G -cpu max -smp 4 \\-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \\-device virtio-net-pci,netdev=mynet0,mac=$(qemu-mac-hasher.py ubuntu1604-arm64) \\-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback \\-device virtio-blk,drive=drive0,bootindex=0 \\-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 以上命令指定 qemu 使用 tap 设备作为虚拟机网络接口并且指定使用刚刚创建的 tap0 接口。 为了指定虚拟器的 MAC 地址我们使用一个脚本来为每个虚拟机生成特定地址。MAC 地址的生成脚本如下： qemu-mac-hasher.py12345678#!/usr/bin/env python# usage: qemu-mac-hasher.py &lt;VMName&gt;import sysimport zlibcrc = str(hex(zlib.crc32(sys.argv[1].encode(&quot;utf-8&quot;))))[-8:]print(&quot;52:54:%s%s:%s%s:%s%s:%s%s&quot; % tuple(crc)) 虚拟机启动后根据需要配置其网络参数即可。 优化网络以上步骤完成后虚拟机可与宿主机所在网络的其他设备互连（包括宿主机），也可以通过指定的网关连接互联网，但是此时宿主机无法连接互联网，解决方法如下： 删除 enp3s0 接口的默认网关： 1sudo ip route del default dev enp3s0 为 br0 添加默认网关： 1sudo ip route add default via 192.168.199.1 dev br0","categories":[],"tags":[{"name":"操作方法","slug":"操作方法","permalink":"https://clarenceyk.github.io/tags/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"QEMU","slug":"QEMU","permalink":"https://clarenceyk.github.io/tags/QEMU/"},{"name":"ARM64","slug":"ARM64","permalink":"https://clarenceyk.github.io/tags/ARM64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://clarenceyk.github.io/tags/Ubuntu/"}]},{"title":"用 LXD 容器化 VoIP 服务","slug":"create-a-linux-container-of-debian-with-asterisk-freepbx-installed","date":"2020-07-25T02:39:18.000Z","updated":"2020-07-26T08:31:33.000Z","comments":true,"path":"2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/","link":"","permalink":"https://clarenceyk.github.io/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/","excerpt":"将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。","text":"将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。 Why如果你的 VoIP 服务开发环境、测试环境和生产环境在同一台物理机上，也许不会察觉到环境搭建的繁琐以及消耗在配置环境上的时间。让我们来设想这样一个场景：客户指定使用某一个 Linux 发行版安装 Asterisk（或者配合 FreePBX）开发一套存在特定需求的 VoIP 服务，基于这个前提你拿到一台新的设备开始工作： 首先安装配置某个指定 Linux 发行版（花费1、2个小时）； 接着编译、安装、配置 Asterisk（1个小时）； 然后安装配置 FreePBX（花费2小时解决无数个问题）； 最后完成测试（花费1小时）。 终于在5、6个小时后你搭建好了开发环境，接着发现还有测试环境和生产环境需要搭建，于是你再花上2倍于之前的时间完成了环境搭建工作。总算可以开始开发了，你开始实现某一项功能，为了完成这项功能可能： 需要变动 Asterisk 的配置； 需要变动 FreePBX 的接口； 系统某些环境变量、配置参数需要改动。 于是你将这些变动都同步执行到测试和生产环境以保证各平台的环境一致，这将耗费开发人员大量的时间。同时，一个项目中面临几十上百项功能的开发需求，很快你就会发现因为环境配置失步导致的开发流程失控，比如开发环境能实现的功能在测试环境失效，在生产环境出现的问题在开发环境无法复现。 问题总结： 开发人员在搭建环境和保证各平台环境配置同步的过程中耗费大量时间； 手动操作进行配置同步难免会出错，出现运行环境失控的情况。 为了解决这2方面问题，我们可以将服务程序及其所依赖的环境打包进容器中使得整套环境容器化，然后在各个平台分发此容器以保证环境的一致性。 How本次测试的环境是 Debian 10，以下分4个步骤完成 VoIP 服务容器化： 安装并配置 LXD； 制作根文件系统，其中安装了 Asterisk 以及 FreePBX； 将此根文件系统打包作为基础镜像导入 LXD； 从 LXD 中的基础镜像启动一个实例，并配置网络。 安装并配置 LXDLXD 是一下代开源系统容器、虚拟机管理器。关于 LXD 更为详细的介绍请参考官方文档。 使用 snap 安装 LXD，如果系统没有 snap 先安装 snap： 12sudo apt install snapsudo snap install core 安装 LXD： 1sudo snap install lxd 将用户添加到 lxd 组： 1sudo usermod -a -G lxd $YOUR_USERNAME 配置 LXD一般情况下直接在命令行中输入 lxd init 然后全部选择都使用默认选项即可。这里我希望使用自定义的存储设备作为 lxd 的 storage pool。 首先创建一个大小合适的空文件： 12mkdir $HOME/lxd_storagedd if=/dev/zero of=$HOME/lxd_storage/disk bs=1M count=51200 # 50G 创建新的 loop device 并将刚刚创建的空文件关联到此设备： 12losetup /dev/loop14 $HOME/lxd_storage/disk # 先查看 /dev 目录下是否已有 loop14，有则换一个如：loop15sudo reboot # 重启生效配置 初始化 lxd 配置： 1234567891011121314151617uklar@debian:~# lxd initWould you like to use LXD clustering? (yes/no) [default=no]:Do you want to configure a new storage pool? (yes/no) [default=yes]:Name of the new storage pool [default=default]:Name of the storage backend to use (btrfs, dir) [default=btrfs]:Would you like to create a new btrfs subvolume under /var/lib/lxd? (yes/no) [default=yes]: noCreate a new BTRFS pool? (yes/no) [default=yes]:Would you like to use an existing block device? (yes/no) [default=no]: yesPath to the existing block device: /dev/loop14Would you like to connect to a MAAS server? (yes/no) [default=no]:Would you like to create a new local network bridge? (yes/no) [default=yes]:What should the new bridge be called? [default=lxdbr0]:What IPv4 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:What IPv6 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]: noneWould you like LXD to be available over the network? (yes/no) [default=no]:Would you like stale cached images to be updated automatically? (yes/no) [default=yes] noWould you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]: 制作根文件系统这里使用 debootstrap 获取 debian 的根文件系统： 123sudo apt install debootstrapmkdir /tmp/debiansudo debootstrap buster /tmp/debian 使用 systemd-nspawn 以 chroot 模式切换到 /tmp/debian 中： 12sudo apt install systemd-container # 此软件包中包含了 systemd-nspawnsudo systemd-container -D /tmp/debian 做一些基本配置，如设置 root 用户密码、添加普通用户以及配置网络等，然后退出： 12345678910111213141516171819202122232425passwduseradd -m $USERNAMEpasswd $USERNAMEapt install sudousermod -a -G sudo $USERNAMEusermod --shell /bin/bash $USERNAMEcat &lt;&lt;EOF &gt;/etc/network/interfaces# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The eth0 network interfaceauto eth0iface eth0 inet dhcpEOFexit 接着使用 systemd-nspawn 的容器模式启动 /tmp/debian 以 root 身份登陆： 1sudo systemd-nspawn -D /tmp/debian --boot 在容器中安装 Asterisk 以及 FreePBX，过程请参考： Asterisk 安装脚本 FreePBX 安装脚本 配置 hostname： 123apt install dbushostnamectl set-hostname debian.voip.netecho &#x27;127.0.0.1 debian.voip.net&#x27; &gt;&gt;/etc/hosts 访问服务器 Web 页面验证容器中的 VoIP 服务是否正常运行： 从 systemd-nspawn 容器中退出： 1shutdown now 创建 LXD 镜像将刚刚配置完成的根文件系统打包并压缩： 123mkdir -p ~/container/images/voip_basecd ~/container/images/voip_basesudo tar czf voip_base.tar.gz -C /tmp/debian . 为镜像创建 metadata 文件： 1234567891011cat &lt;&lt;EOF &gt;./metadata.yamlarchitecture: &quot;x86_64&quot;creation_date: $(date +%s)properties: architecture: &quot;x86_64&quot; description: &quot;Debian(buster) with preinstalled Asterisk13&amp;FreePBX15 ($(date +%Y%m%d))&quot; os: &quot;debian&quot; release: &quot;buster&quot;EOFtar czf metadata.tar.gz metadata.yaml 将压缩包作为镜像导入 LXD： 1234lxc image import \\~/container/images/voip_base/metadata.tar.gz \\~/container/images/voip_base/voip_base.tar.gz \\--alias voip-base 查看镜像是否成功导入： 1lxc image list 从镜像启动实例有了基础镜像之后，启动一个新的 VoIP 服务实例只需一行命令： 1lxc launch voip-base test 查看实例运行状态： 1lxc list 可以看到 VoIP 服务实例（名字为 test）正在运行，分配的内部 IP 地址是 10.72.18.48。 可用以下命令登陆到实例中： 1lxc exec test bash 查看各类服务使用的端口： 1lsof -i -P -n 宿主机网络配置让宿主机（IP 为 192.168.0.107）所在网络（192.168.0.0/24）的其他设备能够访问 VoIP 服务（IP 为 10.72.18.48），需要在宿主机上配置网络地址转换（NAT）： 发送到宿主机 5060 端口的 UDP 包（PJSIP）转发到容器实例 发送到宿主机 5160 端口的 UDP 包（SIP）转发到容器实例 发送到宿主机 10000 - 20000 端口的 UDP 包（语音）转发到容器实例 发送到宿主机 80 端口的 TCP 包（Web 管理服务）转发到容器实例 以上配置可根据实际需求更改。 这里使用 iptables 来完成，使用 exit 从实例退出返回宿主机，执行： 1234sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5060 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5160 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 10000:20000 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p tcp --dport 80 -j DNAT --to 10.72.18.48 查看 NAT 配置状态： 1sudo iptables -t nat -v -L PREROUTING -n 现在即可通过宿主机的 IP 访问宿主机上容器化的 VoIP 服务了。 Asterisk 网络配置配置 Asterisk 的 SIP 参数： externip 为 192.168.0.107 localnet 为 10.72.18.0/24 这样 VoIP 服务才能向 SIP 终端正确地发送 contact 参数，否则终端与服务器的 SIP 协议交互会出错。 直接使用 FreePBX 完成配置（Settings -&gt; Asterisk SIP Settings）： 总结本文详细介绍了如何将 VoIP 服务容器化，涉及的内容包括 LXD 的使用、systemd-nspawn 的使用、根文件系统制作、容器镜像制作以及和 VoIP 服务相关的网络配置。通过容器化的操作能让各平台的运行环境保持一致，减少开发人员不必要的时间损耗。至于选择 LXD 作为实现容器化的平台原因有2： VoIP 服务软件组成复杂，部署在一个带根文件系统的容器中更为方便； LXD 的实现性能较好，关于业界几种容器化工具的性能对比分析请参考论文 Performance analysis of multi services on container Docker, LXC, and LXD","categories":[],"tags":[{"name":"LXD","slug":"LXD","permalink":"https://clarenceyk.github.io/tags/LXD/"},{"name":"VoIP","slug":"VoIP","permalink":"https://clarenceyk.github.io/tags/VoIP/"},{"name":"Asterisk","slug":"Asterisk","permalink":"https://clarenceyk.github.io/tags/Asterisk/"},{"name":"FreePBX","slug":"FreePBX","permalink":"https://clarenceyk.github.io/tags/FreePBX/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://clarenceyk.github.io/tags/systemd-nspawn/"}]},{"title":"【OSTEP 练习题】测量操作系统切换上下文的耗时","slug":"ostep-measure-cost-of-context-switch","date":"2020-07-11T08:49:16.000Z","updated":"2021-03-02T02:47:19.000Z","comments":true,"path":"2020/07/11/ostep-measure-cost-of-context-switch/","link":"","permalink":"https://clarenceyk.github.io/2020/07/11/ostep-measure-cost-of-context-switch/","excerpt":"尝试解答 OSTEP 1 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。","text":"尝试解答 OSTEP 1 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。 环境使用的测试平台 CPU 是 Intel i5-6200U，主频 2.3GHz，操作系统是 Arch Linux，内核版本 5.7.7。 方法为了尽量准确地测量进程上下文切换耗时，需要有如下几个前提： 创建 2 个测试进程； 保证这 2 个进程运行在同一个 CPU 核上（鉴于目前的计算平台一般为多核 CPU）； 保证正在运行这 2 个测试进程的 CPU 核上没有运行其他用户进程； 尽量使操作系统在指定时刻执行进程调度（与此同时执行上下文切换）。 进程创建使用 fork 系统调用创建子进程： 12345678910switch (fork()) &#123;case -1: // error handling exit(EXIT_FAILURE);case 0: // child process // do something in child process exit(EXIT_SUCESS);default: // parent process // do something in parent process exit(EXIT_SUCESS);&#125; sched_setaffinity使用 sched_setaffinity 指定进程运行在 CPU3 这个核心上： 1234567891011#define CPU_NUM 3cpu_set_t set;CPU_ZERO(&amp;set);CPU_SET(CPU_NUM, &amp;set);if (sched_setaffinity(getpid(), sizeof(set), &amp;set) &lt; 0) &#123; // error handling&#125;// set successfully// do other things 此操作只需在父进程 fork 子进程之前执行即可，子进程默认情况下会和父进程运行在同一个 CPU 核上。 内核启动参数为了保证指定的 CPU 核上只有用于测试的 2 个用户进程，需要设置 isolcpus 这个启动参数给内核。此参数告诉内核在调度其余用户进程时排除指定的 CPU 核心。 12cat /proc/cmdline# BOOT_IMAGE=... isolcpus=3 ... 重新启动计算机，在进入 GRUB 启动界面时选择启动项并按下 e，进入启动项编辑界面，找到 linux 为开头的一行在行尾添加如下启动参数： 1isolcpus=3 # 3 代表测试平台中 CPU 的一个核的编号 查看设备 CPU 核心数可在进入系统后命令行执行： 1lscpu 或者： 1cat /proc/cpuinfo 设置完后可以用 stress 命令测试一下： 12sudo pacman -S stressstress --cpu 8 从下图可以看出内核在调度用户进程时绕开了 CPU3（从 0 开始计数）。 Pipe以上几个步骤保证了在 CPU3 核心上只有用于测试的 2 个用户进程，接下来只需要让内核来回切换（调度）这 2 个测试进程即可。 使用的方法是：创建 2 个 pipe，子进程向 pipe0 写入一个字符然后从 pipe1 读取一个字符，父进程从 pipe0 读取一个字符然后将读取到的字符写入 pipe1，这样重复 N/2 次。当子进程在“等待”读取时内核就执行调度切换到父进程，当父进程在“等待”读取时内核执行调度切换到子进程，所以测试进程一次“读写”完成后内核执行了 2 次上下文切换，既总共完成了 N 次切换。更加直观的过程如题图所示。 结果在我的平台2 上的测试结果为：操作系统上下文切换平均耗时 3.42 微秒。 源码 注释[1] Operating System: Three Easy Pieces - ARPACI-DUSSEAU[2] Intel i5-6200U @ 2.3GHz, Arch Linux, Kernel 5.7.7","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://clarenceyk.github.io/tags/Operating-System/"},{"name":"Context Switch","slug":"Context-Switch","permalink":"https://clarenceyk.github.io/tags/Context-Switch/"}]},{"title":"复刻 Linux 操作系统到另一台设备","slug":"复刻-Linux-操作系统到另一台设备","date":"2020-05-08T06:32:27.000Z","updated":"2020-05-08T09:42:17.000Z","comments":true,"path":"2020/05/08/复刻-Linux-操作系统到另一台设备/","link":"","permalink":"https://clarenceyk.github.io/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/","excerpt":"rsync 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 rsync 作为核心工具来介绍如何复刻 Linux 操作系统。","text":"rsync 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 rsync 作为核心工具来介绍如何复刻 Linux 操作系统。 准备工作需要注意的是源设备和目标设备之间的 CPU 架构需保持一致。 硬件 一台被复刻的设备作为源设备（参考搭建 IPPBX 基础开发环境） 一台新设备作为目标设备 一个 Linux USB 启动盘（制作方法网络上很多这里不多作介绍，我制作的是 Debian10 USB 启动盘） 软件 rsync openssh-server（可选） 配置源设备在搭建 IPPBX 基础开发环境一文中我们已经搭建好了一个开发环境，其中的 /dev/sdb2 设备里包含了一个完整的用于生产环境的操作系统。现在我们将 /dev/sdb2 用作拷贝源。 源设备网络简单的方法是将源设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和目标设备直接连接的方式，则需要自己配置静态 IP 地址。 挂载 /dev/sdb212sudo mkdir -p /mnt/debian_10sudo mount /dev/sdb2 /mnt/debian_10 安装&amp;配置 rsync1234567891011121314$ sudo -ienter your passwd:apt install rsynccat &lt;&lt; EOF &gt; /etc/rsyncd.confuid = rootgid = rootuse chroot = no[all] path = /EOFrsync --daemonexit 配置目标设备将目标设备从 USB 启动盘启动，然后将必备的软件安装好。 目标设备网络简单的方法是将目标设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和源设备直接连接的方式，则需要自己配置静态 IP 地址。 使用 rsync 复刻系统使用 rsync 将源设备上 Linux 系统复刻到目标设备上的方法有两种： 使用脚本操作 手动操作 推荐使用脚本，用 root 用户执行脚本之后根据提示信息操作即可。如果需要手动操作，则接着往下看（后面的操作均使用 root 用户执行）。 对目标硬盘分区首先查看一下分区信息： 1234567$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 119.2G 0 disk├─sda1 8:1 0 4G 0 part└─sda2 8:2 0 115.2G 0 partsdb 8:16 1 14.3G 0 disk└─sdb1 8:17 1 14.3G 0 part / 其中 sdb 是 USB 启动盘 sda 是目标设备上的硬盘。对 sda 分区： 1234567dd if=/dev/zero of=/dev/sda bs=1024 count=1sfdisk --force /dev/sda &lt;&lt; EOF1M,4G,S,,,L,*EOFmkswap /dev/sda1mkfs.ext4 /dev/sda2 这里我们将 sda 划了2个分区，第一个是4G的交换分区，剩余的空间划分为系统分区并格式化为 ext4 文件系统（分区方式需和源设备保持一致）。 从源设备同步文件首先将刚刚创建好的系统分区挂载到本地目录： 12mkdir -p /mnt/rsync_tmpmount /dev/sda2 /mnt/rsync_tmp 检查一下与源设备的连通性（假定源设备的 IP 地址是 192.168.198.140）： 1ping -c 1 192.168.198.140 开始同步： 1rsync -avHX 192.168.198.140::all/mnt/debian_10/ /mnt/rsync_tmp/ 注意：路径结尾处的 / 必须有。 重新安装 GRUB 启动器从源设备同步完成之后，目标设备上的 GRUB 启动器以及其配置都未更新，所以需要更新。 首先获取2个分区的 UUID： 1234$ blkid /dev/sda1/dev/sda1: UUID=&quot;XXXX&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;XXX&quot;$ blkid /dev/sda2/dev/sda2: UUID=&quot;XXXX&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;XXX&quot; 将对应分区的 UUID 更新到 /mnt/rsync_tmp/etc/fstab 文件中后执行： 12345mount --bind /proc /mnt/rsync_tmp/procmount --bind /sys /mnt/rsync_tmp/sysmount --bind /dev /mnt/rsync_tmp/devmount --bind /run /mnt/rsync_tmp/runchroot /mnt/rsync_tmp 进入到 chroot 环境后，更新 GRUB： 12grub-install /dev/sdaupdate-grub 重启设备1reboot 进入 BIOS 中将启动设备设置为硬盘后启动，即可进入完成复刻的 Linux 系统。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"rsync","slug":"rsync","permalink":"https://clarenceyk.github.io/tags/rsync/"},{"name":"clone file system","slug":"clone-file-system","permalink":"https://clarenceyk.github.io/tags/clone-file-system/"}]},{"title":"搭建 IPPBX 基础开发环境","slug":"搭建-IPPBX-基础开发环境","date":"2020-05-06T05:58:46.000Z","updated":"2020-05-08T09:42:23.000Z","comments":true,"path":"2020/05/06/搭建-IPPBX-基础开发环境/","link":"","permalink":"https://clarenceyk.github.io/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。","text":"软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。 需求整个开发环境里有如下设备： 一台开发机，包含2块硬盘 N 台目标设备（最终业务运行在这些设备上） 实际的开发场景应该是：开发机随时运行着，其运行状态为：2块硬盘各有一个 Linux 操作系统，其中一个为主系统另一个以类似容器的形式运行在主系统中。主系统中只安装各类开发工具，不运行任何与项目业务相关的服务，所有和项目业务相关的服务都运行在“容器1”中。开发人员通过 SSH 远程登陆到主系统中完成开发，或者本地开发完成后将软件服务同步到主系统，维护人员再将新的内容同步到“容器”中。 实际的系统部署场景应该是：当需要将系统部署到新设备上时，维护人员只需将开发机上2块硬盘中存放“容器”的那块硬盘中的数据“拷贝2”到新设备的硬盘中即可。 目标在着手搭建环境之前需要了解清楚开发环境搭建针对的目标，本例中的目标很简单只有如下2个： 便于开发工作的进行。 能方便地将完成了开发工作的系统部署到新设备上。 拆分需求结合前面需求和目标可得到如下细分的功能： 开发机上需要在其中一块硬盘中安装并运行一个 Linux 操作系统。 开发机上的另一块硬盘安装一个 Linux 操作系统，此系统能脱离主系统独立运行，同时又能作为“容器”运行在主系统之中。 需要一个同步方法，能将“容器”同步到新设备的硬盘中。 选择操作系统及软件工具对于开发机的主操作系统这部分没有严格的要求，选择一个适合自己使用习惯的较新的 Linux 发行版即可，这里作为演示我选择的是 Ubuntu20.04。 容器中运行的操作系统，同时也是最终设备中运行的操作系统，这部分对系统的稳定性以及很多软件的兼容性要求更高一些，所以我们选择 Debian10。 对于“容器化”的部分，目前有很多容器化技术，如功能非常少但使用非常简单的 chroot（甚至不能作为容器技术🙈）；又如功能非常强大但使用起来有一定门槛的 docker、podman 或者 Ubuntu 推出的 LXC 等；还有介于前面两种之间的 systemd-nspawn。鉴于本例中的使用场景，我们选择 systemd-nspawn，因为其不仅能在我们的需求范围内很好地隔离主系统与“容器”而且使用方法相对简单。 对于“同步”这部分，我们选择 rsync，这是一个基于增量传输的文件同步软件，既可用通过单机本地同步也可通过网络同步，能满足我们开发环境中的同步需求。 安装主系统主操作系统我们选用的是 Ubuntu20.04 安装方法网络上很多，搜索一下即可，这里不再介绍。 容器中的系统本例中我们采用的是 Debian10，安装方法同上。值得注意的是，此系统需安装到开发机的另一块硬盘上，同时在安装前可先取下安装了主系统的硬盘，这样主系统的启动条目就不会出现在“容器”的 grub 启动选项中。此外，分区方式推荐如下： 123sdb 8:16 0 232.9G 0 disk├─sdb1 8:17 0 16G 0 part [SWAP]└─sdb2 8:18 0 216.8G 0 part 其中交换分区根据自己的实际需求划分，剩下的空间全部作为 / 分区。 工具软件在主系统中安装软件包 systemd-contianer（此中软件包中包含 systemd-nspawn 工具）以及安装同步工具 rsync。 123sudo apt updatesudo apt install systemd-contianersudo apt install rsync 注：关于使用 rsync 来同步容器到新设备的方法放在另一篇文章中阐述。 运行“容器”将2块装好了操作系统的硬盘都接到主板上，然后启动开发机进入 BIOS 将装有 Ubuntu20.04 操作系统的硬盘设置到启动序列的第一位。进入主系统后，查看硬盘分区，大致如下： 12345678$ lsblksda 8:0 0 931.5G 0 disk├─sda1 8:1 0 15.3G 0 part [SWAP]├─sda2 8:2 0 122.1G 0 part /└─sda3 8:3 0 794.2G 0 part /homesdb 8:16 0 232.9G 0 disk├─sdb1 8:17 0 16G 0 part└─sdb2 8:18 0 216.8G 0 part 其中 sda 中安装了我们的主系统（Ubuntu）也就是当前运行的系统，sdb 中安装了“容器”的系统（Debian）。 创建挂载点 1sudo mkdir /mnt/debian_10 挂载 sdb 中的文件系统 1sudo mount /dev/sdb2 /mnt/debian_10 使用 systemd-nspawn 进入“容器”环境 12345678910111213$ sudo systemd-nspawn -D /mnt/debian_10 -bpawning container debian10 on /mntdebian_10.Press ^] three times within 1s to kill container....Welcome to Debian GNU/Linux 10 (buster)!...Debian GNU/Linux 10 debian consoledebian login: 到此我们就进入了“容器”环境。在容器内部我们可以认为在另一个操作系统里，于是可以执行任何命令以及安装各种软件但是并不影响主系统。例如我们可以安装 Asterisk 与 FreePBX 退出容器 1sudo shutdown now 或者在 1s 内按下 ^] 3次。（control 键 + ] 键） 容器中安装平台环境SSH1234sudo apt updatesudo apt install openssh-serversudo systemctl start sshsudo systemctl enable ssh Asterisk参考 Asterisk 自动安装脚本。 注意：此脚本仅在 Ubuntu18.04 以及 Debian10 中测试通过。 FreePBX参考 FreePBX 自动安装脚本。 注意：此脚本仅在 Ubuntu18.04 以及 Debian10 中测试通过。 总结本文介绍了 搭建 IPPBX 基础开发环境 中的操作系统、工具软件选择以及容器的制作与运行。下一篇将接着介绍如何将容器同步到新设备上。 注释[1] 这里的容器不是指完整的容器技术，仅仅采用了 Linux 容器的概念。 [2] 只借用“拷贝”的概念，实际操作要更复杂一些。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://clarenceyk.github.io/tags/systemd-nspawn/"},{"name":"rsync","slug":"rsync","permalink":"https://clarenceyk.github.io/tags/rsync/"}]},{"title":"简明架构","slug":"简明架构","date":"2020-03-28T14:30:44.000Z","updated":"2020-03-30T16:34:12.000Z","comments":true,"path":"2020/03/28/简明架构/","link":"","permalink":"https://clarenceyk.github.io/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/","excerpt":"最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。 原文地址： The Clean Architecture","text":"最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。 原文地址： The Clean Architecture 以下为译文。 在过去的几年间我们已经看到过各种各样关于系统架构的设想，如下： 来自 Alistair Cockburn 的六边形架构（也称接口与适配），此架构被 Steve Freeman 与 Nat Pryce 在其合著的《测试驱动的面向对象软件开发》一书中采纳 来自 Jeffrey Palermo 的洋葱架构 我去年在博客中提出的令人惊叹的架构 由 James Coplien 和 Trygve Reenskaug 提出的 DCI Ivar Jacobson 在其所著的《实例驱动的面向对象软件工程》一书中提出的 BCE 虽然以上这些架构都在细节上有所不同，但在宏观上非常相似。它们有同一个的目标，关注对软件的拆分，通过将软件分解为不同的层次，以达到拆分的目的。每种架构都至少有一层用于描述业务规则，其他层次用于创建接口。 使用这些架构所产生的系统都有以下特点： 独立于框架。架构不依赖于功能丰富的软件库。这让你能够将软件框架作为工具使用，而不用为了使用框架将其塞入系统以满足框架的限制。 可测试。业务规则能够在没有界面、数据库、Web 服务器或其他元素的情况下被测试。 独立于界面。可以在不改变系统其余部分的情况下很容易地修改界面。例如，可以将 Web 界面改为命令行界面却不改变业务规则。 独立于数据库。你可以随时弃用 Oracle 或 SQL Server 的数据库改为使用 Mongo、BigTable、CouchDB 或者其他数据库。因为你的业务规则不与数据库绑定。 独立于任意外部机构。事实上你的业务规则根本对外部世界一无所知。 依赖规则图中每一个同心圆表示不同领域的软件。通常，项目开发得越久软件所处的层级越高。外层圆是机制，内层是策略。 使这个架构能够正常运转而起到决定性作用的规则是依赖规则。这个规则描述了源代码的依赖关系只能由外部指向内部，处于内圈的代码对处于外圈的代码一无所知。特别的，在外圈定义的对象的名称必不能被处于内圈的代码提及。这些对象包括：函数、类、变量或者其他有名称的软件实体。 出于同样的原因，在外圈使用的格式化数据不应该在内圈被使用，特别是由某种软件框架产生的格式化数据。我们不希望外圈的任何事物影响到内圈。 实体实体封装了企业范围内的业务规则。实体可以是携带方法的对象也可以是由数据结构和函数组成的集合。实体只要能被企业中不同的应用程序使用即可，具体是什么则无关紧要。 如果你没有开发企业级软件而是在写单个应用程序，那么这些实体可以是应用程序的业务对象，其中封装了最普遍最高层次的规则。如果架构的外围发生了改变那么实体将会是最后一个需要修改的。例如，你不希望当页面导航或者安全保护方面产生了变更而影响到实体。总的来说，任意指定程序的操作变更都不应影响实体层。 用例处于这一层的软件包含面向应用程序的业务规则，封装和实现所有系统用例。这些用例编排数据流动包括流向实体和从实体流入，以及引导实体使用企业业务规则来实现用例的目的。 同样，我们不希望这一层的变更影响实体。也不希望这一层受到外部变更的影响，比如数据库、UI 或者任意软件框架，此层与这些情况无关。 可以预期，应用程序操作的变更会影响用例进而影响处于此层的软件。如果用例本身发生了变化，那么处于此层的代码一定会受到影响。 接口适配器处于此层的软件通常是一组适配器。适配器的作用是将方便于用例和实体使用的数据格式转换为方便外部机构使用的数据格式。外部机构包括数据库、Web 等。比如在此层中会完全包含图形用户界面的 MVC 架构，表示器、视图以及控制器都属于此层。模型一般表示为数据结构，从控制器传给用例，再从用例返回到表示器和视图。 类似的，数据从方便用例和实体使用的形式转换到方便持久化框架（如数据库）使用的形式也发生在此层。从这一层向内的所有代码都对数据库不了解。如果数据是 SQL 数据库那么所有的 SQL 语句都应该被限制在此层用于与数据库交互的部分。 当然此层还有另一种必备的适配器，用于将来自外部服务的数据格式转换为用例和实体使用的内部数据格式。 框架和驱动最外一层通常是由软件框架与工具组成，例如数据库、Web 开发框架等。一般你不需要在此层写大量代码而是写一些“胶水”代码用于与紧邻的内层通信。 这一层是所有具体细节出现的地方，例如 Web、数据库都充满各种细节需要关注，将这类事物放到最外层可以最大可能地减少对整体系统的影响。 仅有四层？不是，此图只是概念展示。在实际操作中你会发现所需的不止四层，也没有规定一定只能有四层。无论怎样依赖原则始终有效，即源代码总是向内依赖。越往内越抽象。最外圈是最低层次包含最具体的细节，越往内软件越为抽象封装更高层次的策略，最中心的圈也就最一般化。 跨越边界在图示中的右下角可以看到一个示例展示了我们如何跨越不同层次的边界。可以看到控制器和表示器通过它们隔壁层的用例来互相通信。注意控制的流向，它从控制器开始，通过用例最后在表示器中执行以结束。在看源代码的依赖方向，它们都向内指向用例，这就产生了矛盾。 通常我们使用依赖倒置原则解决这个显而易见的冲突。诸如 Java 一类的编程语言我们可以通过组织一组接口和类继承关系使得在适当的时候让源代码的依赖方向和控制方向相反以实现跨越边界。 例如，考虑当用例需要调用表示器的情况。这种调用方式必不能直接实现，因为这样违反了依赖原则：内部事物对外部一无所知。因此我们让用例定义以及调用接口（interface）也就是图中内圈的 Use Case Output Port，而让外圈的表示器实现这个接口（interface）。 这个技巧可以用在整个架构中所有需要跨越边界的地方。我们利用面向对象编程语言的动态多态性这个特点创建与控制流向相反的源代码依赖。这样不论控制流动的方向是什么我们都能让设计符合依赖原则。 哪些数据会跨越边界一般跨越边界的是简单的数据结构。可以根据自己的需要选择基本数据结构或者简单的数据传输对象或者函数调用时传入的参数，也可以将数据打包进哈稀表或者构建到对象里，关键在于用于跨越边界的数据要足够简单和具备独立性。我们并不希望让实体或数据库的原始数据行跨越边界，同样不希望跨越边界的结构里包含任意会违背依赖原则的数据。 比如，许多数据库框架会用便于使用的数据格式作为查询的响应，我们把这样的数据称为 RowStructure。我们不希望跨越边界时传递这样的结构，这样可能会违背依赖原则因为这有几率迫使内部的代码必须了解外部的数据定义。 因此，我们传递的数据跨越边界时，最常用是便于内层使用的格式。 总结遵循这些简单的规则并不费劲，并且可以省去开发过程中很多麻烦。将整体软件分层并配合依赖原则，你可以创建一个具备极好测试性的系统，这会带来非常多的好处。当系统外部任意部分成为了整体系统的瓶颈，如数据库或者 Web 开发框架，你能只花很小的代价就将其撤换。","categories":[],"tags":[{"name":"Architecture","slug":"Architecture","permalink":"https://clarenceyk.github.io/tags/Architecture/"},{"name":"Software Design","slug":"Software-Design","permalink":"https://clarenceyk.github.io/tags/Software-Design/"}]},{"title":"用 Go 语言控制 GPIO","slug":"用-Go-语言控制-GPIO","date":"2020-03-18T10:28:40.000Z","updated":"2020-03-18T13:25:30.000Z","comments":true,"path":"2020/03/18/用-Go-语言控制-GPIO/","link":"","permalink":"https://clarenceyk.github.io/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/","excerpt":"GPIO 也就是通用输入/输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 mmap 系统调用来完成控制的方法。","text":"GPIO 也就是通用输入/输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 mmap 系统调用来完成控制的方法。 软硬件环境 CPU: iMX6Q(ARM) Kernel: Linux 4.19.72 OS: Ubuntu18.04 GPIO 控制流程简介iMX6Q 芯片手册上有如下描述: 由此可知读取 GPIO 某一个管脚上的信号分为3个步骤: 配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。 配置管脚方向寄存器，设置此管脚为输入。 从管脚数据寄存器中读取值。 反之，如果要向外输出信号则为以下3步骤: 配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。 配置管脚方向寄存器，设置此管脚为输出。 向管脚数据寄存器写入值。 寄存器地址iMX6Q 有7组 GPIO 每组有8个 32-bit 的寄存器，每个寄存器上 1-bit 控制着其对应的1个管脚的配置，也就是每组 GPIO 有32个管脚，每个管脚有8个配置项。关于 iMX6Q GPIO 更为详细的介绍可参阅 Definitive GPIO guide。 对于只使用输入/输出功能的情况，8个寄存器中我们只需关心数据寄存器和方向寄存器这2个（对于管脚复用寄存器，因为默认状态下几乎所有管脚都是 GPIO 模式所以基本不用关心，具体情况请参考芯片手册）。 GPIO 控制寄存器的基地址为 0x0209C000，地址宽度为 0x4000 也就是第一组 GPIO 的控制寄存器在地址 0x0209C000 上，第二组在 0x020A0000，以此类推。每一个寄存器是 32-bit 大小所以，第一组 GPIO 的数据寄存器在 0x0209C000 方向寄存器在 0x0209C004，如下图: 由此可以在代码中做如下定义: gpio_imx6q.go1234const ( gpioBaseAddr uint32 = 0x0209C000 gpioAddrWidth uint32 = 0x4000) 对于指定的某一组 GPIO 的寄存器地址可这样获得: gpio_imx6q.go1234func getGPIOMMapper(group int) ([]uint32, error) &#123; gaddr := gpioBaseAddr + (uint32(group)-1)*gpioAddrWidth // ...&#125; 内存地址转换当程序运行起来后操作系统为每一个进程分配了一个虚拟地址空间，而寄存器的地址在实地址空间中，所以需要使用内存地址转换将实地址映射到虚拟地址空间，这样我们才能通过内存地址访问 GPIO 寄存器。 执行终端命令 man mmap 可查阅关于 mmap 详细的资料，这里我们通过 Go 语言 unix 包中封装的 Mmap 函数来使用 mmap 系统调用，如下: gpio_imx6q.go12345678func getGPIOMMapper(group int) ([]uint32, error) &#123; // ... b, err := unix.Mmap(int(memMapFile.Fd()), int64(gaddr), 8, unix.PROT_READ|unix.PROT_WRITE, unix.MAP_SHARED) if err != nil &#123; return nil, err &#125; // ...&#125; 其中指定映射的地址长度为8字节，原因是这里我们只使用前2个寄存器。memMapFile 可由如下函数获得: gpio_imx6q.go12345func initGPIOMemMap() *os.File &#123; file, err := os.OpenFile(&quot;/dev/mem&quot;, os.O_RDWR, 0600) check(err) return file&#125; 完成地址转换之后 unix.Mmap 函数返回一个 byte 类型的切片，而每个寄存器是 32-bit 宽度，也就是一个寄存器对应 4 个 byte，这样操作起来比较麻烦。为了简化操作可以将 []byte 转换为 []uint32 类型: gpio_imx6q.go1234567func byte2uint32(b []byte) []uint32 &#123; sl := reflect.SliceHeader&#123;&#125; sl.Cap = len(b) / 4 sl.Len = len(b) / 4 sl.Data = uintptr(unsafe.Pointer(&amp;b[0])) return *(*[]uint32)(unsafe.Pointer(&amp;sl))&#125; 通过 GPIO 外设输出或读取值完成以上操作之后，假定得到的内存映射保存在 var mapper []uint32 中。如果我们要设置管脚 10 为输出，并且对外输出高电平，则可通过以下操作完成: gpio_imx6q.go1234// 设置方向寄存器中第 10 bit 为1表示管脚10为输出mapper[1] = mapper[1] | uint32(0x00000001&lt;&lt;10)// 设置数据寄存器中第 10 bit 为1表示管脚10输出高电平mapper[0] = mapper[0] | uint32(0x00000001&lt;&lt;10) 如果我们要设置管脚 10 为输入，并且读取管脚上的电平信息，则可通过以下操作完成: gpio_imx6q.go1234// 设置方向寄存器中第 10 bit 为0表示管脚10为输入mapper[1] = mapper[1] &amp; ^uint32(0x00000001&lt;&lt;10)// 读取数据寄存器中第 10 bit 的值value := mapper[0] &amp; uint32(0x00000001&lt;&lt;10) 总结本文介绍了 GPIO 的基本操作、iMX6Q GPIO 外设寄存器的分布以及 Go 语言中使用内存映射的方法，最后实现了使用 Go 语言对 GPIO 进行控制。对于以上的过程我们可以进一步将其封装成 struct 方便使用，类似如下: gpio_imx6q.go123456789type GPIOPin struct &#123; Group int Pin int mmapper []uint32&#125;func (pin *GPIOPin) SetDir(dir string) &#123;&#125;func (pin *GPIOPin) Direction() string &#123;&#125;func (pin *GPIOPin) Set(v string) &#123;&#125;func (pin *GPIOPin) Read() string &#123;&#125; 除了内存映射之外，还可以使用其他方法操作 GPIO，例如通过 sysfs 文件系统或者使用 /dev/gpiochip 设备文件等，这里就不做过多介绍了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"GPIO","slug":"GPIO","permalink":"https://clarenceyk.github.io/tags/GPIO/"},{"name":"memory map","slug":"memory-map","permalink":"https://clarenceyk.github.io/tags/memory-map/"}]},{"title":"iMX6Q 2GB 内存支持","slug":"iMX6Q-2GB-内存支持","date":"2020-03-16T08:18:41.000Z","updated":"2020-03-16T13:19:28.000Z","comments":true,"path":"2020/03/16/iMX6Q-2GB-内存支持/","link":"","permalink":"https://clarenceyk.github.io/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/","excerpt":"iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。","text":"iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。 系统启动过程现象系统启动过程中可看到 U-Boot 输出如下信息: 终端输出1234567891011U-Boot 2019.10-rc1-00134-gacda5922db-dirty (Mar 16 2020 - 15:27:54 +0800)CPU: Freescale i.MX6Q rev1.6 996 MHz (running at 792 MHz)CPU: Automotive temperature grade (-40C to 125C) at 36CReset cause: PORModel: Freescale i.MX6 Quad SABRE Smart Device BoardBoard: MX6-SabreSDI2C: readyDRAM: 1 GiBPMIC: PFUZE100 ID=0x10MMC: FSL_SDHC: 0, FSL_SDHC: 3 其中 DRAM: 1 GiB 这一行表示 U-Boot 识别到的内存空间大小为 1GB。 进入操作系统之后，终端执行如下命令: 终端输出123ubuntu@arm:~$ cat /proc/meminfoMemTotal: 1031138 kB... 可知操作系统识别到的内存空间大小也是 1GB。 识别内存大小的过程查看 U-Boot 源码，初始化函数 board_init_f 会执行一系列初始化操作: u-boot/common/board_f.c12if (initcall_run_list(init_sequence_f)) hang(); init_sequence_f 是一个数组，所有初始化函数都放在这个数组中，其中有2个函数: imx6q/u-boot/common/board_f.c123456static const init_fnc_t init_sequence_f[] = &#123; // ... announce_dram_init, dram_init, /* configure available RAM banks */ // ...&#125; announce_dram_init 函数只有一行代码作用是输出 DRAM:。真正需要我们关心的是 dram_init，这个函数继续调用了另一个函数 imx_ddr_size，接着往下追发现如下注释信息: u-boot/arch/arm/mach-imx/cpu.c1234567891011/* * imx_ddr_size - return size in bytes of DRAM according MMDC config * The MMDC MDCTL register holds the number of bits for row, col, and data * width and the MMDC MDMISC register holds the number of banks. Combine * all these bits to determine the meme size the MMDC has been configured for */unsigned imx_ddr_size(void)&#123; struct esd_mmdc_regs *mem = (struct esd_mmdc_regs *)MEMCTL_BASE; // ...&#125; 可看到函数 imx_ddr_size 根据 MMDC 的配置返回内存空间大小，配置信息存储在寄存器 MMDC_MDCTL 中。 适配 2GB 内存从前面的代码中可看到寄存器 MMDC_MDCTL 的地址在定义 MEMCTL_BASE 中，接着查看 MEMCTL_BASE 的定义，可得到如下信息: 12345678910111213141516MEMCTL_BASE | vMMDC_P0_BASE_ADDR | vAIPS2_OFF_BASE_ADDR + 0x30000 | vATZ2_BASE_ADDR + 0x80000 + 0x30000 | vAIPS2_ARB_BASE_ADDR + 0x80000 + 0x30000 | v0x02100000 + 0x80000 + 0x30000 &#x3D; 0x021b0000 所以 MMDC_MDCTL 寄存器地址为 0x021b0000。此处代码是从寄存器中读取配置的值，那么一定会有其他的代码去配置这个寄存器的值，继续查找可发现: u-boot/board/freescale/mx6sabresd/mx6sabresd.c123456static int mx6q_dcd_table[] = &#123; //... 0x021b0040, 0x00000027, 0x021b0000, 0x831A0000, //...&#125; 原始 codebase 中向寄存器 MMDC_MDCTL 配置了值 0x831A0000 以及向寄存器 MMDC_MDASP 配置了值 0x00000027。 接着从 iMX6Q 芯片参考手册中可查到寄存器 MMDC_MDCTL 数据位的分配: 从而得知原始代码中，寄存器 MMDC_MDCTL 配置的含义为： 使能 CS0 关闭 CS1 行地址宽度 14bit 列地址宽度 10bit burst 长度 8 数据总线大小 64bit 我们运行平台上的内存芯片和 iMX6Q SABRESD 开发板上的内存芯片是一样的封装，只是容量是后者的2倍，也就是行地址宽度多了1bit，所以将 MMDC_MDCTL 寄存器的值配置为 0x841A0000。 对于寄存器 MMDC_MDASP，芯片手册中描述如下: MMDCx_MDASP[CS0_END] should be set to DDR_CS_SIZE/32MB + 0x7 (DDR base address begins at 0x10000000) Freescalei.MX 6Dual/6Quad Applications Processor Reference Manual 所以寄存器 MMDC_MDASP 的值应该配置为 内存大小/32MB + 0x7 也就是 0x00000047，最后配置如下: u-boot/board/freescale/mx6sabresd/mx6sabresd.c123456static int mx6q_dcd_table[] = &#123; //... 0x021b0040, 0x00000047, 0x021b0000, 0x841A0000, //...&#125; 设备树修改将 U-Boot 以及内核设备树与内存大小相关的地方修改为 2GB: u-boot/arch/arm/dts/imx6qdl-sabresd.dtsi123memory@10000000 &#123; reg = &lt;0x10000000 0x80000000&gt;;&#125;; 最后，将以上修改保存到设备中，启动系统之后可以看到 U-Boot 以及操作系统均识别到 2GB 内存空间。 总结本文介绍了 U-Boot 在启动时识别内存大小的过程，以及 iMX6Q 关于内存信息的几个寄存器的配置，最终实现让系统平台识别并且使用 2GB 内存空间。","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"内存拓展","slug":"内存拓展","permalink":"https://clarenceyk.github.io/tags/%E5%86%85%E5%AD%98%E6%8B%93%E5%B1%95/"}]},{"title":"Linux 系统中 Watchdog 的应用","slug":"Linux-系统中-Watchdog-的应用","date":"2020-02-22T02:08:56.000Z","updated":"2020-02-23T09:43:09.000Z","comments":true,"path":"2020/02/22/Linux-系统中-Watchdog-的应用/","link":"","permalink":"https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"本文将介绍如何在 Linux 系统的用户层使用 Watchdog。","text":"本文将介绍如何在 Linux 系统的用户层使用 Watchdog。 操作环境 硬件环境: iMX6Q SABRE-SD 开发板 操作系统内核: Linux 4.19.72-armv7 操作系统发行版: Ubuntu18.04 开启 Watchdog在编译内核时开启 Watchdog: ./tools/rebuild.sh12# 内核配置选项位置Device Drivers -&gt; Watchdog Timer Support 开启 Disable watchdog shutdown on close 这一项。 内核文档中关于此选项的解释如下: When the device is closed, the watchdog is disabled, unless the “MagicClose” feature is supported (see below). This is not always such a good idea, since if there is a bug in the watchdog daemon and it crashes the system will not reboot. Because of this, some of the drivers support the configuration option “Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT. If it is set to Y when compiling the kernel, there is no way of disabling the watchdog once it has been started. So, if the watchdog daemon crashes, the system will reboot after the timeout has passed. Watchdog devices also usually support the nowayout module parameter so that this option can be controlled at runtime. Magic Close feature: If a driver supports “Magic Close”, the driver will not disable the watchdog unless a specific magic character ‘V’ has been sent to /dev/watchdog just before closing the file. If the userspace daemon closes the file without sending this special character, the driver will assume that the daemon (and userspace in general) died, and will stop pinging the watchdog without disabling it first. This will then cause a reboot if the watchdog is not re-opened in sufficient time. Christer WeingelThe Linux Watchdog driver API. 简单来说，开启此选项之后一旦我们打开了 Watchdog 设备，只要程序没对此 Watchdog 做文档中指定的操作，那么 Watchdog 就会重启系统。 基本操作操作系统内核会将 CPU 芯片上的 Watchdog 外设抽象为文件系统中的一个字符设备: ubuntu@arm:~$12ls /dev/watchdog*# /dev/watchdog /dev/watchdog0 上面命令列出来系统中的 Watchdog 设备（/dev/watchdog、/dev/watchdog0 在底层指向同一个硬件）。使用其中任一设备都可以。 打开设备 api_watchdog_open1watchdog_fd = open(watchdog_dev, O_RDWR); 根据头文件 linux/watchdog.h 中的定义，我们可以通过得到的文件描述符对 watchdog 设备做后面这些操作。 设置 watchdog 超时时间 api_watchdog_settimeout1ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &amp;seconds); feed watchdog api_watchdog_feed1ioctl(watchdog_fd, WDIOC_KEEPALIVE, NULL); 可以将上面的这些操作封装成函数接口，在函数内部做一些错误处理。 测试main.c1234567891011121314int main(void)&#123; struct timespec wait_time = &#123; 1, 0 &#125;; if (api_watchdog_init(WATCHDOG_DEV, WATCHDOG_TIMEOUT) &lt; 0) return -1; printf(&quot;Watchdog opened!\\n&quot;); while (1) &#123; api_watchdog_feed(); nanosleep(&amp;wait_time, NULL); &#125;&#125; 如上，先初始化 watchdog 然后每秒 feed watchdog 一次，此时系统如常运行。当 kill 此程序后，由于前面在内核开启了 Disable watchdog shutdown on close 选项 watchdog 会继续工作，同时没有继续 feed 的操作所以系统进入重启流程。 引入外部 Kick 信号以一个具体的应用场景为例，如下: 硬件连接123------- GPIO --------| CPU | &lt;------ | FPGA |------- -------- FPGA 通过 CPU 的 GPIO 外设向开发板输入一个周期性翻转信号。CPU 在每一个周期开始时重置 watchdog，我们可以检测 GPIO 的上升沿或者下降沿获得周期开始的信息。 对 GPIO 的操作在 Linux 环境中有很多方法实现，这里我们使用 libgpiod 库来实现对 GPIO 上升沿信号的检测。 libgpiod 中封装了很多便于使用的 API。在当前使用场景中，只需调用函数 gpiod_ctxless_event_monitor 就可实现我们想要的功能，其函数签名以及相应的文档注释如下: 1234567891011121314151617181920212223/** * @brief Wait for events on a single GPIO line. * @param device Name, path, number or label of the gpiochip. * @param event_type Type of events to listen for. * @param offset GPIO line offset to monitor. * @param active_low The active state of this line - true if low. * @param consumer Name of the consumer. * @param timeout Maximum wait time for each iteration. * @param poll_cb Callback function to call when waiting for events. * @param event_cb Callback function to call for each line event. * @param data User data passed to the callback. * @return 0 if no errors were encountered, -1 if an error occurred. * @note The way the ctxless event loop works is described in detail in * ::gpiod_ctxless_event_monitor_multiple - this is just a wrapper aound * this routine which calls it for a single GPIO line. */int gpiod_ctxless_event_monitor(const char *device, int event_type, unsigned int offset, bool active_low, const char *consumer, const struct timespec *timeout, gpiod_ctxless_event_poll_cb poll_cb, gpiod_ctxless_event_handle_cb event_cb, void *data) GPIOD_API; 如上可以看出几个关键参数，通过 device、offset 参数指定使用的 GPIO 管脚，event_type 指定检测事件（如，上升沿事件），event_cb 是触发指定事件后调用的回调函数，其调用方法大致如下: 上升沿检测12345// WDOG_GPIO_SIG_CHIP &quot;/dev/gpiochip6&quot;// WDOG_GPIO_SIG_PORT 7gpiod_ctxless_event_monitor(WDOG_GPIO_SIG_CHIP, GPIOD_CTXLESS_EVENT_RISING_EDGE, WDOG_GPIO_SIG_PORT, false, &quot;wdog&quot;, &amp;timeout, NULL, gpio6_port7_rising_edge_handle_cb, NULL); 接下来只需要再定义回调函数即可，回调函数的函数签名如下: 12345678910111213/** * @brief Simple event callback signature. * * The callback function takes the following arguments: event type (int), * GPIO line offset (unsigned int), event timestamp (const struct timespec *) * and a pointer to user data (void *). * * This callback is called by the ctxless event loop functions for each GPIO * event. If the callback returns ::GPIOD_CTXLESS_EVENT_CB_RET_ERR, it should * also set errno. */typedef int (*gpiod_ctxless_event_handle_cb)(int, unsigned int, const struct timespec *, void *); 所以我们定义的上升沿事件回调函数大致如下: 定义回调函数123456789101112int gpio6_port7_rising_edge_handle_cb(int type, unsigned int offset, const struct timespec *timestamp, void *arg)&#123; wdog_count ++; if (wdog_count &gt;= WDOG_FEED_PERIOD / FPGA_WDOG_SIG_PERIOD) &#123; api_watchdog_feed(); wdog_count = 0; &#125; return GPIOD_CTXLESS_EVENT_CB_RET_OK;&#125; 其中关键在于 api_watchdog_feed()。 以上就实现了外部 Kick 信号的引入。 配置 systemd 服务我们希望 watchdog 程序随着系统自动启动，所以配置如下的 systemd 服务: wdog_fpga.service12345678910[Unit]Description&#x3D;Watchdog systemd service.ConditionKernelCommandLine&#x3D;!disable_wdog[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;wdog_fpga[Install]WantedBy&#x3D;multi-user.target 其中我们定义了 ConditionKernelCommandLine 参数为 !disable_wdog。这样当系统启动之后 systemd 会检测内核启动命令行参数中是否存在disable_wdog，如果不存在则启动 watchdog，反之依然。这样配置的好处是，我们可以在系统启动之前配置是否开启 watchdog。 U-Boot 环境设置内核命令行参数如果我们不想开启 watchdog，则在 U-Boot 启动后暂停引导内核，然后将 disable_wdog 参数设置到内核命令行参数中，如下: 1setenv bootargs ... 其他参数 ... disable_wdog 然后再引导内核启动: 1run bootcmd 总结文本介绍了如何在 Linux 操作系统中使用 watchdog，分为以下方面的工作: 内核选项配置 部分 API 介绍 设备操作接口封装 实际应用场景示例","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"Watchdog","slug":"Watchdog","permalink":"https://clarenceyk.github.io/tags/Watchdog/"},{"name":"Embedded System","slug":"Embedded-System","permalink":"https://clarenceyk.github.io/tags/Embedded-System/"}]},{"title":"iMX6Q SABRE-SD 开发板软件烧录","slug":"iMX6Q-SABRE-SD-开发板软件烧录","date":"2020-02-19T09:04:39.000Z","updated":"2020-02-20T14:55:42.000Z","comments":true,"path":"2020/02/19/iMX6Q-SABRE-SD-开发板软件烧录/","link":"","permalink":"https://clarenceyk.github.io/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/","excerpt":"本文将介绍 iMX6Q SABRE-SD 开发板的软件烧录流程。","text":"本文将介绍 iMX6Q SABRE-SD 开发板的软件烧录流程。 软件环境 操作系统: Ubuntu14.04 准备工作 使开发板进入工厂模式具体操作请参考此文档。 开发板系统软件制作开发板系统软件请参考此文档。 烧录流程烧录过程中会使用 utp_com 向开发板发送指令，开发板收到指令后执行。 创建分区表 分区脚本 netop@mfgtools:~/utp_com$12345678910111213141516171819cat &lt;&lt;END &gt;/tmp/mkmmc.sh#!/bin/shnode=\\$1# partition size in MBBOOT_ROM_SIZE=10# wait for the SD/MMC device node readywhile [ ! -e \\$&#123;node&#125; ]dosleep 1echo &quot;wait for \\$&#123;node&#125; appear&quot;done# destroy the partition tabledd if=/dev/zero of=\\$&#123;node&#125; bs=1024 count=1# call sfdisk to create partition tablesfdisk --force \\$&#123;node&#125; &lt;&lt;EOF1M,,L,*EOFEND 发送并执行分区脚本 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;send&quot; -f /tmp/mkmmc.sh./utp_com -d /dev/sg1 -c &quot;$ sh \\$FILE /dev/mmcblk3&quot; 建立 U-Boot 分区 boot 分区写使能 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo 0 &gt; /sys/block/mmcblk3boot0/force_ro&quot; 发送 SPL、U-Boot 并写入 netop@mfgtools:~/utp_com$1234./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;SPL 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ dd if=\\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=1&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;U-Boot 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ dd if=\\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=69&quot; boot 分区只读使能 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo 1 &gt; /sys/block/mmcblk3boot0/force_ro&quot; 使能 boot 分区 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ mmc bootpart enable 1 1 /dev/mmcblk3&quot; 创建系统分区 建立 EXT4 分区 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ while [ ! -e /dev/mmcblk3p1 ]; do sleep 1; echo \\&quot;waiting...\\&quot;; done&quot;./utp_com -d /dev/sg1 -c &quot;$ mkfs.ext4 -L rootfs /dev/mmcblk3p1&quot; 挂载系统分区 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ mkdir -p /mnt/rootfs&quot;./utp_com -d /dev/sg1 -c &quot;$ mount /dev/mmcblk3p1 /mnt/rootfs&quot; 安装操作系统 写入根文件系统 netop@mfgtools:~/utp_com$1234./utp_com -d /dev/sg1 -c &quot;pipe tar -x[文件压缩方式] -C /mnt/rootfs&quot; -f &lt;rootfs 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;frf&quot;./utp_com -d /dev/sg1 -c &quot;$ chown root:root /mnt/rootfs&quot;./utp_com -d /dev/sg1 -c &quot;$ chmod 755 /mnt/rootfs&quot; 设置 uname_r netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo &#x27;uname_r=&lt;内核版本信息&gt;&#x27; &gt;&gt; /mnt/rootfs/boot/uEnv.txt&quot; 写入内核、设备树、内核模块 netop@mfgtools:~/utp_com$1234567./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;kernel 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ cp \\$FILE /mnt/rootfs/boot/vmlinuz-&lt;内核版本信息&gt;&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;dtb 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ mkdir -p /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;./utp_com -d /dev/sg1 -c &quot;$ tar xf \\$FILE -C /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;modules 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ tar xf \\$FILE -C /mnt/rootfs/&quot; 更新 fstab netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo &#x27;/dev/mmcblk2p1 / auto errors=remount-ro 0 1&#x27; &gt;&gt; /mnt/rootfs/etc/fstab&quot; 同步，取消挂载 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ sync&quot;./utp_com -d /dev/sg1 -c &quot;$ umount /mnt/rootfs&quot; 启动开发板将开发板的启动拨码开关拨至 11100110，然后上电启动可看到串口输出: 串口输出12345Ubuntu 18.04.3 LTS arm ttymxc0default username:password is [ubuntu:temppwd]arm login: 总结本文介绍了 iMX6Q SABRE-SD 开发板的软件烧录流程，总结为以下4个步骤: 创建分区表 建立 U-Boot 分区 创建系统分区 安装操作系统","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"}]},{"title":"iMX6Q SABRE-SD 开发板系统软件","slug":"iMX6Q-SABRE-SD-开发板系统软件","date":"2020-02-19T06:34:46.000Z","updated":"2020-02-19T12:38:55.000Z","comments":true,"path":"2020/02/19/iMX6Q-SABRE-SD-开发板系统软件/","link":"","permalink":"https://clarenceyk.github.io/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/","excerpt":"本文将介绍适用于 iMX6Q SABRE-SD 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。","text":"本文将介绍适用于 iMX6Q SABRE-SD 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。 软件环境 操作系统: Ubuntu14.04 ARM 交叉编译工具链 下载 &amp; 解压 netop@mfgtools:~$12wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xztar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz 测试 netop@mfgtools:~$12export CC=`pwd`/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-$&#123;CC&#125;gcc --version 终端输出1234arm-linux-gnueabihf-gcc (Linaro GCC 6.5-2018.12) 6.5.0Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 启动加载器: U-Boot 下载源码 netop@mfgtools:~$123git clone https://github.com/u-boot/u-bootcd u-boot/git checkout v2019.07 -b tmp 打补丁 netop@mfgtools:~/u-boot$12wget -c https://raw.githubusercontent.com/eewiki/u-boot-patches/master/v2019.07-rc4/0001-mx6sabresd-fixes.patchpatch -p1 &lt; 0001-mx6sabresd-fixes.patch 修改代码 用编辑器打开文件 ~/u-boot/include/configs/mx6sabre_common.h，找到如下代码: vi ~/u-boot/include/configs/mx6sabre_common.h123456......#define CONFIG_BOOTCOMMAND \\ &quot;setenv interface mmc;&quot; \\ &quot;setenv mmcdev 0;&quot; \\ &quot;run mmcboot;&quot; \\...... 添加2行代码，结果如下: vi ~/u-boot/include/configs/mx6sabre_common.h12345678......#define CONFIG_BOOTCOMMAND \\ &quot;setenv interface mmc;&quot; \\ &quot;setenv mmcdev 3;&quot; \\ &quot;run mmcboot;&quot; \\ &quot;setenv mmcdev 0;&quot; \\ &quot;run mmcboot;&quot; \\...... 配置 &amp; 编译 netop@mfgtools:~/u-boot$123make ARCH=arm CROSS_COMPILE=$&#123;CC&#125; distcleanmake ARCH=arm CROSS_COMPILE=$&#123;CC&#125; mx6sabresd_defconfigmake ARCH=arm CROSS_COMPILE=$&#123;CC&#125; Linux 内核内核我们采用 4.19 长期支持版。 下载源码 netop@mfgtools:~$123git clone https://github.com/RobertCNelson/armv7-multiplatformcd armv7-multiplatform/git checkout origin/v4.19.x -b tmp 编译 netop@mfgtools:~/armv7-multiplatform$1./build_kernel.sh 根文件系统根文件系统我们采用 Ubuntu18.04 LTS。 下载 netop@mfgtools:~$1wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 验证 netop@mfgtools:~$12sha256sum ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz# 输出信息: b28b356d75153bfb3beb5c96bf8eabe92025cf5e665e1a564b469bc70e5a363b ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 解压 netop@mfgtools:~$1tar xf ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 总结本文介绍了 iMX6Q SABRE-SD 开发板系统软件的制作。通过这些操作可得到以下文件: 启动加载器, 目录: ~/u-boot/ SPL u-boot.img 内核相关，目录: ~/armv7-multiplatform/deploy 4.19.xx-armv7-xxx.zImage 4.19.xx-armv7-xxx-dtbs.tar.gz 4.19.xx-armv7-xxx-modules.tar.gz 根文件系统，目录: ~/imx6q/ubuntu-18.04.3-minimal-armhf-2020-02-10 armhf-rootfs-ubuntu-bionic.tar","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"U-Boot","slug":"U-Boot","permalink":"https://clarenceyk.github.io/tags/U-Boot/"},{"name":"Linux kernel","slug":"Linux-kernel","permalink":"https://clarenceyk.github.io/tags/Linux-kernel/"}]},{"title":"iMX USB loader & UTP 使用方法介绍","slug":"iMX-USB-loader-UTP-使用方法介绍","date":"2020-02-18T06:04:49.000Z","updated":"2020-02-18T09:59:03.000Z","comments":true,"path":"2020/02/18/iMX-USB-loader-UTP-使用方法介绍/","link":"","permalink":"https://clarenceyk.github.io/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。","text":"本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。 在使用 iMX6Q SabreSD 开发板时，如果我们对 Linux 内核或者根文件系统进行了定制则需要将新的软件部署到开发板。将软件部署到开发板的方法与开发板的启动方式有关，如果我们需要开发板从 eMMC 启动则需要将软件部署到 eMMC 存储器，使用 Freescale 提供的 iMX USB loader 和 UTP 2个工具能帮助我们完成这项工作。 软件环境 操作系统: Ubuntu14.04 开发板设置在操作之前需要将开发板设置到下载模式，iMX6Q SabreSD 的说明文档中提到: Mode Switch download mode(MFGTool mode) (SW6) 00001100 (from 1-8 bit) eMMC (MMC3) boot (SW6) 11100110 (from 1-8 bit) MMC4 (SD2) boot (SW6) 10000010 (from 1-8 bit) MMC2 (SD3) boot (SW6) 01000010 (from 1-8 bit) Freescale – Android User Guide 所以我们将开发板的启动拨码开关拨到如下位置: 将开发板的 USB 接到电脑端，使用 lsusb 命令可看到如下信息: 查看 USB 设备信息1234lsusb# ......# Bus 001 Device 003: ID 15a2:0054 Freescale Semiconductor, Inc. i.MX 6Dual/6Quad SystemOnChip in RecoveryMode# ...... 可看到电脑端成功识别了开发板，记录下 ID 信息: ID: 15a2:0054 在开始后面步骤之前请将开发板串口与电脑端连接，方便通过串口查看调试信息。 iMX USB loader 安装配置 安装 libusb。 install libusb1sudo apt-get install libusb-1.0-0-dev 获取 iMX USB loader 源代码。 git clone1git clone https://github.com/boundarydevices/imx_usb_loader.git 编译 compile12cd imx_usb_loadermake 修改配置文件 查看文件 imx_usb.conf 根据刚刚记录下来的 ID 值找到取对应的开发板配置文件: imx_usb.conf123......0x15a2:0x0054, mx6_usb_work.conf...... 将文件 mx6_usb_work.conf 的内容修改为如下: mx6_usb_work.conf12345678mx6_qsbhid,1024,0x910000,0x10000000,1G,0x00900000,0x40000firmware&#x2F;u-boot.imx: dcdfirmware&#x2F;zImage: load 0x12000000firmware&#x2F;fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot: load 0x12C00000firmware&#x2F;zImage-imx6q-sabresd.dtb: load 0x18000000firmware&#x2F;u-boot.imx: clear_dcd,load,plug,jump header 使用 USB loader 创建 firmware 目录: 创建目录1mkdir firmware 将生成的镜像文件拷贝到 firmware 目录中后执行: 运行 imx_usb1./imx_usb 等待半分钟左右，可通过串口看到输出的启动信息: 串口输出信息123456......Starting UTPuuc 0.5 [built Jan 9 2020 12:41:11]UTP: Waiting for device to appearUTP: file/device node /dev/utp already exists...... 此时开发板通过 USB 将自己模拟成一个 sg 设备，在电脑端可以通过以下命令查看此设备: 查看 sg 设备12ls /dev/sg*# /dev/sg0 /dev/sg1 其中 /dev/sg1 就是开发板。通过此设备我们便可用 UTP 工具与开发板通信。 UTP 安装配置 安装 libsgutils2。 install libsgutils21sudo apt-get install libsgutils2-dev 获取 UTP 源代码。 git clone1git clone https://github.com/ixonos/utp_com.git 编译 compile12cd utp_commake 使用 utp_com 与开发板通信 使用 utp_com1./utp_com -d /dev/sg1 -c &quot;$ echo hello, world!&quot; 通过串口可看到开发板的输出信息: 串口输出12345UTP: received command &#x27;$ echo hello, world!&#x27;UTP: executing &quot;echo hello, world!&quot;hello, world!UTP: sending Success to kernel for command $ echo hello, world!.utp_poll: pass returned. 总结至此我们完成了 imx_usb 和 utp_com 的安装配置，使用 imx_usb 向开发板下载固件，以及使用 utp_com 与开发板通信向其发送并执行指令。具体工作如下: 开发板下载模式配置 iMX USB loader 安装配置 UTP com 安装配置","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://clarenceyk.github.io/tags/mfgtool/"},{"name":"imx_usb","slug":"imx-usb","permalink":"https://clarenceyk.github.io/tags/imx-usb/"},{"name":"utp_com","slug":"utp-com","permalink":"https://clarenceyk.github.io/tags/utp-com/"}]},{"title":"搭建 iMX6Q SabreSD Yocto 项目开发环境","slug":"搭建-iMX6Q-SabreSD-Yocto-项目开发环境","date":"2020-02-17T03:03:41.000Z","updated":"2020-02-18T05:50:17.000Z","comments":true,"path":"2020/02/17/搭建-iMX6Q-SabreSD-Yocto-项目开发环境/","link":"","permalink":"https://clarenceyk.github.io/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"本文将介绍 iMX6Q SabreSD 开发板的 Yocto Project 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。","text":"本文将介绍 iMX6Q SabreSD 开发板的 Yocto Project 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。 软件环境 操作系统: Ubuntu14.04 安装依赖包Yocto Project 的依赖包12sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\build-essential chrpath socat 其他依赖包123sudo apt-get install libsdl1.2-dev xterm sed cvs subversion coreutils texi2html \\docbook-utils python-pysqlite2 help2man make gcc g++ desktop-file-utils \\libgl1-mesa-dev libglu1-mesa-dev mercurial autoconf automake groff curl lzop asciidoc u-boot 工具1sudo apt-get install u-boot-tools 安装 repo 工具repo 是一个基于 git 的工具。使用 repo 可以方便地管理存在多个软件源的项目。安装 repo 分为以下几个步骤: 在 home 目录下创建一个 bin 目录。 安装 repo123mkdir ~/bincurl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 将下面2行加入 .bashrc 文件末尾，确保 ~/bin 在 PATH 变量中。 环境变量12export PATH=$&#123;PATH&#125;:~/binexport MACHINE=imx6qsabresd 构建 Yocto 项目Freescale Yocto Project BSP Release 目录包含如下内容: sources 目录包含一些用于构建的配方 一个或多个 build 目录 一些用于配置开发环境的脚本 以下步骤创建了一个 fsl-release-bsp 目录用于构建 Yocto 项目: 创建目录12mkdir fsl-release-bspcd fsl-release-bsp 配置 git 信息12345# git config --global user.name &quot;Your Name&quot;git config --global user.name &quot;ClarenceYk&quot;# git config --global user.email &quot;Your Email&quot;git config --global user.email &quot;xxx@xxx.com&quot;git config --list 同步源代码12repo init -u git://git.freescale.com/imx/fsl-arm-yocto-bsp.git -b imx-4.1.15-1.0.0_garepo sync 上面采用了 imx-4.1.15-1.0.0_ga 分支，可根据实际需求使用其他分支代码，如下: 编译构建 MFGTool向开发板烧录系统镜像可使用 MFGTool 完成。编译 MFGTool 镜像文件的配方分别是 linux-imx-mfgtool 和 u-boot-mfgtool。编译命令如下: 编译 MFGTool123cd ~/fsl-release-bspsource fsl-setup-release.sh -b build-mfgtools -e x11bitbake fsl-image-mfgtool-initramfs 编译过程需下载大量的源代码，为确保过程顺利建议使用 VPN 或者采用其他加速网络访问的方式。 成功编译之后，在目录 ~/fsl-mfgtools-bsp/build-mfgtools/tmp/deploy/images/imx6qsabresd 下会产生如下文件: u-boot.imx（u-boot） zImage（内核） zImage-imx6q-sabresd.dtb（设备树） fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot（内存文件系统） 总结通过以上步骤，我们完成了 Freescale iMX6Q Yocto Project 开发环境搭建，其中包含如下方面的工作: 安装项目依赖软件 安装 repo 配置 git 构建 Yocto 项目 编译 MFGTool 镜像","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://clarenceyk.github.io/tags/mfgtool/"},{"name":"yocto","slug":"yocto","permalink":"https://clarenceyk.github.io/tags/yocto/"}]},{"title":"VirtualBox 安装及配置 Ubuntu14.04 服务器版","slug":"VirtualBox-安装及配置-Ubuntu14-04-服务器版","date":"2020-02-15T08:02:18.000Z","updated":"2020-02-19T02:19:30.000Z","comments":true,"path":"2020/02/15/VirtualBox-安装及配置-Ubuntu14-04-服务器版/","link":"","permalink":"https://clarenceyk.github.io/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/","excerpt":"本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。","text":"本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。 运行环境 操作系统: Windows 10 VirtualBox: 6.0 下载及安装 VirtualBox本文创建时使用的 VirtualBox 版本为 6.0，你可根据自己的需要选择其他或者最新版本。 访问 Oracle VirtualBox 主页。 点击下载按钮，下载安装程序后双击此程序安装 VirtualBox。 此处可一路点击下一步直至安装完成，然后重启计算机。 下载 Ubuntu14.04 服务器版镜像文件 访问 Ubuntu 镜像发布页，点击如下图链接。 在如下页面中找到并下载服务器版本镜像。 创建虚拟机接下来开始创建虚拟机。 点击新建，选项配置如下： 名称: 自定义，如 ubuntu1404-mfgtools 表示此虚拟机操作系统为 ubuntu14.04 用于制作 mfgtools 文件夹: 自定义，此虚拟机相关文件存放位置 类型: Linux 版本: Ubuntu (64-bit) 内存大小: 不影响主机性能的情况下取最大 其他选项如上图，配置完成后点击创建。 创建虚拟磁盘: 文件大小: 根据需求配置 固定或动态大小: 同上 配置完成点击创建。 设置启动镜像 点击设置，选择存储： 依次点击如下所示选项： 然后在弹出的选项中点击选择一个虚拟光盘文件，然后在弹出的选项框中选择之前下载的系统镜像文件。 选择系统，将启动顺序改为如下图般: 配置完成后点击确认。 安装系统 主界面点击启动，进入系统安装界面。 根据提示操作，完成安装后如下图： 选择 Continue 结束安装。关闭窗口。 回到主界面点击设置，选择系统并将启动顺序改为如下图般: 点击 ok 保存设置。 额外的配置完成前面的步骤后一个可用的虚拟机已经创建完成，后面的步骤可以让虚拟机使用起来更方便。 设置端口转发 回到主界面点击设置，选择网络并点击高级选项卡: 点击端口转发之后，添加如下配置: 其中子系统IP填为虚拟机的 IP 地址。 这一步的作用是将虚拟机的 22 端口转发到主机的 2200 端口上，方面我们使用 SSH 连接虚拟机。 安装增强功能 登录虚拟机12# ssh -p &lt;端口&gt; &lt;用户&gt;@&lt;主机地址&gt;ssh -p 2200 test@192.168.1.101 安装依赖软件123sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential 点击如下图所示的安装增强功能: 挂载光盘123sudo mkdir /mnt/cdromsudo mount /dev/cdrom /mnt/cdrom/# mount: block device /dev/sr0 is write-protected, mounting read-only 运行安装程序123cd /mnt/cdrom/sudo ./VBoxLinuxAdditions.runsudo shutdown -h 0 -r 共享文件夹 加入 vboxsf 组12# sudo usermod -a -G vboxsf &lt;用户&gt;sudo usermod -a -G vboxsf test 回到设置，选择共享文件夹并点击如下所示按钮: 如下般设置: 挂载点不用填。 重启虚拟机1sudo shutdown -h 0 -r USB 设备支持 访问 VirtualBox 官网下载拓展包。注意，请找到对应自己版本的拓展包。 回到 VirtualBox 主界面，选择管理-&gt;全局设定-&gt;拓展: 选择刚刚下载的拓展包，安装。 总结以上我们就在虚拟机中安装好了 Ubuntu 操作系统，并做了以下设置: 将虚拟机的22端口转发到主机2200端口。 创建一个共享文件夹用于虚拟机与主机间的文件共享。 安装了拓展包使虚拟机支持 USB2.0 以及 USB3.0 设备。","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"开发环境","slug":"开发环境","permalink":"https://clarenceyk.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}],"categories":[],"tags":[{"name":"操作方法","slug":"操作方法","permalink":"https://clarenceyk.github.io/tags/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"QEMU","slug":"QEMU","permalink":"https://clarenceyk.github.io/tags/QEMU/"},{"name":"ARM64","slug":"ARM64","permalink":"https://clarenceyk.github.io/tags/ARM64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://clarenceyk.github.io/tags/Ubuntu/"},{"name":"LXD","slug":"LXD","permalink":"https://clarenceyk.github.io/tags/LXD/"},{"name":"VoIP","slug":"VoIP","permalink":"https://clarenceyk.github.io/tags/VoIP/"},{"name":"Asterisk","slug":"Asterisk","permalink":"https://clarenceyk.github.io/tags/Asterisk/"},{"name":"FreePBX","slug":"FreePBX","permalink":"https://clarenceyk.github.io/tags/FreePBX/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://clarenceyk.github.io/tags/systemd-nspawn/"},{"name":"Linux","slug":"Linux","permalink":"https://clarenceyk.github.io/tags/Linux/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://clarenceyk.github.io/tags/Operating-System/"},{"name":"Context Switch","slug":"Context-Switch","permalink":"https://clarenceyk.github.io/tags/Context-Switch/"},{"name":"rsync","slug":"rsync","permalink":"https://clarenceyk.github.io/tags/rsync/"},{"name":"clone file system","slug":"clone-file-system","permalink":"https://clarenceyk.github.io/tags/clone-file-system/"},{"name":"Architecture","slug":"Architecture","permalink":"https://clarenceyk.github.io/tags/Architecture/"},{"name":"Software Design","slug":"Software-Design","permalink":"https://clarenceyk.github.io/tags/Software-Design/"},{"name":"GPIO","slug":"GPIO","permalink":"https://clarenceyk.github.io/tags/GPIO/"},{"name":"memory map","slug":"memory-map","permalink":"https://clarenceyk.github.io/tags/memory-map/"},{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://clarenceyk.github.io/tags/iMX6Q/"},{"name":"内存拓展","slug":"内存拓展","permalink":"https://clarenceyk.github.io/tags/%E5%86%85%E5%AD%98%E6%8B%93%E5%B1%95/"},{"name":"Watchdog","slug":"Watchdog","permalink":"https://clarenceyk.github.io/tags/Watchdog/"},{"name":"Embedded System","slug":"Embedded-System","permalink":"https://clarenceyk.github.io/tags/Embedded-System/"},{"name":"U-Boot","slug":"U-Boot","permalink":"https://clarenceyk.github.io/tags/U-Boot/"},{"name":"Linux kernel","slug":"Linux-kernel","permalink":"https://clarenceyk.github.io/tags/Linux-kernel/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://clarenceyk.github.io/tags/mfgtool/"},{"name":"imx_usb","slug":"imx-usb","permalink":"https://clarenceyk.github.io/tags/imx-usb/"},{"name":"utp_com","slug":"utp-com","permalink":"https://clarenceyk.github.io/tags/utp-com/"},{"name":"yocto","slug":"yocto","permalink":"https://clarenceyk.github.io/tags/yocto/"},{"name":"开发环境","slug":"开发环境","permalink":"https://clarenceyk.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}