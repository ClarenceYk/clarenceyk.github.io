{"meta":{"title":"Old Stone","subtitle":"","description":"","author":"uklar","url":"https://blog.mahyang.uk","root":"/"},"pages":[{"title":"关于","date":"2023-04-11T01:51:43.000Z","updated":"2025-01-23T15:15:13.821Z","comments":true,"path":"about/index.html","permalink":"https://blog.mahyang.uk/about/index.html","excerpt":"","text":"关于我的博客这里是我的个人博客，我会在这里分享我的一些想法和经验。 关于我 一个软件开发者 喜欢学习（最近在学习 C++） 喜欢看书（最近在看 他者的消失） 喜欢看剧（最近在看 The White Lotus 2） 喜欢摄影（只是看摄影大师的作品:-) ） 养了 2 只猫，富贵和花开 联系我如果您对我的博客感兴趣，可以通过以下方式联系我： 邮箱：&#117;&#x6b;&#108;&#97;&#114;&#109;&#x61;&#104;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;"},{"title":"标签","date":"2023-05-30T04:08:00.000Z","updated":"2025-01-23T15:15:13.821Z","comments":true,"path":"tags/index.html","permalink":"https://blog.mahyang.uk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何在 WSL 中访问 U 盘","slug":"如何在-WSL-中访问-U-盘","date":"2023-09-17T02:14:11.000Z","updated":"2023-09-17T02:14:11.000Z","comments":true,"path":"2023/09/17/如何在-WSL-中访问-U-盘/","link":"","permalink":"https://blog.mahyang.uk/2023/09/17/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E8%AE%BF%E9%97%AE-U-%E7%9B%98/","excerpt":"在 WSL 中可以通过 /mnt/ 目录很方便地访问 Windows 主机的文件系统，但是如果我们 PC 上接 U 盘，这个 U 盘只能在 Windows 系统里访问而不能在 WSL 里访问。如果想要在 WSL 中使用 dd 命令读写 U 盘或者挂载 U 盘到 WSL 系统，则需要让 USB 设备连接到 WSL，但是默认情况下 WSL 不支持这种操作所以我们需要对 WSL 进行一些修改。","text":"在 WSL 中可以通过 /mnt/ 目录很方便地访问 Windows 主机的文件系统，但是如果我们 PC 上接 U 盘，这个 U 盘只能在 Windows 系统里访问而不能在 WSL 里访问。如果想要在 WSL 中使用 dd 命令读写 U 盘或者挂载 U 盘到 WSL 系统，则需要让 USB 设备连接到 WSL，但是默认情况下 WSL 不支持这种操作所以我们需要对 WSL 进行一些修改。 自己编译内核首先需要做的是编译自己的 WSL 内核并且让 WSL 使用我们自己编译的内核，具体的操作步骤可参考这篇：如何在 WSL 中编译加载内核模块。 在编译之前需要通过 make menuconfig 配置内核，将 USB 存储相关的驱动打开： 123Device Drivers ---&gt; USB support ---&gt; USB Mass Storage support 安装 usbipusbip 是一个服务程序，它可以将 USB 协议通过网络转发，从而实现将一个设备的 USB 设备通过网络转发到另外一台设备。同样我们可以利用这个程序将 USB 设备从 Windows 主机通过本地网络转发到 WSL 系统。 Windows 上的操作我们需要安装 usbipd 这个服务，可以通过下载安装包的方式，也可以通过 winget 安装，我使用后一种： 1winget install usbipd WSL 中的操作直接通过 Ubuntu 的软件仓库安装并启用 usbip： 12sudo apt install linux-tools-generic hwdatasudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 usbip 的使用Windows 上的操作首先将 U 盘插入到 PC 上，然后使用管理员权限打开 Windows PowerShell，输入以下命令： 列出所有可用的 USB 设备： 1usbipd wsl list 会得到类似如下输出： 12345BUSID VID:PID DEVICE STATE1-3 04f2:b569 Integrated Camera Not attached1-4 138a:0011 Synaptics FP Sensors (WBF) (PID=0011) Not attached1-7 8087:0a2a 英特尔(R) 无线 Bluetooth(R) Not attached3-2 05e3:0736 USB 大容量存储设备 Not attached 可以看到 BUSID 3-2 就是我们的 U 盘，然后就可以把它加入到 WSL 中了： 1usbipd wsl attach --busid 3-2 WSL 中的操作使用 lsusb 查看 USB 设备是否已经连接到了 WSL 中： 1lsusb 可以看到输出： 123Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 002: ID 05e3:0736 Genesys Logic, Inc. Colour arc SD Card Reader [PISEN]Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 这个 Bus 001 就是我们的 U 盘，说明已经成功连上 USB 设备了。 然后通过 lsblk 查看是否有新的存储设备出现： 1lsblk 可以看到输出： 12sdd 8:48 1 7.2G 0 disk└─sdd1 8:49 1 7.2G 0 part 说明 USB 存储设备也成功识别了。接下来我们就可以通过 dd 命令进行镜像烧写，或者在 U 盘中已经有文件系统的情况下，挂载 U 盘到 WSL 从而进行文件访问。 在 WSL 中使用完 U 盘之后，我们需要回到 Windows 系统将 U 盘取消连接，同样在 powershell 中输入如下命令： 1usbipd wsl detach --busid 3-2 就可以取消连接 WSL。","categories":[],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://blog.mahyang.uk/tags/WSL/"}]},{"title":"如何在 WSL 中编译加载内核模块","slug":"如何在-WSL-中编译加载内核模块","date":"2023-09-16T12:20:28.000Z","updated":"2023-09-17T01:20:28.000Z","comments":true,"path":"2023/09/16/如何在-WSL-中编译加载内核模块/","link":"","permalink":"https://blog.mahyang.uk/2023/09/16/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"Windows 系统中集成的 WSL 子系统非常好用，特别是到了 WSL2 这个版本，配合 Ubuntu 发行版可以应付绝大多数工作需求。但是这个系统中使用的内核是微软提供的，不允许加载内核模块，导致自己编译的模块无法使用。如果想要加载内核模块则需要自己编译内核供 WSL 使用。","text":"Windows 系统中集成的 WSL 子系统非常好用，特别是到了 WSL2 这个版本，配合 Ubuntu 发行版可以应付绝大多数工作需求。但是这个系统中使用的内核是微软提供的，不允许加载内核模块，导致自己编译的模块无法使用。如果想要加载内核模块则需要自己编译内核供 WSL 使用。 编译 WSL 内核我们可以从微软的开源仓库中拉取最新的内核源码，然后自己编译内核。 拉取源码： 1git clone https://github.com/microsoft/WSL2-Linux-Kernel.git 配置内核： 这里直接使用微软的默认配置： 1mv Microsoft/config-wsl ./.config 编译： 1make -j8 WSL 启动新编译内核将新编译好的内核拷贝到任意位置： 1cp arch/x86_64/boot/bzImage /mnt/c/Users/uklar/ 在启动 WSL 的用户的根目录中创建 WSL 配置文件： 1touch /mnt/c/Users/uklar/.wslconfig 同时将如下内容写入配置文件： 12[wsl2]kernel=C:\\\\Users\\\\uklar\\\\bzImage 这里的配置就是指定 WSL 启动使用的内核。 关闭 WSL 再启动，以生效更改： 1wsl --shutdown 测试hello.c 程序： 12345678910111213141516171819#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/printk.h&gt;static int __init hello_init(void)&#123; pr_info(&quot;Hello, world\\n&quot;); return 0;&#125;static void __exit hello_exit(void)&#123; pr_info(&quot;Goodbye, world\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); Makefile： 123456789obj-m += hello.oPWD := $(CURDIR)all: make -C /home/uklar/WSL2-Linux-Kernel M=$(PWD) modulesclean: make -C /home/uklar/WSL2-Linux-Kernel M=$(PWD) clean 注意：这里要使用自己下载的内核源码的路径。 编译： 1make 此时我们会得到 hello.ko 使用 sudo insmod hello.ko 测试是否可以加载模块，在 dmesg 命令的输出中我们可以看到： 1[11114.649475] Hello, world 说明此时内核模块已经成功加载了。","categories":[],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://blog.mahyang.uk/tags/WSL/"},{"name":"Kernel Module","slug":"Kernel-Module","permalink":"https://blog.mahyang.uk/tags/Kernel-Module/"}]},{"title":"复盘一道面试算法题","slug":"复盘一道面试算法题","date":"2023-06-08T14:02:40.000Z","updated":"2023-06-08T14:02:40.000Z","comments":true,"path":"2023/06/08/复盘一道面试算法题/","link":"","permalink":"https://blog.mahyang.uk/2023/06/08/%E5%A4%8D%E7%9B%98%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"最近面试一个开发岗位，遇到一道算法题，现场我只给出了思路，没能在规定时间里写出代码也就没法现场验证，在这里复盘一下。","text":"最近面试一个开发岗位，遇到一道算法题，现场我只给出了思路，没能在规定时间里写出代码也就没法现场验证，在这里复盘一下。 题目只能回忆起部分内容，大致是，从一个给定的字符串中找出最长的重复的子串。 分析假定输入字符串是 asdfddfbiibhddf234，长度为 18 个字符。 子串：长度至少要为 1 个字符，最大 17 个字符。 重复子串：当确定以一个子串，如以 asd 为目标寻找重复子串，那么寻找的范围必须是输入字符串中 a 字符之后的部分。 需要遍历所有情况。 基于以上 3 条规则，我们可以得出如下思路： 利用双重循环遍历所有可能出现的子串。 使用 strstr 从输入字符串的子串首字母之后的部分中寻找是否有重复子串。 更新最长子串记录。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int substring(char *input, char **output)&#123; int i, j, n; int in_len = strlen(input); int max = 0; char *tmp; tmp = malloc(in_len); // 双重循环负责遍历所有子串 // j 从 i+1 开始保证子串最短为 1 个字符 // j &lt; in_len 保证子串最大为 in_len-1 个字符 for (i = 0; i &lt; in_len; i++) &#123; for (j = i + 1; j &lt; in_len; j++) &#123; // 子串长度 n = j - i; // 取子串 strncpy(tmp, input + i, n); tmp[n] = &#x27;\\0&#x27;; // 从子串首字符之后的剩余部分找重复子串 if (strstr(input + i + 1, tmp)) &#123; if (n &gt; max) &#123; *output = input + i; max = n; &#125; &#125; &#125; &#125; free(tmp); return max;&#125;int main(int argc, char *argv[])&#123; char *out; int len; int i; printf(&quot; input: \\&quot;%s\\&quot;\\n&quot;, argv[1]); len = substring(argv[1], &amp;out); printf(&quot;output: \\&quot;&quot;); for (i = 0; i &lt; len; i++) printf(&quot;%c&quot;, out[i]); printf(&quot;\\&quot;\\n&quot;); return 0;&#125; 测试结果测试字符串：asdfddfbiibhddf234结果输出： 12 input: &quot;asdfddfbiibhddf234&quot;output: &quot;ddf&quot; 测试字符串：aaa结果输出： 12 input: &quot;aaa&quot;output: &quot;aa&quot; 测试字符串：bbbb结果输出： 12 input: &quot;bbbb&quot;output: &quot;bbb&quot; 测试字符串：c结果输出： 12 input: &quot;c&quot;output: &quot;&quot;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://blog.mahyang.uk/tags/%E9%9D%A2%E8%AF%95/"},{"name":"C","slug":"C","permalink":"https://blog.mahyang.uk/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://blog.mahyang.uk/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ROSR 学习笔记 - 第3.1章","slug":"ROSR-学习笔记-第3-1章","date":"2022-11-21T05:42:39.000Z","updated":"2022-11-21T05:42:39.000Z","comments":true,"path":"2022/11/21/ROSR-学习笔记-第3-1章/","link":"","permalink":"https://blog.mahyang.uk/2022/11/21/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3-1%E7%AB%A0/","excerpt":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述系统堆内存管理。 前面章节已经描述过我们通过 QEMU 给整个系统提供了 128M 字节内存空间，ELF 文件加载到内存中后除开代码、全局变量、栈等占用的内存之外，其余部分我们都分配了堆。所以堆的部分就由操作系统来管理分配。 管理系统堆空间时，分为 3 个部分： 页分配 字节分配 编程内存管理单元 本 3.1 节主要描述页分配。","text":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述系统堆内存管理。 前面章节已经描述过我们通过 QEMU 给整个系统提供了 128M 字节内存空间，ELF 文件加载到内存中后除开代码、全局变量、栈等占用的内存之外，其余部分我们都分配了堆。所以堆的部分就由操作系统来管理分配。 管理系统堆空间时，分为 3 个部分： 页分配 字节分配 编程内存管理单元 本 3.1 节主要描述页分配。 按页分配表示以页为粒度来分配内存空间，RISC-V 和大多数架构一样最小页空间占用 4096 字节。按页分配的方法有很多，这里采用描述符分配方式。 在进入正题之前，我们先来看几个重要的参数： 12PROVIDE(_heap_start = _stack_end);PROVIDE(_heap_size = _memory_end - _heap_start); linker script 提供了 2 个重要符号：堆起始地址（_heap_start）和堆大小（_heap_size），这些符号又通过 mem.S 文件作为全局常量传入 rust： 12345.global HEAP_STARTHEAP_START: .dword _heap_start.global HEAP_SIZEHEAP_SIZE: .dword _heap_size 在 page.rs 的 init 函数中： 123456789let num_pages = HEAP_SIZE / PAGE_SIZE;// ...ALLOC_START = align_val( HEAP_START + num_pages * size_of::&lt;Page,&gt;(), PAGE_ORDER,); 第一行算出堆内存总共的页数，最后一行算出用于分配的堆内存起始地址。 描述符分配法每次分配都按照连续页分配，并且只存储首页地址。为了达到此目标必须每页内存都有一个字节大小的描述符。此描述符包含 2 种标志：1）此页是否被分配；2）是否为连续分配内存的最后一页。 由此定义如下数据结构： 12345678910#[repr(u8)]pub enum PageBits &#123; Empty = 0, Taken = 1 &lt;&lt; 0, Last = 1 &lt;&lt; 1,&#125;pub struct Page &#123; flags: u8,&#125; 分配内存页123456789101112131415161718192021222324252627282930pub fn alloc(pages: usize) -&gt; *mut u8 &#123; assert!(pages &gt; 0); unsafe &#123; let num_pages = HEAP_SIZE / PAGE_SIZE; let ptr = HEAP_START as *mut Page; for i in 0..num_pages - pages &#123; let mut found = false; if (*ptr.add(i)).is_free() &#123; found = true; for j in i..i + pages &#123; if (*ptr.add(j)).is_taken() &#123; found = false; break; &#125; &#125; &#125; if found &#123; for k in i..i + pages - 1 &#123; (*ptr.add(k)).set_flag(PageBits::Taken); &#125; (*ptr.add(i+pages-1)).set_flag(PageBits::Taken); (*ptr.add(i+pages-1)).set_flag(PageBits::Last); return (ALLOC_START + PAGE_SIZE * i) as *mut u8; &#125; &#125; &#125; null_mut()&#125; 如上为内存页分配函数，函数参数为需要的页数。 第 2 行：判断页数是否有效；第 4 行：算出堆内存空间总页数；第 5 行：将堆起始地址类型转换为可变页指针；第 6～26 行：找出满足要求连续空闲页并分配；第 8～16 行：在第 i 页为空闲的前提下看其后是否有满足所需页数的连续页；第 17～25 行：如果找到了满足所需页数的连续空闲页，将除最后一页的内存页标记为占用，最后一页标记为占用以及尾，并返回页指针。 回收内存页12345678910111213141516171819pub fn dealloc(ptr: *mut u8) &#123; assert!(!ptr.is_null()); unsafe &#123; let addr = HEAP_START + (ptr as usize - ALLOC_START) / PAGE_SIZE; assert!(addr &gt;= HEAP_START &amp;&amp; addr &lt; HEAP_START + HEAP_SIZE); let mut p = addr as *mut Page; while (*p).is_taken() &amp;&amp; !(*p).is_last() &#123; (*p).clear(); p = p.add(1); &#125; assert!( (*p).is_last() == true, &quot;Possible double-free detected! (Not taken found \\ before last)&quot; ); (*p).clear(); &#125;&#125; 如上为内存页回收函数，函数参数为需要回收的页指针。 第 2 行：判断页指针是否有效；第 4～7 行：算出此页内存所对应的页描述符；第 8～17 行：依次将所有分配的内存页对应的页描述符标记清零，表示设置为未占用。","categories":[],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://blog.mahyang.uk/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://blog.mahyang.uk/tags/OS/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.mahyang.uk/tags/Rust/"}]},{"title":"ROSR 学习笔记 - 第2章","slug":"ROSR-学习笔记-第2章","date":"2022-11-11T02:38:40.000Z","updated":"2022-11-11T02:38:40.000Z","comments":true,"path":"2022/11/11/ROSR-学习笔记-第2章/","link":"","permalink":"https://blog.mahyang.uk/2022/11/11/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0/","excerpt":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述使用 Rust 的 unsafe 功能操作 MMIO 来控制 UART 进而实现 println! 等宏。","text":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述使用 Rust 的 unsafe 功能操作 MMIO 来控制 UART 进而实现 println! 等宏。 Universal Asynchronous Reciever &#x2F; Transmitter (UART)QEMU 内部虚拟了一个 NS16550A UART 芯片，查看 qemu&#x2F;hw&#x2F;riscv&#x2F;virt.c 代码可知： 1234static const MemMapEntry virt_memmap[] = &#123; // ... [VIRT_UART0] = &#123; 0x10000000, 0x100 &#125;,&#125;; 通过物理地址 0x10000000，即可访问 NS16550A 芯片的寄存器。BTW，这种通过物理地址访问的 IO 被称为 MMIO。 从下图可以看到发送（THR）接收（RBR）寄存器都是 8 bit（1 byte），我们只要从地址 0x10000000 读取就能从 UART 接收一个字节，向地址 0x10000000 写入就能发送一个字节。 Rust 中的 MMIO1234567891011121314151617181920212223242526272829303132/// # Safety////// We label the mmio function unsafe since/// we will be working with raw memory. Rust cannot/// make any guarantees when we do this.fn unsafe mmio_write(address: usize, offset: usize, value: u8) &#123; // Set the pointer based off of the address let reg = address as *mut u8; // write_volatile is a member of the *mut raw // and we can use the .add() to give us another pointer // at an offset based on the original pointer&#x27;s memory // address. NOTE: The add uses pointer arithmetic so it is // new_pointer = old_pointer + sizeof(pointer_type) * offset reg.add(offset).write_volatile(value);&#125;/// # Safety////// We label the mmio function unsafe since/// we will be working with raw memory. Rust cannot/// make any guarantees when we do this.fn unsafe mmio_read(address: usize, offset: usize, value: u8) -&gt; u8 &#123; // Set the pointer based off of the address let reg = address as *mut u8; // read_volatile() is much like write_volatile() except it // will grab 8-bits from the pointer and give that value to us. // We don&#x27;t add a semi-colon at the end here so that the value // is &quot;returned&quot;. reg.add(offset).read_volatile()&#125; Rust UART 驱动UART 驱动包括： 数据结构用于存储基地址 初始化方法 输出一个字符函数（put） 读取一个字符函数（get） 实现 Write traits 数据结构定义123pub struct UartDriver &#123; base_address: usize,&#125; 增加初始化方法12345678910111213141516171819202122232425impl UartDriver &#123; // ... pub fn init(&amp;self) &#123; let ptr = self.base_address as *mut u8; unsafe &#123; let lcr = (1 &lt;&lt; 0) | (1 &lt;&lt; 1); ptr.add(3).write_volatile(lcr); ptr.add(2).write_volatile(1 &lt;&lt; 0); ptr.add(1).write_volatile(1 &lt;&lt; 0); let divisor: u16 = 12; let divisor_least: u8 = (divisor &amp; 0xff) as u8; let divisor_most: u8 = (divisor &gt;&gt; 8) as u8; ptr.add(3).write_volatile(lcr | 1 &lt;&lt; 7); ptr.add(0).write_volatile(divisor_least); ptr.add(1).write_volatile(divisor_most); ptr.add(3).write_volatile(lcr); &#125; &#125; // ...&#125; 7~9行，设置8位数据、无停止位、无奇偶（因为是模拟的 UART，一般硬件设置为 8N1） 10、11行，开启收中断、开启 FIFO 13~18行，设置波特率 115200（因为是模拟的 UART 所以波特率设置不影响） 根据 NS16550A 芯片资料，其内部有一个全局时钟频率为 22.729 MHz（22729000 Hz），所以要设置 115200 波特率： divisor &#x3D; 22729000 &#x2F; (115200 * 16) &#x3D; 12。 并且在设置波特率之前需把 LCR 寄存器的 DLAB 位置1，设置完后再置0。 增加 put 方法12345678910impl UartDriver &#123; // ... fn put(&amp;self, c: u8) &#123; let ptr = self.base_address as *mut u8; unsafe &#123; ptr.add(0).write_volatile(c); &#125; &#125; // ...&#125; 增加 get 方法123456789101112131415impl UartDriver &#123; // ... pub fn get(&amp;self) -&gt; Option&lt;u8&gt; &#123; let ptr = self.base_address as *mut u8; unsafe &#123; if ptr.add(5).read_volatile() &amp; 1 == 0 &#123; None &#125; else &#123; Some(ptr.add(0).read_volatile()) &#125; &#125; &#125; // ...&#125; 这里我们的内核还没处理中断，所以采用 poll 的方式检测是否有数据。 实现 Write traits这一步是为了 print! 宏做准备。 123456789101112use core::fmt::&#123;Error, Write&#125;;// ...impl Write for UartDriver &#123; fn write_str(&amp;mut self, s: &amp;str) -&gt; Result&lt;(), Error&gt; &#123; for c in s.bytes() &#123; self.put(c); &#125; Ok(()) &#125;&#125; 实现 print! 宏第1章中，lib.rs 文件中的 print! 宏的实现是空，现在我们可以填入内容了： 12345678#[macro_export]macro_rules! print&#123; ($($args:tt)+) =&gt; &#123;&#123; use core::fmt::Write; let _ = write!(uart::UartDriver::new(0x1000_0000), $($args)+); &#125;&#125;;&#125; Hello, World!在 kmain 入口处初始化 UART 后就可以向终端输出信息了： 1234567#[no_mangle]extern &quot;C&quot; fn kmain() &#123; let my_uart = uart::UartDriver::new(0x1000_0000); my_uart.init(); println!(&quot;Hello, World!&quot;);&#125; 同样也能从终端获取用户输入： 1234567891011121314151617181920#[no_mangle]extern &quot;C&quot; fn kmain() &#123; // ... loop &#123; if let Some(c) = my_uart.get() &#123; match c &#123; 8 | 127 =&gt; &#123; print!(&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;, 8 as char, &#x27; &#x27;, 8 as char); &#125;, 10 | 13 =&gt; &#123; println!(); &#125;, _ =&gt; &#123; print!(&quot;&#123;&#125;&quot;, c as char); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://blog.mahyang.uk/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://blog.mahyang.uk/tags/OS/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.mahyang.uk/tags/Rust/"}]},{"title":"ROSR 学习笔记 - 第1章","slug":"ROSR-学习笔记-第1章","date":"2022-11-10T03:30:00.000Z","updated":"2022-11-10T03:30:00.000Z","comments":true,"path":"2022/11/10/ROSR-学习笔记-第1章/","link":"","permalink":"https://blog.mahyang.uk/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/","excerpt":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述使用汇编语言编写引导程序为 Rust 语言创建执行环境。","text":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述使用汇编语言编写引导程序为 Rust 语言创建执行环境。 基本思路 将源码编译出目标文件 使用 linker script 通过链接器将目标文件链接成 ELF 文件 QEMU 使用 ELF 文件启动 QEMU 根据 ELF 文件指定的内存地址将代码段、数据段等放置到内存中相应的位置 QEMU 模拟器开始执行程序 QEMU 内存映射查看 qemu&#x2F;hw&#x2F;riscv&#x2F;virt.c 文件可知： 1234static const MemMapEntry virt_memmap[] = &#123; // ... [VIRT_DRAM] = &#123; 0x80000000, 0x0 &#125;,&#125;; QEMU 从内存地址 0x80000000 开始执行程序，所以我们需要把代码链接到此地址上，这一点从第0章的 linker script 也能看出。 启动并执行 Rust 程序分为 3 个步骤： 选择用于启动的 CPU （一般选择 id 为 #0 的） 初始化 BSS 段为 0 跳转 Rust 选择启动 CPU选择一个 CPU 来执行启动流程，原因在于在这个阶段我们并不想去处理并发或者资源竞争等问题。通过 RISC-V 特权级规范手册 的 3.1.5 节可知，我们能使用 mhartid 寄存器来确定当前指令正在被哪个 CPU 执行。 123456 csrr t0, mhartid bnez t0, 3f3: wfi j 3b 这段代码让 id#0 之外的 CPU 都跳转到 wfi（等待中断） 指令处。 初始化 BSS 段确定好由哪个 CPU 执行启动流程后，就需要使用它将 BSS 段初始化清零： 1234567 la a0, _bss_start la a1, _bss_end bgeu a0, a1, 2f1: sd zero, (a0) addi a0, a0, 8 bltu a0, a1, 1b 其中标号 _bss_start 以及 _bss_end 由 linker script 确定。 跳转 Rust在跳转执行 Rust 代码前我们必须为 Rust 准备执行环境，也就是设置好栈指针（SP）以及异常程序计数器（mepc）然后利用中断返回（mret）让 CPU 跳转到主函数入口（kmain）。 但是此时的 CPU 并没有被中断，要使用中断返回就必须模拟一个中断的场景使得 mret 指令能够正确执行。 123456789la sp, _stackli t0, (0b11 &lt;&lt; 11) | (1 &lt;&lt; 7) | (1 &lt;&lt; 3)csrw mstatus, t0la t1, kmaincsrw mepc, t1la t2, asm_trap_vectorcsrw mtvec, t2li t3, (1 &lt;&lt; 3) | (1 &lt;&lt; 7) | (1 &lt;&lt; 11)csrw mie, t3 上面这段代码中的第1行就是设置 SP 寄存器，同样 _statck 符号由 linker script 提供。 第2、3行将 mstatus 寄存器的 MIE、MPIE、MPP 位分别置 b&#39;1、b&#39;1 以及 b&#39;11，使得 mret 执行后 MIE 为 b&#39;1，MPIE 为 b&#39;1，MPP 为 b&#39;00，并且 CPU 处于 M 态。 第4、5行将 Rust 程序的入口写入 mepc 寄存器，当 mret 执行后 CPU 就会跳转到此处。 第6、7行设置陷阱向量基地址，暂时不用关心。 第8、9行开启软中断、时钟中断、外部中断。 Rust Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Steve Operating System// Stephen Marz// 21 Sep 2019#![no_std]#![feature(panic_info_message)]use core::arch::asm;// ///////////////////////////////////// / RUST MACROS// ///////////////////////////////////#[macro_export]macro_rules! print &#123; ($($args:tt)+) =&gt; &#123;&#123;&#125;&#125;;&#125;#[macro_export]macro_rules! println&#123; () =&gt; (&#123; print!(&quot;\\r\\n&quot;) &#125;); ($fmt:expr) =&gt; (&#123; print!(concat!($fmt, &quot;\\r\\n&quot;)) &#125;); ($fmt:expr, $($args:tt)+) =&gt; (&#123; print!(concat!($fmt, &quot;\\r\\n&quot;), $($args)+) &#125;);&#125;// ///////////////////////////////////// / LANGUAGE STRUCTURES / FUNCTIONS// ///////////////////////////////////#[no_mangle]extern &quot;C&quot; fn eh_personality() &#123;&#125;#[panic_handler]fn panic(info: &amp;core::panic::PanicInfo) -&gt; ! &#123; print!(&quot;Aborting: &quot;); if let Some(p) = info.location() &#123; println!( &quot;line &#123;&#125;, file &#123;&#125;: &#123;&#125;&quot;, p.line(), p.file(), info.message().unwrap() ); &#125; else &#123; println!(&quot;no information available.&quot;); &#125; abort();&#125;#[no_mangle]extern &quot;C&quot; fn abort() -&gt; ! &#123; loop &#123; unsafe &#123; // The asm! syntax has changed in Rust. // For the old, you can use llvm_asm!, but the // new syntax kicks ass--when we actually get to use it. asm!(&quot;wfi&quot;); &#125; &#125;&#125;#[no_mangle]extern &quot;C&quot; fn kmain() &#123; // Main should initialize all sub-systems and get // ready to start scheduling. The last thing this // should do is start the timer.&#125; 这里的代码和作者原先的代码有如下差异： 12345&lt; #![feature(panic_info_message,asm)]---&gt; #![feature(panic_info_message)]&gt;&gt; use core::arch::asm; 大概因为目前的 Rust 编译器以及提供了对 asm 稳定支持。","categories":[],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://blog.mahyang.uk/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://blog.mahyang.uk/tags/OS/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.mahyang.uk/tags/Rust/"}]},{"title":"ROSR 学习笔记 - 第0章","slug":"ROSR-学习笔记-第0章","date":"2022-11-10T02:04:39.000Z","updated":"2022-11-10T02:04:39.000Z","comments":true,"path":"2022/11/10/ROSR-学习笔记-第0章/","link":"","permalink":"https://blog.mahyang.uk/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC0%E7%AB%A0/","excerpt":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述实验环境的搭建。","text":"ROSR 是『RISC-V OS using Rust』的缩写，是由 Stephen Marz 在他的系列博客中提供的操作系统开发教程。 本章描述实验环境的搭建。 开发环境搭建现在 Rust 编译器已经增加了对 RISC-V 的支持，所以搭建开发环境变得容易了很多： 安装 rustup 配置 Rust 编译环境 安装 RISC-V 交叉编译工具链 安装 QEMU 的 RISC-V 模拟环境 在 Ubuntu 20.04 上搭建开发环境的具体步骤如下： 安装 rustup参考 Rust 官方文档。 配置 Rust 编译环境命令行执行： 123rustup default nightlyrustup target add riscv64gc-unknown-none-elfcargo install cargo-binutils 使用 nightly 构建是因为需要使用一些 Rust 的稳定版本中没有的语言特性 #![features]。 安装 RISC-V 交叉编译工具链使用 ubuntu 软件仓提供的工具链： 12sudo apt updatesudo apt install gcc-riscv64-unknown-elf 安装 QEMU 的 RISC-V 模拟环境1sudo apt install qemu-system-riscv64 创建工程1cargo new myos --lib 在 Cargo.toml 项目配置文件中增加： 12[lib]crate-type = [&quot;staticlib&quot;] 创建 .cargo/config 文件： 123456[build]target = &quot;riscv64gc-unknown-none-elf&quot;rustflags = [&#x27;-Clink-arg=-Tsrc/lds/virt.lds&#x27;][target.riscv64gc-unknown-none-elf]runner = &quot;qemu-system-riscv64 -machine virt -cpu rv64 -smp 4 -m 128M -drive if=none,format=raw,file=hdd.dsk,id=foo -device virtio-blk-device,scsi=off,drive=foo -nographic -serial mon:stdio -bios none -device virtio-rng-device -device virtio-gpu-device -device virtio-net-device -device virtio-tablet-device -device virtio-keyboard-device -kernel &quot; 在 src/lds/ 目录中创建 linker script virt.lds： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849OUTPUT_ARCH( &quot;riscv&quot; )ENTRY( _start )MEMORY&#123; ram (wxa!ri) : ORIGIN = 0x80000000, LENGTH = 128M&#125;PHDRS&#123; text PT_LOAD; data PT_LOAD; bss PT_LOAD;&#125;SECTIONS&#123; .text : &#123; PROVIDE(_text_start = .); *(.text.init) *(.text .text.*) PROVIDE(_text_end = .); &#125; &gt;ram AT&gt;ram :text PROVIDE(_global_pointer = .); .rodata : &#123; PROVIDE(_rodata_start = .); *(.rodata .rodata.*) PROVIDE(_rodata_end = .); &#125; &gt;ram AT&gt;ram :text .data : &#123; . = ALIGN(4096); PROVIDE(_data_start = .); *(.sdata .sdata.*) *(.data .data.*) PROVIDE(_data_end = .); &#125; &gt;ram AT&gt;ram :data .bss :&#123; PROVIDE(_bss_start = .); *(.sbss .sbss.*) *(.bss .bss.*) PROVIDE(_bss_end = .); &#125; &gt;ram AT&gt;ram :bss PROVIDE(_memory_start = ORIGIN(ram)); PROVIDE(_stack = _bss_end + 0x80000); PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram)); PROVIDE(_heap_start = _stack); PROVIDE(_heap_size = _memory_end - _stack);&#125; 创建 makefile： 1234567891011121314151617181920212223242526272829303132333435363738####### BUILD#####CC=riscv64-unknown-elf-g++CFLAGS=-Wall -Wextra -pedantic -Wextra -O0 -g -std=c++17CFLAGS+=-static -ffreestanding -nostdlib -fno-rtti -fno-exceptionsCFLAGS+=-march=rv64gc -mabi=lp64dINCLUDES=LINKER_SCRIPT=-Tsrc/lds/virt.ldsTYPE=debugRUST_TARGET=./target/riscv64gc-unknown-none-elf/$(TYPE)LIBS=-L$(RUST_TARGET)SOURCES_ASM=$(wildcard src/asm/*.S)LIB=-lsos -lgccOUT=os.elf####### QEMU#####QEMU=qemu-system-riscv64MACH=virtCPU=rv64CPUS=4MEM=128MDRIVE=hdd.dskall: cargo build $(CC) $(CFLAGS) $(LINKER_SCRIPT) $(INCLUDES) -o $(OUT) $(SOURCES_ASM) $(LIBS) $(LIB) run: all $(QEMU) -machine $(MACH) -cpu $(CPU) -smp $(CPUS) -m $(MEM) -nographic -serial mon:stdio -bios none -kernel $(OUT) -drive if=none,format=raw,file=$(DRIVE),id=foo -device virtio-blk-device,scsi=off,drive=foo.PHONY: cleanclean: cargo clean rm -f $(OUT) 创建硬盘镜像： 1dd if=/dev/zero of=hdd.dsk count=32 bs=1M","categories":[],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://blog.mahyang.uk/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://blog.mahyang.uk/tags/OS/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.mahyang.uk/tags/Rust/"}]},{"title":"Asterisk 交叉编译","slug":"asterisk-cross-compilation","date":"2021-11-02T02:06:11.000Z","updated":"2021-11-10T06:37:16.000Z","comments":true,"path":"2021/11/02/asterisk-cross-compilation/","link":"","permalink":"https://blog.mahyang.uk/2021/11/02/asterisk-cross-compilation/","excerpt":"本文将介绍如何交叉编译 Asterisk。","text":"本文将介绍如何交叉编译 Asterisk。 环境介绍开发环境： 操作系统: Ubuntu 20.04 LTS CPU 架构: x86_64 目标环境： 操作系统: Linux 平台(内核版本 2.6.32) CPU 架构: mipsel Asterisk 依赖要求Asterisk 与各模块间的依赖如下图： 开发环境准备安装必备的构建工具： 1234567891011sudo apt install -y \\ build-essential \\ autoconf \\ automake \\ bison \\ flex \\ git \\ libtool \\ libtool-bin \\ make \\ pkg-config 准备交叉编译工具链： 这一步需要注意的是，在安装交叉编译工具链时，需要指定一个目标架构，这里我们使用 mipsel，这个架构是 mipsel-linux-gnu-gcc 的目标架构。 对于 mipsel 架构所对应的交叉编译工具软件包可从上游厂商处获取。其他架构如 arm、arm64 可从 ARM 官方下载，或直接通过软件包管理工具获取（debian 仓库），或者下载第三方提供的二进制文件（如 Linaro 提供）。 工作目录准备： 12345MIPSEL_Cross-Compile├── build_opt├── build_source├── build_start└── toolchain 建立目录 MIPSEL_Cross-Compile 与子目录 build_opt、build_source、build_start、toolchain，并将 MIPSEL_Cross-Compile/toolchain 目录中的交叉编译工具链添加到环境变量中，以便后续的编译操作可以使用。 12export PATH=&quot;$PATH:/home/ubuntu/MIPSEL_Cross-Compile/toolchain/gcc-4.4-gnu/bin&quot;export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/home/ubuntu/MIPSEL_Cross-Compile/toolchain/gcc-4.4-gnu/mipsel-linux/lib&quot; build_opt: 存放编译后产生的可执行文件、库文件等 build_source: 存放源代码压缩包 build_start: 存放源代码 toolchain: 存放交叉编译工具链 准备源代码： 各个所需模块的源代码通过下载获取（搜索一下便可得到下载地址），并将源代码压缩包拷贝到 build_source 目录中。 12345678910asterisk-18-current.tar.gzasterisk-g72x.zipbcg729-1.1.1.tar.gzlibedit-20210910-3.1.tar.gzlibuuid-1.0.3.tar.gzlibxml2-2.9.12.tar.gzncurses-6.2.tar.gzopenssl-1.1.1l.tar.gzsqlite-autoconf-3360000.tar.gzzlib-1.2.11.tar.gz 将这些压缩包都解压到 build_start 目录中。 交叉编译编译顺序为： 12345678910ncurseslibeditsqlite3libuuidzliblibxml2opensslasteriskbcg729asterisk-g72x ncurses12345678910cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/ncurses-6.2CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--disable-stripping \\--with-shared --without-ada --enable-termcap \\--with-build-cc=gcc --with-build-cpp=gcc \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipselmake &amp;&amp; make install Tips: 参数 --with-build-cc 以及 --with-build-cpp 指定的是开发环境本地编译使用的 gcc 工具链，而非交叉编译工具链。 libedit123456789cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libedit-20210910-3.1CC=mipsel-linux-gcc \\CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include/ncurses&quot; \\LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/lib&quot; \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipselmake &amp;&amp; make install Tips: libedit 依赖于 ncurses，所以需要指定 CFLAGS、LDFLAGS 等参数，以便编译时能够正确搜索 ncurses 相关的头文件和库文件。 sqlite31234567cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/sqlite-autoconf-3360000CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipselmake &amp;&amp; make install libuuid1234567cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libuuid-1.0.3CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipselmake &amp;&amp; make install zlib123456cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/zlib-1.2.11CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \\./configure --prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipselmake &amp;&amp; make install libxml2123456789cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libxml2-2.9.12./autogen.sh CC=mipsel-linux-gcc \\CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/include&quot; \\LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/lib&quot; \\--build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipselmake &amp;&amp; make install Tips: libxml2 依赖于 zlib，所以需要指定 CFLAGS、LDFLAGS 等参数，以便编译时能够正确搜索 zlib 相关的头文件和库文件。 Notice: 与前面编译命令不同 libxml2 使用 ./autogen.sh 而不是 ./configure，autogen.sh 会生成并运行 configure 同时将传给 autogen.sh 的编译参数传给 configure。 openssl123456789101112cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/openssl-1.1.1l./Configure linux-mips32 \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \\--openssldir=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \\sharedsed -i &quot;s/\\(CROSS_COMPILE=\\).*/\\1mipsel-linux-/g&quot; Makefilesed -i &quot;s/\\(CFLAGS=.*\\)/\\1 -mabi=32 -mglibc -march=mips32/g&quot; Makefilesed -i &quot;s/\\(CXXFLAGS=.*\\)/\\1 -mabi=32 -mglibc -march=mips32/g&quot; Makefilemake &amp;&amp; make install Notice: Configure 是大写的 C，并且执行完成后需要手动修改 Makefile。 asterisk设置编译 Asterisk 使用的 CFLAGS、LDFLAGS 参数： 123456789101112131415161718AST_CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include/ncurses&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/include&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/include/libxml2&quot;AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel/include&quot;AST_LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel/lib&quot;AST_LDFLAGS=&quot;$AST_LDFLAGS -lncurses&quot; 设置 Asterisk 运行时路径： 1AST_RUNTIME_DIR=&quot;/root&quot; 开始编译： 123456789101112131415161718192021222324CC=mipsel-linux-gcc CXX=mipsel-linux-g++ AR=mipsel-linux-ar RANLIB=mipsel-linux-ranlib \\CFLAGS=$AST_CLFAGS LDFLAGS=$AST_LDFLAGS \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=$AST_RUNTIME_DIR/build_opt/asterisk_build_for_mipsel \\--with-libedit=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel \\--with-sqlite3=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel \\--with-libxml2=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel \\--with-crypto=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \\--with-ssl=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \\--without-bluetooth \\--without-dahdi \\--with-jansson-bundled \\--with-pjproject-bundled \\--without-ldap \\--without-netsnmp \\--without-pri \\--disable-xmldocmake menuselect/menuselect menuselect-tree menuselect.makeoptsmenuselect/menuselect --enable-allmakemake install DESTDIR=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipselmake samples DESTDIR=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel Tips: 如果第 19 行报错，则再运行一次即可。 由于指定的运行路径和安装路径有可能不一致，所以需要修复一下： 123mv /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel/$AST_RUNTIME_DIR/build_opt/asterisk_build_for_mipsel /tmp/ast_tmprm -rf /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipselmv /tmp/ast_tmp /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel bcg729123456cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/bcg729-1.1.1CC=mipsel-linux-gcc \\cmake . -DCMAKE_INSTALL_PREFIX=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipselmake &amp;&amp; make install Tips: bcg729 最近的几个版本改为使用 cmake 构建，如果需要用 configure 的构建方式下载旧版本即可。 asterisk-g72x123456789101112cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/asterisk-g72x-master./autogen.shCC=mipsel-linux-gcc \\CFLAGS=&quot;-O3 -fomit-frame-pointer -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipsel/include&quot; \\LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipsel/lib&quot; \\./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \\--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel \\--with-bcg729 \\--with-asterisk-includes=/home/ubuntu/MIPSEL_Cross-Compile/build_start/asterisk-18.7.1/includemake &amp;&amp; make install Tips: --with-asterisk-includes 参数指定 Asterisk 源代码路径中的头文件。 库安装最后，将前面编译出的所有动态链接库（除 asterisk 以及 asterisk-g72x 外）都放置到 Asterisk 的运行目录中。 附录将以上描述的过程整理成一个 Makefile 文件，如下：","categories":[],"tags":[{"name":"Asterisk","slug":"Asterisk","permalink":"https://blog.mahyang.uk/tags/Asterisk/"},{"name":"Cross Compilation","slug":"Cross-Compilation","permalink":"https://blog.mahyang.uk/tags/Cross-Compilation/"}]},{"title":"使用 SIPp 测试 Asterisk 处理能力","slug":"testing-asterisk-using-sipp","date":"2021-03-05T09:06:27.000Z","updated":"2021-03-05T09:06:27.000Z","comments":true,"path":"2021/03/05/testing-asterisk-using-sipp/","link":"","permalink":"https://blog.mahyang.uk/2021/03/05/testing-asterisk-using-sipp/","excerpt":"本文将简单介绍 SIPp 的使用方法，然后重点介绍如何使用 SIPp 对 Asterisk 服务进行 SIP 注册与通话测试。","text":"本文将简单介绍 SIPp 的使用方法，然后重点介绍如何使用 SIPp 对 Asterisk 服务进行 SIP 注册与通话测试。 环境本文所有操作在 Ubuntu 20.04 和 Debian 10 操作系统上完成。 SIPpSIPp 是一款针对 SIP 协议的开源测试工具，使用此工具可以自定义发送各类 SIP 协议请求以及接收分析 SIP 协议响应，可用于模拟 VoIP 通话进行话音测试。 软件安装下载并解压源码： 1wget -c https://github.com/SIPp/sipp/releases/download/v3.6.1/sipp-3.6.1.tar.gz -O - | tar -xz -C /tmp 编译安装： 1234cd /tmp/sipp-3.6.1./build.sh --commonmake -j4sudo make install 使用方法SIPp 的详细使用方法请参考官方手册。此外可使用 sipp -h 命令查看 SIPp 软件的命令行参数说明。 命令行参数SIPp 使用 XML 描述语言来描述软件交互行为（情景），可通过命令行参数 -sf 指定自定义的 XML 文件： 1sipp -sf &lt;your_xml_file&gt; 同时 SIPp 也内置了一些 XML 文件来描述一些特定场景的交互过程，可通过 -sn 命令行参数加载内置文件： 1sipp -sn &lt;default_xml_file&gt; 例如，运行 SIPp 内置的 SIP 服务端示例： 1./sipp -sn uas 在同一台电脑上再运行 SIPp 内置的 SIP 客户端示例： 1./sipp -sn uac 127.0.0.1 此时 SIPp 便开始执行测试流程，界面如下： 我们不但可以传递预设参数给 SIPp，可能传递自定义参数，自定义参数保存在 csv 文件中，可通过如下方式传入： 1sipp -inf &lt;your_csv_file&gt; SIPp 使用的 csv 文件第一行指定读取方式： SEQUENTIAL 顺序读取 RANDOM 随即读取 USER 基于用户读取 从第2行开始便是 SIPp 读取的数据，每个测试实例读取一行，每行中的参数以 ; 号隔开： 1uklar;age;address 在 XML 文件中引用如上参数则分别使用 [field0]、[field1]、[field2]。 XML 情景描述这里用 SIP 注册为例讲解如何编写情景描述文件。 SIPp 使用的 XML 描述文件均以如下内容开头： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;&lt;!DOCTYPE scenario SYSTEM &quot;sipp.dtd&quot;&gt; 接着便是描述情景的 section： 123&lt;scenario name=&quot;My UAC registor&quot;&gt;&lt;!-- describe your scenario here --&gt;&lt;/scenario&gt; 所有的交互动作均要编写在 &lt;scenario/&gt; section 里。 根据 SIP 协议示例文档（rfc3665）确定交互流程： 注册交互流程UAC SIP Server | | | REGISTER | |---------------------------&gt;| | 401 Unauthorized | |&lt;---------------------------| | REGISTER | |---------------------------&gt;| | 200 OK | |&lt;---------------------------| | | 根据交互流程编写基本框架： 123456789101112131415161718192021&lt;send retrans=&quot;500&quot;&gt; &lt;![CDATA[ REGISTER ]]&gt;&lt;/send&gt;&lt;recv response=&quot;401&quot; auth=&quot;true&quot;&gt;&lt;/recv&gt;&lt;send retrans=&quot;500&quot;&gt; &lt;![CDATA[ REGISTER ]]&gt;&lt;/send&gt;&lt;recv response=&quot;200&quot; crlf=&quot;true&quot;&gt;&lt;/recv&gt; 其中 &lt;![CDATA[ ... ]]&gt; 用于指定 SIPp 发送的 SIP 协议帧内容，我们可以根据不同的场景自定义帧内容。 例如，模拟客户端 101 向服务器（asterisk） 192.168.199.59 发送 SIP 注册请求： 1234567891011121314&lt;![CDATA[ REGISTER sip:192.168.199.59 SIP/2.0 Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] Max-Forwards: 70 From: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;;tag=[pid]101[call_number] To: &quot;101&quot; &lt;sip:101@192.168.199.59&gt; Call-ID: [call_id] CSeq: 1 REGISTER Contact: &lt;sip:101@[local_ip]:[local_port]&gt;;transport=[transport] Expires: 3600 Content-Length: 0]]&gt; 如上，所有 [] 内的字段均可通过命令行参数指定，或 SIPp 自动填入默认值。 发送 SIP 注册消息后，我们等待服务端响应 401 未授权消息，然后发送携带认证信息的注册请求： 123456789101112131415&lt;![CDATA[ REGISTER sip:192.168.199.59 SIP/2.0 Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] Max-Forwards: 70 From: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;;tag=[pid]101[call_number] To: &quot;101&quot; &lt;sip:101@192.168.199.59&gt; Call-ID: [call_id] CSeq: 2 REGISTER Contact: &lt;sip:101@[local_ip]:[local_port]&gt;;transport=[transport] [authentication username=101 password=1234abcd] Expires: 3600 Content-Length: 0]]&gt; 我们只需在消息帧中加入 [authentication username=USERNAME password=PASSWD]，SIPp 便可根据前一条消息的内容自动计算并填入认证信息。 需要注意的是，定义前一条消息时（这里是 401），需要加入属性 auth=&quot;true&quot;。 最后我们等待服务端发送 200 OK 响应以完成 SIP 注册流程。 批量运行SIPp 的主要功能是将定义的情景通过不同的参数实例化出多个测试进程，实现并发测试。 还是以 SIP 注册为例，我们将之前的单用户注册改造为多用户并发向指定服务器注册，命令行指令如下： 1sipp -sf ./register.xml &lt;server_ip&gt; -i &lt;local_ip&gt; -users &lt;number_of_users&gt; -inf ./data.csv 相应参数的解释如下： server_ip：指定服务端 IP 地址，在 XML 文件中通过 [remote_ip] 引用 local_ip：指定客户端 IP 地址，在 XML 文件中通过 [local_ip] 引用 number_of_users：指定同时存在的用户数量 假定我们需要同时存在 3 个用户向服务器发起注册，则： data.csv 文件内容如下： 1234SEQUENTIAL101,[authentication username=101 password=1234abcd]102,[authentication username=102 password=1234abcd]103,[authentication username=103 password=1234abcd] 再修改前面例子中部分参数： 服务端 IP 地址 192.168.199.59 替换为 [remote_ip] 用户名 101 替换为 [field0] 授权信息 [authentication username=101 password=1234abcd] 替换为 [field1] 启动批量注册测试： 1sipp -sf ./register.xml 192.168.199.59 -i 192.168.199.30 -users 3 -inf ./data.csv 通话测试以下操作流程中涉及到的文件都能点击此处获取。 模拟 SIP 通话场景如下图： 模拟场景+---------------------------+ +---------------------------+ +----------------------------+| Host Caller | | Asterisk Server | | Host Callee || | | +&lt;---&gt;+ || N_Users: 49 +&lt;--&gt;+ N_Users: 98 | | N_Users: 48 || Codec : G729 | | Codecs : G711a G729 +&lt;-+ | Codec : G711a || IP : 192.168.199.30 | | IP : 192.168.199.59 | | | IP : 192.168.199.227 |+---------------------------+ +---------------------------+ | +----------------------------+ | | +----------------------------+ | | Yealink | | | | +-&gt;+ Codec : G711a | | IP : 192.168.199.35 | +----------------------------+ 在 Asterisk 服务器上创建 98 个用户： 123for i in &#123;101..198&#125;; do ext_manage.sh add $i; doneasterisk -rx &quot;core stop now&quot;asterisk 在 Host Caller 上生成 test_data.csv 文件： 12echo &quot;SEQUENTIAL&quot; &gt; test_data.csvfor i in &#123;101..149&#125;; do echo &quot;$i;$(expr $i + 49);[authentication username=$i password=1234abcd];[authentication username=$(expr $i + 49) password=1234abcd]&quot; &gt;&gt; test_data.csv; done 在 Host Callee 上生成 test_data.csv 文件： 12echo &quot;SEQUENTIAL&quot; &gt; test_data.csvfor i in &#123;101..148&#125;; do echo &quot;$i;$(expr $i + 49);[authentication username=$i password=1234abcd];[authentication username=$(expr $i + 49) password=1234abcd]&quot; &gt;&gt; test_data.csv; done 在 Host Caller 上用 SIPp 注册 49 个用户： 1sudo sipp -sf ./my_caller_register.xml 192.168.199.59 -i 192.168.199.30 -users 49 -inf ./test_data.csv 在 Host Callee 上用 SIPp 注册 48 个用户： 1sudo sipp -sf ./my_callee_register.xml 192.168.199.59 -i 192.168.199.227 -users 48 -inf ./test_data.csv 在 Yealink 上使用账户 198 向服务器注册，并在设置中关闭视频通话，只开启 g711a 话音编码。 在 Host Callee 上用 SIPp 启动接收 48 路通话： 1sudo sipp -sf ./my_callee_flow.xml 192.168.199.59 -i 192.168.199.227 -users 48 -inf ./test_data.csv 在 Host Caller 上用 SIPp 启动呼叫 49 路通话： 1sudo sipp -sf ./my_caller_flow.xml 192.168.199.59 -i 192.168.199.30 -users 49 -inf ./test_data.csv 此时我们可以在 Yealink 上收到呼叫，接听后可通过话音质量来主观感受服务器压力状态。 同时可查看服务器 CPU 占用状况：","categories":[],"tags":[{"name":"操作方法","slug":"操作方法","permalink":"https://blog.mahyang.uk/tags/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"QEMU","slug":"QEMU","permalink":"https://blog.mahyang.uk/tags/QEMU/"},{"name":"ARM64","slug":"ARM64","permalink":"https://blog.mahyang.uk/tags/ARM64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.mahyang.uk/tags/Ubuntu/"}]},{"title":"使用 QEMU 启动 ARM aarch64 架构 Ubuntu 虚拟机","slug":"QEMU-安装-Ubuntu-ARM64-架构操作系统","date":"2021-03-01T01:35:03.000Z","updated":"2021-03-13T07:51:43.000Z","comments":true,"path":"2021/03/01/QEMU-安装-Ubuntu-ARM64-架构操作系统/","link":"","permalink":"https://blog.mahyang.uk/2021/03/01/QEMU-%E5%AE%89%E8%A3%85-Ubuntu-ARM64-%E6%9E%B6%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。","text":"本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。 环境本文所有操作均在 Ubuntu20.04 操作系统上完成。 安装 QEMU安装启动 aarch64 ubuntu 所需的依赖程序： 1234sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager qemusudo apt install qemu-system-aarch64sudo apt install qemu-efi-aarch64sudo apt install qemu-utils 创建镜像创建启动必备的 flash 镜像： 123dd if=/dev/zero of=flash1.img bs=1M count=64dd if=/dev/zero of=flash0.img bs=1M count=64dd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=flash0.img conv=notrunc 下载想要启动的镜像，本文选用 Ubuntu16.04： 1wget http://ports.ubuntu.com/ubuntu-ports/dists/xenial-updates/main/installer-arm64/current/images/netboot/mini.iso 创建空硬盘镜像，此镜像用于安装操作系统： 1qemu-img create ubuntu-image.img 20G 至此准备工作完成。 安装系统启动系统安装器： 12345qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 512M -cpu max -smp 4 \\-netdev user,id=vnet,hostfwd=:127.0.0.1:0-:22 -device virtio-net-pci,netdev=vnet \\-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \\-drive file=mini.iso,if=none,id=drive1,cache=writeback -device virtio-blk,drive=drive1,bootindex=1 \\-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 根据提示信息完成操作系统安装。 安装完成之后通过 Ctrl-a x 退出 QEMU 。 启动镜像这里我们希望将虚拟机接入宿主机所在网络，如下图： 网络连接图+-----------------------------------------------------------------+| Host || +---------------------+ || | | || | br0: | || | 192.168.199.32/24 +-----+ || | | | || +----+----------------+ | +-------------------------+ || | | | Guest | || | | | +---------------------+ | || +----+----------------+ +--+---+ | | | | || | | | | | | eth0: | | || | enp3s0: | | tap0 | | | 192.168.199.33/24 | | || | 192.168.199.30/24 | | +-----+ | | || | | | | | +---------------------+ | || +---------------------+ +------+ +-------------------------+ |+-----------------------------------------------------------------+ 配置网桥 br0： 12345sudo ip link add name br0 type bridgesudo ip link set dev br0 downsudo ip addr flush dev br0sudo ip addr add 192.168.199.32/24 dev br0sudo ip link set dev br0 up 配置 tap 设备 tap0： 12sudo ip tuntap add name tap0 mode tapsudo ip link set dev tap0 up 将宿主机网络接口 enp3s0 和 tap0 接入网桥 br0： 12sudo ip link set enp3s0 master br0sudo ip link set tap0 master br0 启动虚拟机系统： 1234567sudo qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 1G -cpu max -smp 4 \\-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \\-device virtio-net-pci,netdev=mynet0,mac=$(qemu-mac-hasher.py ubuntu1604-arm64) \\-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback \\-device virtio-blk,drive=drive0,bootindex=0 \\-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash \\-device virtio-rng-pci 以上命令指定 qemu 使用 tap 设备作为虚拟机网络接口并且指定使用刚刚创建的 tap0 接口。 为了指定虚拟器的 MAC 地址我们使用一个脚本来为每个虚拟机生成特定地址。MAC 地址的生成脚本如下： qemu-mac-hasher.py12345678#!/usr/bin/env python# usage: qemu-mac-hasher.py &lt;VMName&gt;import sysimport zlibcrc = str(hex(zlib.crc32(sys.argv[1].encode(&quot;utf-8&quot;))))[-8:]print(&quot;52:54:%s%s:%s%s:%s%s:%s%s&quot; % tuple(crc)) 虚拟机启动后根据需要配置其网络参数即可。 优化网络以上步骤完成后虚拟机可与宿主机所在网络的其他设备互连（包括宿主机），也可以通过指定的网关连接互联网，但是此时宿主机无法连接互联网，解决方法如下： 删除 enp3s0 接口的默认网关： 1sudo ip route del default dev enp3s0 为 br0 添加默认网关： 1sudo ip route add default via 192.168.199.1 dev br0","categories":[],"tags":[{"name":"操作方法","slug":"操作方法","permalink":"https://blog.mahyang.uk/tags/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"QEMU","slug":"QEMU","permalink":"https://blog.mahyang.uk/tags/QEMU/"},{"name":"ARM64","slug":"ARM64","permalink":"https://blog.mahyang.uk/tags/ARM64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.mahyang.uk/tags/Ubuntu/"}]},{"title":"用 LXD 容器化 VoIP 服务","slug":"create-a-linux-container-of-debian-with-asterisk-freepbx-installed","date":"2020-07-25T02:39:18.000Z","updated":"2020-07-26T08:31:33.000Z","comments":true,"path":"2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/","link":"","permalink":"https://blog.mahyang.uk/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/","excerpt":"将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。","text":"将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。 Why如果你的 VoIP 服务开发环境、测试环境和生产环境在同一台物理机上，也许不会察觉到环境搭建的繁琐以及消耗在配置环境上的时间。让我们来设想这样一个场景：客户指定使用某一个 Linux 发行版安装 Asterisk（或者配合 FreePBX）开发一套存在特定需求的 VoIP 服务，基于这个前提你拿到一台新的设备开始工作： 首先安装配置某个指定 Linux 发行版（花费1、2个小时）； 接着编译、安装、配置 Asterisk（1个小时）； 然后安装配置 FreePBX（花费2小时解决无数个问题）； 最后完成测试（花费1小时）。 终于在5、6个小时后你搭建好了开发环境，接着发现还有测试环境和生产环境需要搭建，于是你再花上2倍于之前的时间完成了环境搭建工作。总算可以开始开发了，你开始实现某一项功能，为了完成这项功能可能： 需要变动 Asterisk 的配置； 需要变动 FreePBX 的接口； 系统某些环境变量、配置参数需要改动。 于是你将这些变动都同步执行到测试和生产环境以保证各平台的环境一致，这将耗费开发人员大量的时间。同时，一个项目中面临几十上百项功能的开发需求，很快你就会发现因为环境配置失步导致的开发流程失控，比如开发环境能实现的功能在测试环境失效，在生产环境出现的问题在开发环境无法复现。 问题总结： 开发人员在搭建环境和保证各平台环境配置同步的过程中耗费大量时间； 手动操作进行配置同步难免会出错，出现运行环境失控的情况。 为了解决这2方面问题，我们可以将服务程序及其所依赖的环境打包进容器中使得整套环境容器化，然后在各个平台分发此容器以保证环境的一致性。 How本次测试的环境是 Debian 10，以下分4个步骤完成 VoIP 服务容器化： 安装并配置 LXD； 制作根文件系统，其中安装了 Asterisk 以及 FreePBX； 将此根文件系统打包作为基础镜像导入 LXD； 从 LXD 中的基础镜像启动一个实例，并配置网络。 安装并配置 LXDLXD 是一下代开源系统容器、虚拟机管理器。关于 LXD 更为详细的介绍请参考官方文档。 使用 snap 安装 LXD，如果系统没有 snap 先安装 snap： 12sudo apt install snapsudo snap install core 安装 LXD： 1sudo snap install lxd 将用户添加到 lxd 组： 1sudo usermod -a -G lxd $YOUR_USERNAME 配置 LXD一般情况下直接在命令行中输入 lxd init 然后全部选择都使用默认选项即可。这里我希望使用自定义的存储设备作为 lxd 的 storage pool。 首先创建一个大小合适的空文件： 12mkdir $HOME/lxd_storagedd if=/dev/zero of=$HOME/lxd_storage/disk bs=1M count=51200 # 50G 创建新的 loop device 并将刚刚创建的空文件关联到此设备： 12losetup /dev/loop14 $HOME/lxd_storage/disk # 先查看 /dev 目录下是否已有 loop14，有则换一个如：loop15sudo reboot # 重启生效配置 初始化 lxd 配置： 1234567891011121314151617uklar@debian:~# lxd initWould you like to use LXD clustering? (yes/no) [default=no]:Do you want to configure a new storage pool? (yes/no) [default=yes]:Name of the new storage pool [default=default]:Name of the storage backend to use (btrfs, dir) [default=btrfs]:Would you like to create a new btrfs subvolume under /var/lib/lxd? (yes/no) [default=yes]: noCreate a new BTRFS pool? (yes/no) [default=yes]:Would you like to use an existing block device? (yes/no) [default=no]: yesPath to the existing block device: /dev/loop14Would you like to connect to a MAAS server? (yes/no) [default=no]:Would you like to create a new local network bridge? (yes/no) [default=yes]:What should the new bridge be called? [default=lxdbr0]:What IPv4 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:What IPv6 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]: noneWould you like LXD to be available over the network? (yes/no) [default=no]:Would you like stale cached images to be updated automatically? (yes/no) [default=yes] noWould you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]: 制作根文件系统这里使用 debootstrap 获取 debian 的根文件系统： 123sudo apt install debootstrapmkdir /tmp/debiansudo debootstrap buster /tmp/debian 使用 systemd-nspawn 以 chroot 模式切换到 /tmp/debian 中： 12sudo apt install systemd-container # 此软件包中包含了 systemd-nspawnsudo systemd-container -D /tmp/debian 做一些基本配置，如设置 root 用户密码、添加普通用户以及配置网络等，然后退出： 12345678910111213141516171819202122232425passwduseradd -m $USERNAMEpasswd $USERNAMEapt install sudousermod -a -G sudo $USERNAMEusermod --shell /bin/bash $USERNAMEcat &lt;&lt;EOF &gt;/etc/network/interfaces# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The eth0 network interfaceauto eth0iface eth0 inet dhcpEOFexit 接着使用 systemd-nspawn 的容器模式启动 /tmp/debian 以 root 身份登陆： 1sudo systemd-nspawn -D /tmp/debian --boot 在容器中安装 Asterisk 以及 FreePBX，过程请参考： Asterisk 安装脚本 FreePBX 安装脚本 配置 hostname： 123apt install dbushostnamectl set-hostname debian.voip.netecho &#x27;127.0.0.1 debian.voip.net&#x27; &gt;&gt;/etc/hosts 访问服务器 Web 页面验证容器中的 VoIP 服务是否正常运行： 从 systemd-nspawn 容器中退出： 1shutdown now 创建 LXD 镜像将刚刚配置完成的根文件系统打包并压缩： 123mkdir -p ~/container/images/voip_basecd ~/container/images/voip_basesudo tar czf voip_base.tar.gz -C /tmp/debian . 为镜像创建 metadata 文件： 1234567891011cat &lt;&lt;EOF &gt;./metadata.yamlarchitecture: &quot;x86_64&quot;creation_date: $(date +%s)properties: architecture: &quot;x86_64&quot; description: &quot;Debian(buster) with preinstalled Asterisk13&amp;FreePBX15 ($(date +%Y%m%d))&quot; os: &quot;debian&quot; release: &quot;buster&quot;EOFtar czf metadata.tar.gz metadata.yaml 将压缩包作为镜像导入 LXD： 1234lxc image import \\~/container/images/voip_base/metadata.tar.gz \\~/container/images/voip_base/voip_base.tar.gz \\--alias voip-base 查看镜像是否成功导入： 1lxc image list 从镜像启动实例有了基础镜像之后，启动一个新的 VoIP 服务实例只需一行命令： 1lxc launch voip-base test 查看实例运行状态： 1lxc list 可以看到 VoIP 服务实例（名字为 test）正在运行，分配的内部 IP 地址是 10.72.18.48。 可用以下命令登陆到实例中： 1lxc exec test bash 查看各类服务使用的端口： 1lsof -i -P -n 宿主机网络配置让宿主机（IP 为 192.168.0.107）所在网络（192.168.0.0/24）的其他设备能够访问 VoIP 服务（IP 为 10.72.18.48），需要在宿主机上配置网络地址转换（NAT）： 发送到宿主机 5060 端口的 UDP 包（PJSIP）转发到容器实例 发送到宿主机 5160 端口的 UDP 包（SIP）转发到容器实例 发送到宿主机 10000 - 20000 端口的 UDP 包（语音）转发到容器实例 发送到宿主机 80 端口的 TCP 包（Web 管理服务）转发到容器实例 以上配置可根据实际需求更改。 这里使用 iptables 来完成，使用 exit 从实例退出返回宿主机，执行： 1234sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5060 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5160 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 10000:20000 -j DNAT --to 10.72.18.48sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p tcp --dport 80 -j DNAT --to 10.72.18.48 查看 NAT 配置状态： 1sudo iptables -t nat -v -L PREROUTING -n 现在即可通过宿主机的 IP 访问宿主机上容器化的 VoIP 服务了。 Asterisk 网络配置配置 Asterisk 的 SIP 参数： externip 为 192.168.0.107 localnet 为 10.72.18.0/24 这样 VoIP 服务才能向 SIP 终端正确地发送 contact 参数，否则终端与服务器的 SIP 协议交互会出错。 直接使用 FreePBX 完成配置（Settings -&gt; Asterisk SIP Settings）： 总结本文详细介绍了如何将 VoIP 服务容器化，涉及的内容包括 LXD 的使用、systemd-nspawn 的使用、根文件系统制作、容器镜像制作以及和 VoIP 服务相关的网络配置。通过容器化的操作能让各平台的运行环境保持一致，减少开发人员不必要的时间损耗。至于选择 LXD 作为实现容器化的平台原因有2： VoIP 服务软件组成复杂，部署在一个带根文件系统的容器中更为方便； LXD 的实现性能较好，关于业界几种容器化工具的性能对比分析请参考论文 Performance analysis of multi services on container Docker, LXC, and LXD","categories":[],"tags":[{"name":"Asterisk","slug":"Asterisk","permalink":"https://blog.mahyang.uk/tags/Asterisk/"},{"name":"LXD","slug":"LXD","permalink":"https://blog.mahyang.uk/tags/LXD/"},{"name":"VoIP","slug":"VoIP","permalink":"https://blog.mahyang.uk/tags/VoIP/"},{"name":"FreePBX","slug":"FreePBX","permalink":"https://blog.mahyang.uk/tags/FreePBX/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://blog.mahyang.uk/tags/systemd-nspawn/"}]},{"title":"【OSTEP 练习题】测量操作系统切换上下文的耗时","slug":"ostep-measure-cost-of-context-switch","date":"2020-07-11T08:49:16.000Z","updated":"2021-03-02T02:47:19.000Z","comments":true,"path":"2020/07/11/ostep-measure-cost-of-context-switch/","link":"","permalink":"https://blog.mahyang.uk/2020/07/11/ostep-measure-cost-of-context-switch/","excerpt":"尝试解答 OSTEP 1 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。","text":"尝试解答 OSTEP 1 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。 环境使用的测试平台 CPU 是 Intel i5-6200U，主频 2.3GHz，操作系统是 Arch Linux，内核版本 5.7.7。 方法为了尽量准确地测量进程上下文切换耗时，需要有如下几个前提： 创建 2 个测试进程； 保证这 2 个进程运行在同一个 CPU 核上（鉴于目前的计算平台一般为多核 CPU）； 保证正在运行这 2 个测试进程的 CPU 核上没有运行其他用户进程； 尽量使操作系统在指定时刻执行进程调度（与此同时执行上下文切换）。 进程创建使用 fork 系统调用创建子进程： 12345678910switch (fork()) &#123;case -1: // error handling exit(EXIT_FAILURE);case 0: // child process // do something in child process exit(EXIT_SUCESS);default: // parent process // do something in parent process exit(EXIT_SUCESS);&#125; sched_setaffinity使用 sched_setaffinity 指定进程运行在 CPU3 这个核心上： 1234567891011#define CPU_NUM 3cpu_set_t set;CPU_ZERO(&amp;set);CPU_SET(CPU_NUM, &amp;set);if (sched_setaffinity(getpid(), sizeof(set), &amp;set) &lt; 0) &#123; // error handling&#125;// set successfully// do other things 此操作只需在父进程 fork 子进程之前执行即可，子进程默认情况下会和父进程运行在同一个 CPU 核上。 内核启动参数为了保证指定的 CPU 核上只有用于测试的 2 个用户进程，需要设置 isolcpus 这个启动参数给内核。此参数告诉内核在调度其余用户进程时排除指定的 CPU 核心。 12cat /proc/cmdline# BOOT_IMAGE=... isolcpus=3 ... 重新启动计算机，在进入 GRUB 启动界面时选择启动项并按下 e，进入启动项编辑界面，找到 linux 为开头的一行在行尾添加如下启动参数： 1isolcpus=3 # 3 代表测试平台中 CPU 的一个核的编号 查看设备 CPU 核心数可在进入系统后命令行执行： 1lscpu 或者： 1cat /proc/cpuinfo 设置完后可以用 stress 命令测试一下： 12sudo pacman -S stressstress --cpu 8 从下图可以看出内核在调度用户进程时绕开了 CPU3（从 0 开始计数）。 Pipe以上几个步骤保证了在 CPU3 核心上只有用于测试的 2 个用户进程，接下来只需要让内核来回切换（调度）这 2 个测试进程即可。 使用的方法是：创建 2 个 pipe，子进程向 pipe0 写入一个字符然后从 pipe1 读取一个字符，父进程从 pipe0 读取一个字符然后将读取到的字符写入 pipe1，这样重复 N&#x2F;2 次。当子进程在“等待”读取时内核就执行调度切换到父进程，当父进程在“等待”读取时内核执行调度切换到子进程，所以测试进程一次“读写”完成后内核执行了 2 次上下文切换，既总共完成了 N 次切换。更加直观的过程如题图所示。 结果在我的平台2 上的测试结果为：操作系统上下文切换平均耗时 3.42 微秒。 源码 注释[1] Operating System: Three Easy Pieces - ARPACI-DUSSEAU[2] Intel i5-6200U @ 2.3GHz, Arch Linux, Kernel 5.7.7","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://blog.mahyang.uk/tags/Operating-System/"},{"name":"Context Switch","slug":"Context-Switch","permalink":"https://blog.mahyang.uk/tags/Context-Switch/"}]},{"title":"复刻 Linux 操作系统到另一台设备","slug":"复刻-Linux-操作系统到另一台设备","date":"2020-05-08T06:32:27.000Z","updated":"2020-05-08T09:42:17.000Z","comments":true,"path":"2020/05/08/复刻-Linux-操作系统到另一台设备/","link":"","permalink":"https://blog.mahyang.uk/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/","excerpt":"rsync 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 rsync 作为核心工具来介绍如何复刻 Linux 操作系统。","text":"rsync 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 rsync 作为核心工具来介绍如何复刻 Linux 操作系统。 准备工作需要注意的是源设备和目标设备之间的 CPU 架构需保持一致。 硬件 一台被复刻的设备作为源设备（参考搭建 IPPBX 基础开发环境） 一台新设备作为目标设备 一个 Linux USB 启动盘（制作方法网络上很多这里不多作介绍，我制作的是 Debian10 USB 启动盘） 软件 rsync openssh-server（可选） 配置源设备在搭建 IPPBX 基础开发环境一文中我们已经搭建好了一个开发环境，其中的 /dev/sdb2 设备里包含了一个完整的用于生产环境的操作系统。现在我们将 /dev/sdb2 用作拷贝源。 源设备网络简单的方法是将源设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和目标设备直接连接的方式，则需要自己配置静态 IP 地址。 挂载 /dev/sdb212sudo mkdir -p /mnt/debian_10sudo mount /dev/sdb2 /mnt/debian_10 安装&amp;配置 rsync1234567891011121314$ sudo -ienter your passwd:apt install rsynccat &lt;&lt; EOF &gt; /etc/rsyncd.confuid = rootgid = rootuse chroot = no[all] path = /EOFrsync --daemonexit 配置目标设备将目标设备从 USB 启动盘启动，然后将必备的软件安装好。 目标设备网络简单的方法是将目标设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和源设备直接连接的方式，则需要自己配置静态 IP 地址。 使用 rsync 复刻系统使用 rsync 将源设备上 Linux 系统复刻到目标设备上的方法有两种： 使用脚本操作 手动操作 推荐使用脚本，用 root 用户执行脚本之后根据提示信息操作即可。如果需要手动操作，则接着往下看（后面的操作均使用 root 用户执行）。 对目标硬盘分区首先查看一下分区信息： 1234567$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 119.2G 0 disk├─sda1 8:1 0 4G 0 part└─sda2 8:2 0 115.2G 0 partsdb 8:16 1 14.3G 0 disk└─sdb1 8:17 1 14.3G 0 part / 其中 sdb 是 USB 启动盘 sda 是目标设备上的硬盘。对 sda 分区： 1234567dd if=/dev/zero of=/dev/sda bs=1024 count=1sfdisk --force /dev/sda &lt;&lt; EOF1M,4G,S,,,L,*EOFmkswap /dev/sda1mkfs.ext4 /dev/sda2 这里我们将 sda 划了2个分区，第一个是4G的交换分区，剩余的空间划分为系统分区并格式化为 ext4 文件系统（分区方式需和源设备保持一致）。 从源设备同步文件首先将刚刚创建好的系统分区挂载到本地目录： 12mkdir -p /mnt/rsync_tmpmount /dev/sda2 /mnt/rsync_tmp 检查一下与源设备的连通性（假定源设备的 IP 地址是 192.168.198.140）： 1ping -c 1 192.168.198.140 开始同步： 1rsync -avHX 192.168.198.140::all/mnt/debian_10/ /mnt/rsync_tmp/ 注意：路径结尾处的 / 必须有。 重新安装 GRUB 启动器从源设备同步完成之后，目标设备上的 GRUB 启动器以及其配置都未更新，所以需要更新。 首先获取2个分区的 UUID： 1234$ blkid /dev/sda1/dev/sda1: UUID=&quot;XXXX&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;XXX&quot;$ blkid /dev/sda2/dev/sda2: UUID=&quot;XXXX&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;XXX&quot; 将对应分区的 UUID 更新到 /mnt/rsync_tmp/etc/fstab 文件中后执行： 12345mount --bind /proc /mnt/rsync_tmp/procmount --bind /sys /mnt/rsync_tmp/sysmount --bind /dev /mnt/rsync_tmp/devmount --bind /run /mnt/rsync_tmp/runchroot /mnt/rsync_tmp 进入到 chroot 环境后，更新 GRUB： 12grub-install /dev/sdaupdate-grub 重启设备1reboot 进入 BIOS 中将启动设备设置为硬盘后启动，即可进入完成复刻的 Linux 系统。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"rsync","slug":"rsync","permalink":"https://blog.mahyang.uk/tags/rsync/"},{"name":"clone file system","slug":"clone-file-system","permalink":"https://blog.mahyang.uk/tags/clone-file-system/"}]},{"title":"搭建 IPPBX 基础开发环境","slug":"搭建-IPPBX-基础开发环境","date":"2020-05-06T05:58:46.000Z","updated":"2020-05-08T09:42:23.000Z","comments":true,"path":"2020/05/06/搭建-IPPBX-基础开发环境/","link":"","permalink":"https://blog.mahyang.uk/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。","text":"软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。 需求整个开发环境里有如下设备： 一台开发机，包含2块硬盘 N 台目标设备（最终业务运行在这些设备上） 实际的开发场景应该是：开发机随时运行着，其运行状态为：2块硬盘各有一个 Linux 操作系统，其中一个为主系统另一个以类似容器的形式运行在主系统中。主系统中只安装各类开发工具，不运行任何与项目业务相关的服务，所有和项目业务相关的服务都运行在“容器1”中。开发人员通过 SSH 远程登陆到主系统中完成开发，或者本地开发完成后将软件服务同步到主系统，维护人员再将新的内容同步到“容器”中。 实际的系统部署场景应该是：当需要将系统部署到新设备上时，维护人员只需将开发机上2块硬盘中存放“容器”的那块硬盘中的数据“拷贝2”到新设备的硬盘中即可。 目标在着手搭建环境之前需要了解清楚开发环境搭建针对的目标，本例中的目标很简单只有如下2个： 便于开发工作的进行。 能方便地将完成了开发工作的系统部署到新设备上。 拆分需求结合前面需求和目标可得到如下细分的功能： 开发机上需要在其中一块硬盘中安装并运行一个 Linux 操作系统。 开发机上的另一块硬盘安装一个 Linux 操作系统，此系统能脱离主系统独立运行，同时又能作为“容器”运行在主系统之中。 需要一个同步方法，能将“容器”同步到新设备的硬盘中。 选择操作系统及软件工具对于开发机的主操作系统这部分没有严格的要求，选择一个适合自己使用习惯的较新的 Linux 发行版即可，这里作为演示我选择的是 Ubuntu20.04。 容器中运行的操作系统，同时也是最终设备中运行的操作系统，这部分对系统的稳定性以及很多软件的兼容性要求更高一些，所以我们选择 Debian10。 对于“容器化”的部分，目前有很多容器化技术，如功能非常少但使用非常简单的 chroot（甚至不能作为容器技术🙈）；又如功能非常强大但使用起来有一定门槛的 docker、podman 或者 Ubuntu 推出的 LXC 等；还有介于前面两种之间的 systemd-nspawn。鉴于本例中的使用场景，我们选择 systemd-nspawn，因为其不仅能在我们的需求范围内很好地隔离主系统与“容器”而且使用方法相对简单。 对于“同步”这部分，我们选择 rsync，这是一个基于增量传输的文件同步软件，既可用通过单机本地同步也可通过网络同步，能满足我们开发环境中的同步需求。 安装主系统主操作系统我们选用的是 Ubuntu20.04 安装方法网络上很多，搜索一下即可，这里不再介绍。 容器中的系统本例中我们采用的是 Debian10，安装方法同上。值得注意的是，此系统需安装到开发机的另一块硬盘上，同时在安装前可先取下安装了主系统的硬盘，这样主系统的启动条目就不会出现在“容器”的 grub 启动选项中。此外，分区方式推荐如下： 123sdb 8:16 0 232.9G 0 disk├─sdb1 8:17 0 16G 0 part [SWAP]└─sdb2 8:18 0 216.8G 0 part 其中交换分区根据自己的实际需求划分，剩下的空间全部作为 / 分区。 工具软件在主系统中安装软件包 systemd-contianer（此中软件包中包含 systemd-nspawn 工具）以及安装同步工具 rsync。 123sudo apt updatesudo apt install systemd-contianersudo apt install rsync 注：关于使用 rsync 来同步容器到新设备的方法放在另一篇文章中阐述。 运行“容器”将2块装好了操作系统的硬盘都接到主板上，然后启动开发机进入 BIOS 将装有 Ubuntu20.04 操作系统的硬盘设置到启动序列的第一位。进入主系统后，查看硬盘分区，大致如下： 12345678$ lsblksda 8:0 0 931.5G 0 disk├─sda1 8:1 0 15.3G 0 part [SWAP]├─sda2 8:2 0 122.1G 0 part /└─sda3 8:3 0 794.2G 0 part /homesdb 8:16 0 232.9G 0 disk├─sdb1 8:17 0 16G 0 part└─sdb2 8:18 0 216.8G 0 part 其中 sda 中安装了我们的主系统（Ubuntu）也就是当前运行的系统，sdb 中安装了“容器”的系统（Debian）。 创建挂载点 1sudo mkdir /mnt/debian_10 挂载 sdb 中的文件系统 1sudo mount /dev/sdb2 /mnt/debian_10 使用 systemd-nspawn 进入“容器”环境 12345678910111213$ sudo systemd-nspawn -D /mnt/debian_10 -bpawning container debian10 on /mntdebian_10.Press ^] three times within 1s to kill container....Welcome to Debian GNU/Linux 10 (buster)!...Debian GNU/Linux 10 debian consoledebian login: 到此我们就进入了“容器”环境。在容器内部我们可以认为在另一个操作系统里，于是可以执行任何命令以及安装各种软件但是并不影响主系统。例如我们可以安装 Asterisk 与 FreePBX 退出容器 1sudo shutdown now 或者在 1s 内按下 ^] 3次。（control 键 + ] 键） 容器中安装平台环境SSH1234sudo apt updatesudo apt install openssh-serversudo systemctl start sshsudo systemctl enable ssh Asterisk参考 Asterisk 自动安装脚本。 注意：此脚本仅在 Ubuntu18.04 以及 Debian10 中测试通过。 FreePBX参考 FreePBX 自动安装脚本。 注意：此脚本仅在 Ubuntu18.04 以及 Debian10 中测试通过。 总结本文介绍了 搭建 IPPBX 基础开发环境 中的操作系统、工具软件选择以及容器的制作与运行。下一篇将接着介绍如何将容器同步到新设备上。 注释[1] 这里的容器不是指完整的容器技术，仅仅采用了 Linux 容器的概念。 [2] 只借用“拷贝”的概念，实际操作要更复杂一些。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://blog.mahyang.uk/tags/systemd-nspawn/"},{"name":"rsync","slug":"rsync","permalink":"https://blog.mahyang.uk/tags/rsync/"}]},{"title":"简明架构","slug":"简明架构","date":"2020-03-28T14:30:44.000Z","updated":"2020-03-30T16:34:12.000Z","comments":true,"path":"2020/03/28/简明架构/","link":"","permalink":"https://blog.mahyang.uk/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/","excerpt":"最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。 原文地址： The Clean Architecture","text":"最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。 原文地址： The Clean Architecture 以下为译文。 在过去的几年间我们已经看到过各种各样关于系统架构的设想，如下： 来自 Alistair Cockburn 的六边形架构（也称接口与适配），此架构被 Steve Freeman 与 Nat Pryce 在其合著的《测试驱动的面向对象软件开发》一书中采纳 来自 Jeffrey Palermo 的洋葱架构 我去年在博客中提出的令人惊叹的架构 由 James Coplien 和 Trygve Reenskaug 提出的 DCI Ivar Jacobson 在其所著的《实例驱动的面向对象软件工程》一书中提出的 BCE 虽然以上这些架构都在细节上有所不同，但在宏观上非常相似。它们有同一个的目标，关注对软件的拆分，通过将软件分解为不同的层次，以达到拆分的目的。每种架构都至少有一层用于描述业务规则，其他层次用于创建接口。 使用这些架构所产生的系统都有以下特点： 独立于框架。架构不依赖于功能丰富的软件库。这让你能够将软件框架作为工具使用，而不用为了使用框架将其塞入系统以满足框架的限制。 可测试。业务规则能够在没有界面、数据库、Web 服务器或其他元素的情况下被测试。 独立于界面。可以在不改变系统其余部分的情况下很容易地修改界面。例如，可以将 Web 界面改为命令行界面却不改变业务规则。 独立于数据库。你可以随时弃用 Oracle 或 SQL Server 的数据库改为使用 Mongo、BigTable、CouchDB 或者其他数据库。因为你的业务规则不与数据库绑定。 独立于任意外部机构。事实上你的业务规则根本对外部世界一无所知。 依赖规则图中每一个同心圆表示不同领域的软件。通常，项目开发得越久软件所处的层级越高。外层圆是机制，内层是策略。 使这个架构能够正常运转而起到决定性作用的规则是依赖规则。这个规则描述了源代码的依赖关系只能由外部指向内部，处于内圈的代码对处于外圈的代码一无所知。特别的，在外圈定义的对象的名称必不能被处于内圈的代码提及。这些对象包括：函数、类、变量或者其他有名称的软件实体。 出于同样的原因，在外圈使用的格式化数据不应该在内圈被使用，特别是由某种软件框架产生的格式化数据。我们不希望外圈的任何事物影响到内圈。 实体实体封装了企业范围内的业务规则。实体可以是携带方法的对象也可以是由数据结构和函数组成的集合。实体只要能被企业中不同的应用程序使用即可，具体是什么则无关紧要。 如果你没有开发企业级软件而是在写单个应用程序，那么这些实体可以是应用程序的业务对象，其中封装了最普遍最高层次的规则。如果架构的外围发生了改变那么实体将会是最后一个需要修改的。例如，你不希望当页面导航或者安全保护方面产生了变更而影响到实体。总的来说，任意指定程序的操作变更都不应影响实体层。 用例处于这一层的软件包含面向应用程序的业务规则，封装和实现所有系统用例。这些用例编排数据流动包括流向实体和从实体流入，以及引导实体使用企业业务规则来实现用例的目的。 同样，我们不希望这一层的变更影响实体。也不希望这一层受到外部变更的影响，比如数据库、UI 或者任意软件框架，此层与这些情况无关。 可以预期，应用程序操作的变更会影响用例进而影响处于此层的软件。如果用例本身发生了变化，那么处于此层的代码一定会受到影响。 接口适配器处于此层的软件通常是一组适配器。适配器的作用是将方便于用例和实体使用的数据格式转换为方便外部机构使用的数据格式。外部机构包括数据库、Web 等。比如在此层中会完全包含图形用户界面的 MVC 架构，表示器、视图以及控制器都属于此层。模型一般表示为数据结构，从控制器传给用例，再从用例返回到表示器和视图。 类似的，数据从方便用例和实体使用的形式转换到方便持久化框架（如数据库）使用的形式也发生在此层。从这一层向内的所有代码都对数据库不了解。如果数据是 SQL 数据库那么所有的 SQL 语句都应该被限制在此层用于与数据库交互的部分。 当然此层还有另一种必备的适配器，用于将来自外部服务的数据格式转换为用例和实体使用的内部数据格式。 框架和驱动最外一层通常是由软件框架与工具组成，例如数据库、Web 开发框架等。一般你不需要在此层写大量代码而是写一些“胶水”代码用于与紧邻的内层通信。 这一层是所有具体细节出现的地方，例如 Web、数据库都充满各种细节需要关注，将这类事物放到最外层可以最大可能地减少对整体系统的影响。 仅有四层？不是，此图只是概念展示。在实际操作中你会发现所需的不止四层，也没有规定一定只能有四层。无论怎样依赖原则始终有效，即源代码总是向内依赖。越往内越抽象。最外圈是最低层次包含最具体的细节，越往内软件越为抽象封装更高层次的策略，最中心的圈也就最一般化。 跨越边界在图示中的右下角可以看到一个示例展示了我们如何跨越不同层次的边界。可以看到控制器和表示器通过它们隔壁层的用例来互相通信。注意控制的流向，它从控制器开始，通过用例最后在表示器中执行以结束。在看源代码的依赖方向，它们都向内指向用例，这就产生了矛盾。 通常我们使用依赖倒置原则解决这个显而易见的冲突。诸如 Java 一类的编程语言我们可以通过组织一组接口和类继承关系使得在适当的时候让源代码的依赖方向和控制方向相反以实现跨越边界。 例如，考虑当用例需要调用表示器的情况。这种调用方式必不能直接实现，因为这样违反了依赖原则：内部事物对外部一无所知。因此我们让用例定义以及调用接口（interface）也就是图中内圈的 Use Case Output Port，而让外圈的表示器实现这个接口（interface）。 这个技巧可以用在整个架构中所有需要跨越边界的地方。我们利用面向对象编程语言的动态多态性这个特点创建与控制流向相反的源代码依赖。这样不论控制流动的方向是什么我们都能让设计符合依赖原则。 哪些数据会跨越边界一般跨越边界的是简单的数据结构。可以根据自己的需要选择基本数据结构或者简单的数据传输对象或者函数调用时传入的参数，也可以将数据打包进哈稀表或者构建到对象里，关键在于用于跨越边界的数据要足够简单和具备独立性。我们并不希望让实体或数据库的原始数据行跨越边界，同样不希望跨越边界的结构里包含任意会违背依赖原则的数据。 比如，许多数据库框架会用便于使用的数据格式作为查询的响应，我们把这样的数据称为 RowStructure。我们不希望跨越边界时传递这样的结构，这样可能会违背依赖原则因为这有几率迫使内部的代码必须了解外部的数据定义。 因此，我们传递的数据跨越边界时，最常用是便于内层使用的格式。 总结遵循这些简单的规则并不费劲，并且可以省去开发过程中很多麻烦。将整体软件分层并配合依赖原则，你可以创建一个具备极好测试性的系统，这会带来非常多的好处。当系统外部任意部分成为了整体系统的瓶颈，如数据库或者 Web 开发框架，你能只花很小的代价就将其撤换。","categories":[],"tags":[{"name":"Architecture","slug":"Architecture","permalink":"https://blog.mahyang.uk/tags/Architecture/"},{"name":"Software Design","slug":"Software-Design","permalink":"https://blog.mahyang.uk/tags/Software-Design/"}]},{"title":"用 Go 语言控制 GPIO","slug":"用-Go-语言控制-GPIO","date":"2020-03-18T10:28:40.000Z","updated":"2020-03-18T13:25:30.000Z","comments":true,"path":"2020/03/18/用-Go-语言控制-GPIO/","link":"","permalink":"https://blog.mahyang.uk/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/","excerpt":"GPIO 也就是通用输入&#x2F;输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 mmap 系统调用来完成控制的方法。","text":"GPIO 也就是通用输入&#x2F;输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 mmap 系统调用来完成控制的方法。 软硬件环境 CPU: iMX6Q(ARM) Kernel: Linux 4.19.72 OS: Ubuntu18.04 GPIO 控制流程简介iMX6Q 芯片手册上有如下描述: 由此可知读取 GPIO 某一个管脚上的信号分为3个步骤: 配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。 配置管脚方向寄存器，设置此管脚为输入。 从管脚数据寄存器中读取值。 反之，如果要向外输出信号则为以下3步骤: 配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。 配置管脚方向寄存器，设置此管脚为输出。 向管脚数据寄存器写入值。 寄存器地址iMX6Q 有7组 GPIO 每组有8个 32-bit 的寄存器，每个寄存器上 1-bit 控制着其对应的1个管脚的配置，也就是每组 GPIO 有32个管脚，每个管脚有8个配置项。关于 iMX6Q GPIO 更为详细的介绍可参阅 Definitive GPIO guide。 对于只使用输入&#x2F;输出功能的情况，8个寄存器中我们只需关心数据寄存器和方向寄存器这2个（对于管脚复用寄存器，因为默认状态下几乎所有管脚都是 GPIO 模式所以基本不用关心，具体情况请参考芯片手册）。 GPIO 控制寄存器的基地址为 0x0209C000，地址宽度为 0x4000 也就是第一组 GPIO 的控制寄存器在地址 0x0209C000 上，第二组在 0x020A0000，以此类推。每一个寄存器是 32-bit 大小所以，第一组 GPIO 的数据寄存器在 0x0209C000 方向寄存器在 0x0209C004，如下图: 由此可以在代码中做如下定义: gpio_imx6q.go1234const ( gpioBaseAddr uint32 = 0x0209C000 gpioAddrWidth uint32 = 0x4000) 对于指定的某一组 GPIO 的寄存器地址可这样获得: gpio_imx6q.go1234func getGPIOMMapper(group int) ([]uint32, error) &#123; gaddr := gpioBaseAddr + (uint32(group)-1)*gpioAddrWidth // ...&#125; 内存地址转换当程序运行起来后操作系统为每一个进程分配了一个虚拟地址空间，而寄存器的地址在实地址空间中，所以需要使用内存地址转换将实地址映射到虚拟地址空间，这样我们才能通过内存地址访问 GPIO 寄存器。 执行终端命令 man mmap 可查阅关于 mmap 详细的资料，这里我们通过 Go 语言 unix 包中封装的 Mmap 函数来使用 mmap 系统调用，如下: gpio_imx6q.go12345678func getGPIOMMapper(group int) ([]uint32, error) &#123; // ... b, err := unix.Mmap(int(memMapFile.Fd()), int64(gaddr), 8, unix.PROT_READ|unix.PROT_WRITE, unix.MAP_SHARED) if err != nil &#123; return nil, err &#125; // ...&#125; 其中指定映射的地址长度为8字节，原因是这里我们只使用前2个寄存器。memMapFile 可由如下函数获得: gpio_imx6q.go12345func initGPIOMemMap() *os.File &#123; file, err := os.OpenFile(&quot;/dev/mem&quot;, os.O_RDWR, 0600) check(err) return file&#125; 完成地址转换之后 unix.Mmap 函数返回一个 byte 类型的切片，而每个寄存器是 32-bit 宽度，也就是一个寄存器对应 4 个 byte，这样操作起来比较麻烦。为了简化操作可以将 []byte 转换为 []uint32 类型: gpio_imx6q.go1234567func byte2uint32(b []byte) []uint32 &#123; sl := reflect.SliceHeader&#123;&#125; sl.Cap = len(b) / 4 sl.Len = len(b) / 4 sl.Data = uintptr(unsafe.Pointer(&amp;b[0])) return *(*[]uint32)(unsafe.Pointer(&amp;sl))&#125; 通过 GPIO 外设输出或读取值完成以上操作之后，假定得到的内存映射保存在 var mapper []uint32 中。如果我们要设置管脚 10 为输出，并且对外输出高电平，则可通过以下操作完成: gpio_imx6q.go1234// 设置方向寄存器中第 10 bit 为1表示管脚10为输出mapper[1] = mapper[1] | uint32(0x00000001&lt;&lt;10)// 设置数据寄存器中第 10 bit 为1表示管脚10输出高电平mapper[0] = mapper[0] | uint32(0x00000001&lt;&lt;10) 如果我们要设置管脚 10 为输入，并且读取管脚上的电平信息，则可通过以下操作完成: gpio_imx6q.go1234// 设置方向寄存器中第 10 bit 为0表示管脚10为输入mapper[1] = mapper[1] &amp; ^uint32(0x00000001&lt;&lt;10)// 读取数据寄存器中第 10 bit 的值value := mapper[0] &amp; uint32(0x00000001&lt;&lt;10) 总结本文介绍了 GPIO 的基本操作、iMX6Q GPIO 外设寄存器的分布以及 Go 语言中使用内存映射的方法，最后实现了使用 Go 语言对 GPIO 进行控制。对于以上的过程我们可以进一步将其封装成 struct 方便使用，类似如下: gpio_imx6q.go123456789type GPIOPin struct &#123; Group int Pin int mmapper []uint32&#125;func (pin *GPIOPin) SetDir(dir string) &#123;&#125;func (pin *GPIOPin) Direction() string &#123;&#125;func (pin *GPIOPin) Set(v string) &#123;&#125;func (pin *GPIOPin) Read() string &#123;&#125; 除了内存映射之外，还可以使用其他方法操作 GPIO，例如通过 sysfs 文件系统或者使用 /dev/gpiochip 设备文件等，这里就不做过多介绍了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"GPIO","slug":"GPIO","permalink":"https://blog.mahyang.uk/tags/GPIO/"},{"name":"memory map","slug":"memory-map","permalink":"https://blog.mahyang.uk/tags/memory-map/"}]},{"title":"iMX6Q 2GB 内存支持","slug":"iMX6Q-2GB-内存支持","date":"2020-03-16T08:18:41.000Z","updated":"2020-03-16T13:19:28.000Z","comments":true,"path":"2020/03/16/iMX6Q-2GB-内存支持/","link":"","permalink":"https://blog.mahyang.uk/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/","excerpt":"iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。","text":"iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。 系统启动过程现象系统启动过程中可看到 U-Boot 输出如下信息: 终端输出1234567891011U-Boot 2019.10-rc1-00134-gacda5922db-dirty (Mar 16 2020 - 15:27:54 +0800)CPU: Freescale i.MX6Q rev1.6 996 MHz (running at 792 MHz)CPU: Automotive temperature grade (-40C to 125C) at 36CReset cause: PORModel: Freescale i.MX6 Quad SABRE Smart Device BoardBoard: MX6-SabreSDI2C: readyDRAM: 1 GiBPMIC: PFUZE100 ID=0x10MMC: FSL_SDHC: 0, FSL_SDHC: 3 其中 DRAM: 1 GiB 这一行表示 U-Boot 识别到的内存空间大小为 1GB。 进入操作系统之后，终端执行如下命令: 终端输出123ubuntu@arm:~$ cat /proc/meminfoMemTotal: 1031138 kB... 可知操作系统识别到的内存空间大小也是 1GB。 识别内存大小的过程查看 U-Boot 源码，初始化函数 board_init_f 会执行一系列初始化操作: u-boot/common/board_f.c12if (initcall_run_list(init_sequence_f)) hang(); init_sequence_f 是一个数组，所有初始化函数都放在这个数组中，其中有2个函数: imx6q/u-boot/common/board_f.c123456static const init_fnc_t init_sequence_f[] = &#123; // ... announce_dram_init, dram_init, /* configure available RAM banks */ // ...&#125; announce_dram_init 函数只有一行代码作用是输出 DRAM:。真正需要我们关心的是 dram_init，这个函数继续调用了另一个函数 imx_ddr_size，接着往下追发现如下注释信息: u-boot/arch/arm/mach-imx/cpu.c1234567891011/* * imx_ddr_size - return size in bytes of DRAM according MMDC config * The MMDC MDCTL register holds the number of bits for row, col, and data * width and the MMDC MDMISC register holds the number of banks. Combine * all these bits to determine the meme size the MMDC has been configured for */unsigned imx_ddr_size(void)&#123; struct esd_mmdc_regs *mem = (struct esd_mmdc_regs *)MEMCTL_BASE; // ...&#125; 可看到函数 imx_ddr_size 根据 MMDC 的配置返回内存空间大小，配置信息存储在寄存器 MMDC_MDCTL 中。 适配 2GB 内存从前面的代码中可看到寄存器 MMDC_MDCTL 的地址在定义 MEMCTL_BASE 中，接着查看 MEMCTL_BASE 的定义，可得到如下信息: 12345678910111213141516MEMCTL_BASE | vMMDC_P0_BASE_ADDR | vAIPS2_OFF_BASE_ADDR + 0x30000 | vATZ2_BASE_ADDR + 0x80000 + 0x30000 | vAIPS2_ARB_BASE_ADDR + 0x80000 + 0x30000 | v0x02100000 + 0x80000 + 0x30000 = 0x021b0000 所以 MMDC_MDCTL 寄存器地址为 0x021b0000。此处代码是从寄存器中读取配置的值，那么一定会有其他的代码去配置这个寄存器的值，继续查找可发现: u-boot/board/freescale/mx6sabresd/mx6sabresd.c123456static int mx6q_dcd_table[] = &#123; //... 0x021b0040, 0x00000027, 0x021b0000, 0x831A0000, //...&#125; 原始 codebase 中向寄存器 MMDC_MDCTL 配置了值 0x831A0000 以及向寄存器 MMDC_MDASP 配置了值 0x00000027。 接着从 iMX6Q 芯片参考手册中可查到寄存器 MMDC_MDCTL 数据位的分配: 从而得知原始代码中，寄存器 MMDC_MDCTL 配置的含义为： 使能 CS0 关闭 CS1 行地址宽度 14bit 列地址宽度 10bit burst 长度 8 数据总线大小 64bit 我们运行平台上的内存芯片和 iMX6Q SABRESD 开发板上的内存芯片是一样的封装，只是容量是后者的2倍，也就是行地址宽度多了1bit，所以将 MMDC_MDCTL 寄存器的值配置为 0x841A0000。 对于寄存器 MMDC_MDASP，芯片手册中描述如下: MMDCx_MDASP[CS0_END] should be set to DDR_CS_SIZE&#x2F;32MB + 0x7 (DDR base address begins at 0x10000000) Freescalei.MX 6Dual/6Quad Applications Processor Reference Manual 所以寄存器 MMDC_MDASP 的值应该配置为 内存大小/32MB + 0x7 也就是 0x00000047，最后配置如下: u-boot/board/freescale/mx6sabresd/mx6sabresd.c123456static int mx6q_dcd_table[] = &#123; //... 0x021b0040, 0x00000047, 0x021b0000, 0x841A0000, //...&#125; 设备树修改将 U-Boot 以及内核设备树与内存大小相关的地方修改为 2GB: u-boot/arch/arm/dts/imx6qdl-sabresd.dtsi123memory@10000000 &#123; reg = &lt;0x10000000 0x80000000&gt;;&#125;; 最后，将以上修改保存到设备中，启动系统之后可以看到 U-Boot 以及操作系统均识别到 2GB 内存空间。 总结本文介绍了 U-Boot 在启动时识别内存大小的过程，以及 iMX6Q 关于内存信息的几个寄存器的配置，最终实现让系统平台识别并且使用 2GB 内存空间。","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"内存拓展","slug":"内存拓展","permalink":"https://blog.mahyang.uk/tags/%E5%86%85%E5%AD%98%E6%8B%93%E5%B1%95/"}]},{"title":"Linux 系统中 Watchdog 的应用","slug":"Linux-系统中-Watchdog-的应用","date":"2020-02-22T02:08:56.000Z","updated":"2020-02-23T09:43:09.000Z","comments":true,"path":"2020/02/22/Linux-系统中-Watchdog-的应用/","link":"","permalink":"https://blog.mahyang.uk/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"本文将介绍如何在 Linux 系统的用户层使用 Watchdog。","text":"本文将介绍如何在 Linux 系统的用户层使用 Watchdog。 操作环境 硬件环境: iMX6Q SABRE-SD 开发板 操作系统内核: Linux 4.19.72-armv7 操作系统发行版: Ubuntu18.04 开启 Watchdog在编译内核时开启 Watchdog: ./tools/rebuild.sh12# 内核配置选项位置Device Drivers -&gt; Watchdog Timer Support 开启 Disable watchdog shutdown on close 这一项。 内核文档中关于此选项的解释如下: When the device is closed, the watchdog is disabled, unless the “MagicClose” feature is supported (see below). This is not always such a good idea, since if there is a bug in the watchdog daemon and it crashes the system will not reboot. Because of this, some of the drivers support the configuration option “Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT. If it is set to Y when compiling the kernel, there is no way of disabling the watchdog once it has been started. So, if the watchdog daemon crashes, the system will reboot after the timeout has passed. Watchdog devices also usually support the nowayout module parameter so that this option can be controlled at runtime. Magic Close feature: If a driver supports “Magic Close”, the driver will not disable the watchdog unless a specific magic character ‘V’ has been sent to &#x2F;dev&#x2F;watchdog just before closing the file. If the userspace daemon closes the file without sending this special character, the driver will assume that the daemon (and userspace in general) died, and will stop pinging the watchdog without disabling it first. This will then cause a reboot if the watchdog is not re-opened in sufficient time. Christer WeingelThe Linux Watchdog driver API. 简单来说，开启此选项之后一旦我们打开了 Watchdog 设备，只要程序没对此 Watchdog 做文档中指定的操作，那么 Watchdog 就会重启系统。 基本操作操作系统内核会将 CPU 芯片上的 Watchdog 外设抽象为文件系统中的一个字符设备: ubuntu@arm:~$12ls /dev/watchdog*# /dev/watchdog /dev/watchdog0 上面命令列出来系统中的 Watchdog 设备（/dev/watchdog、/dev/watchdog0 在底层指向同一个硬件）。使用其中任一设备都可以。 打开设备 api_watchdog_open1watchdog_fd = open(watchdog_dev, O_RDWR); 根据头文件 linux/watchdog.h 中的定义，我们可以通过得到的文件描述符对 watchdog 设备做后面这些操作。 设置 watchdog 超时时间 api_watchdog_settimeout1ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &amp;seconds); feed watchdog api_watchdog_feed1ioctl(watchdog_fd, WDIOC_KEEPALIVE, NULL); 可以将上面的这些操作封装成函数接口，在函数内部做一些错误处理。 测试main.c1234567891011121314int main(void)&#123; struct timespec wait_time = &#123; 1, 0 &#125;; if (api_watchdog_init(WATCHDOG_DEV, WATCHDOG_TIMEOUT) &lt; 0) return -1; printf(&quot;Watchdog opened!\\n&quot;); while (1) &#123; api_watchdog_feed(); nanosleep(&amp;wait_time, NULL); &#125;&#125; 如上，先初始化 watchdog 然后每秒 feed watchdog 一次，此时系统如常运行。当 kill 此程序后，由于前面在内核开启了 Disable watchdog shutdown on close 选项 watchdog 会继续工作，同时没有继续 feed 的操作所以系统进入重启流程。 引入外部 Kick 信号以一个具体的应用场景为例，如下: 硬件连接123------- GPIO --------| CPU | &lt;------ | FPGA |------- -------- FPGA 通过 CPU 的 GPIO 外设向开发板输入一个周期性翻转信号。CPU 在每一个周期开始时重置 watchdog，我们可以检测 GPIO 的上升沿或者下降沿获得周期开始的信息。 对 GPIO 的操作在 Linux 环境中有很多方法实现，这里我们使用 libgpiod 库来实现对 GPIO 上升沿信号的检测。 libgpiod 中封装了很多便于使用的 API。在当前使用场景中，只需调用函数 gpiod_ctxless_event_monitor 就可实现我们想要的功能，其函数签名以及相应的文档注释如下: 1234567891011121314151617181920212223/** * @brief Wait for events on a single GPIO line. * @param device Name, path, number or label of the gpiochip. * @param event_type Type of events to listen for. * @param offset GPIO line offset to monitor. * @param active_low The active state of this line - true if low. * @param consumer Name of the consumer. * @param timeout Maximum wait time for each iteration. * @param poll_cb Callback function to call when waiting for events. * @param event_cb Callback function to call for each line event. * @param data User data passed to the callback. * @return 0 if no errors were encountered, -1 if an error occurred. * @note The way the ctxless event loop works is described in detail in * ::gpiod_ctxless_event_monitor_multiple - this is just a wrapper aound * this routine which calls it for a single GPIO line. */int gpiod_ctxless_event_monitor(const char *device, int event_type, unsigned int offset, bool active_low, const char *consumer, const struct timespec *timeout, gpiod_ctxless_event_poll_cb poll_cb, gpiod_ctxless_event_handle_cb event_cb, void *data) GPIOD_API; 如上可以看出几个关键参数，通过 device、offset 参数指定使用的 GPIO 管脚，event_type 指定检测事件（如，上升沿事件），event_cb 是触发指定事件后调用的回调函数，其调用方法大致如下: 上升沿检测12345// WDOG_GPIO_SIG_CHIP &quot;/dev/gpiochip6&quot;// WDOG_GPIO_SIG_PORT 7gpiod_ctxless_event_monitor(WDOG_GPIO_SIG_CHIP, GPIOD_CTXLESS_EVENT_RISING_EDGE, WDOG_GPIO_SIG_PORT, false, &quot;wdog&quot;, &amp;timeout, NULL, gpio6_port7_rising_edge_handle_cb, NULL); 接下来只需要再定义回调函数即可，回调函数的函数签名如下: 12345678910111213/** * @brief Simple event callback signature. * * The callback function takes the following arguments: event type (int), * GPIO line offset (unsigned int), event timestamp (const struct timespec *) * and a pointer to user data (void *). * * This callback is called by the ctxless event loop functions for each GPIO * event. If the callback returns ::GPIOD_CTXLESS_EVENT_CB_RET_ERR, it should * also set errno. */typedef int (*gpiod_ctxless_event_handle_cb)(int, unsigned int, const struct timespec *, void *); 所以我们定义的上升沿事件回调函数大致如下: 定义回调函数123456789101112int gpio6_port7_rising_edge_handle_cb(int type, unsigned int offset, const struct timespec *timestamp, void *arg)&#123; wdog_count ++; if (wdog_count &gt;= WDOG_FEED_PERIOD / FPGA_WDOG_SIG_PERIOD) &#123; api_watchdog_feed(); wdog_count = 0; &#125; return GPIOD_CTXLESS_EVENT_CB_RET_OK;&#125; 其中关键在于 api_watchdog_feed()。 以上就实现了外部 Kick 信号的引入。 配置 systemd 服务我们希望 watchdog 程序随着系统自动启动，所以配置如下的 systemd 服务: wdog_fpga.service12345678910[Unit]Description=Watchdog systemd service.ConditionKernelCommandLine=!disable_wdog[Service]Type=simpleExecStart=/usr/bin/wdog_fpga[Install]WantedBy=multi-user.target 其中我们定义了 ConditionKernelCommandLine 参数为 !disable_wdog。这样当系统启动之后 systemd 会检测内核启动命令行参数中是否存在disable_wdog，如果不存在则启动 watchdog，反之依然。这样配置的好处是，我们可以在系统启动之前配置是否开启 watchdog。 U-Boot 环境设置内核命令行参数如果我们不想开启 watchdog，则在 U-Boot 启动后暂停引导内核，然后将 disable_wdog 参数设置到内核命令行参数中，如下: 1setenv bootargs ... 其他参数 ... disable_wdog 然后再引导内核启动: 1run bootcmd 总结文本介绍了如何在 Linux 操作系统中使用 watchdog，分为以下方面的工作: 内核选项配置 部分 API 介绍 设备操作接口封装 实际应用场景示例","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"Watchdog","slug":"Watchdog","permalink":"https://blog.mahyang.uk/tags/Watchdog/"},{"name":"Embedded System","slug":"Embedded-System","permalink":"https://blog.mahyang.uk/tags/Embedded-System/"}]},{"title":"iMX6Q SABRE-SD 开发板软件烧录","slug":"iMX6Q-SABRE-SD-开发板软件烧录","date":"2020-02-19T09:04:39.000Z","updated":"2020-02-20T14:55:42.000Z","comments":true,"path":"2020/02/19/iMX6Q-SABRE-SD-开发板软件烧录/","link":"","permalink":"https://blog.mahyang.uk/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/","excerpt":"本文将介绍 iMX6Q SABRE-SD 开发板的软件烧录流程。","text":"本文将介绍 iMX6Q SABRE-SD 开发板的软件烧录流程。 软件环境 操作系统: Ubuntu14.04 准备工作 使开发板进入工厂模式具体操作请参考此文档。 开发板系统软件制作开发板系统软件请参考此文档。 烧录流程烧录过程中会使用 utp_com 向开发板发送指令，开发板收到指令后执行。 创建分区表 分区脚本 netop@mfgtools:~/utp_com$12345678910111213141516171819cat &lt;&lt;END &gt;/tmp/mkmmc.sh#!/bin/shnode=\\$1# partition size in MBBOOT_ROM_SIZE=10# wait for the SD/MMC device node readywhile [ ! -e \\$&#123;node&#125; ]dosleep 1echo &quot;wait for \\$&#123;node&#125; appear&quot;done# destroy the partition tabledd if=/dev/zero of=\\$&#123;node&#125; bs=1024 count=1# call sfdisk to create partition tablesfdisk --force \\$&#123;node&#125; &lt;&lt;EOF1M,,L,*EOFEND 发送并执行分区脚本 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;send&quot; -f /tmp/mkmmc.sh./utp_com -d /dev/sg1 -c &quot;$ sh \\$FILE /dev/mmcblk3&quot; 建立 U-Boot 分区 boot 分区写使能 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo 0 &gt; /sys/block/mmcblk3boot0/force_ro&quot; 发送 SPL、U-Boot 并写入 netop@mfgtools:~/utp_com$1234./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;SPL 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ dd if=\\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=1&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;U-Boot 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ dd if=\\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=69&quot; boot 分区只读使能 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo 1 &gt; /sys/block/mmcblk3boot0/force_ro&quot; 使能 boot 分区 netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ mmc bootpart enable 1 1 /dev/mmcblk3&quot; 创建系统分区 建立 EXT4 分区 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ while [ ! -e /dev/mmcblk3p1 ]; do sleep 1; echo \\&quot;waiting...\\&quot;; done&quot;./utp_com -d /dev/sg1 -c &quot;$ mkfs.ext4 -L rootfs /dev/mmcblk3p1&quot; 挂载系统分区 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ mkdir -p /mnt/rootfs&quot;./utp_com -d /dev/sg1 -c &quot;$ mount /dev/mmcblk3p1 /mnt/rootfs&quot; 安装操作系统 写入根文件系统 netop@mfgtools:~/utp_com$1234./utp_com -d /dev/sg1 -c &quot;pipe tar -x[文件压缩方式] -C /mnt/rootfs&quot; -f &lt;rootfs 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;frf&quot;./utp_com -d /dev/sg1 -c &quot;$ chown root:root /mnt/rootfs&quot;./utp_com -d /dev/sg1 -c &quot;$ chmod 755 /mnt/rootfs&quot; 设置 uname_r netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo &#x27;uname_r=&lt;内核版本信息&gt;&#x27; &gt;&gt; /mnt/rootfs/boot/uEnv.txt&quot; 写入内核、设备树、内核模块 netop@mfgtools:~/utp_com$1234567./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;kernel 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ cp \\$FILE /mnt/rootfs/boot/vmlinuz-&lt;内核版本信息&gt;&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;dtb 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ mkdir -p /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;./utp_com -d /dev/sg1 -c &quot;$ tar xf \\$FILE -C /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;./utp_com -d /dev/sg1 -c &quot;send&quot; -f &lt;modules 文件路径&gt;./utp_com -d /dev/sg1 -c &quot;$ tar xf \\$FILE -C /mnt/rootfs/&quot; 更新 fstab netop@mfgtools:~/utp_com$1./utp_com -d /dev/sg1 -c &quot;$ echo &#x27;/dev/mmcblk2p1 / auto errors=remount-ro 0 1&#x27; &gt;&gt; /mnt/rootfs/etc/fstab&quot; 同步，取消挂载 netop@mfgtools:~/utp_com$12./utp_com -d /dev/sg1 -c &quot;$ sync&quot;./utp_com -d /dev/sg1 -c &quot;$ umount /mnt/rootfs&quot; 启动开发板将开发板的启动拨码开关拨至 11100110，然后上电启动可看到串口输出: 串口输出12345Ubuntu 18.04.3 LTS arm ttymxc0default username:password is [ubuntu:temppwd]arm login: 总结本文介绍了 iMX6Q SABRE-SD 开发板的软件烧录流程，总结为以下4个步骤: 创建分区表 建立 U-Boot 分区 创建系统分区 安装操作系统","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"}]},{"title":"iMX6Q SABRE-SD 开发板系统软件","slug":"iMX6Q-SABRE-SD-开发板系统软件","date":"2020-02-19T06:34:46.000Z","updated":"2020-02-19T12:38:55.000Z","comments":true,"path":"2020/02/19/iMX6Q-SABRE-SD-开发板系统软件/","link":"","permalink":"https://blog.mahyang.uk/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/","excerpt":"本文将介绍适用于 iMX6Q SABRE-SD 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。","text":"本文将介绍适用于 iMX6Q SABRE-SD 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。 软件环境 操作系统: Ubuntu14.04 ARM 交叉编译工具链 下载 &amp; 解压 netop@mfgtools:~$12wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xztar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz 测试 netop@mfgtools:~$12export CC=`pwd`/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-$&#123;CC&#125;gcc --version 终端输出1234arm-linux-gnueabihf-gcc (Linaro GCC 6.5-2018.12) 6.5.0Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 启动加载器: U-Boot 下载源码 netop@mfgtools:~$123git clone https://github.com/u-boot/u-bootcd u-boot/git checkout v2019.07 -b tmp 打补丁 netop@mfgtools:~/u-boot$12wget -c https://raw.githubusercontent.com/eewiki/u-boot-patches/master/v2019.07-rc4/0001-mx6sabresd-fixes.patchpatch -p1 &lt; 0001-mx6sabresd-fixes.patch 修改代码 用编辑器打开文件 ~/u-boot/include/configs/mx6sabre_common.h，找到如下代码: vi ~/u-boot/include/configs/mx6sabre_common.h123456......#define CONFIG_BOOTCOMMAND \\ &quot;setenv interface mmc;&quot; \\ &quot;setenv mmcdev 0;&quot; \\ &quot;run mmcboot;&quot; \\...... 添加2行代码，结果如下: vi ~/u-boot/include/configs/mx6sabre_common.h12345678......#define CONFIG_BOOTCOMMAND \\ &quot;setenv interface mmc;&quot; \\ &quot;setenv mmcdev 3;&quot; \\ &quot;run mmcboot;&quot; \\ &quot;setenv mmcdev 0;&quot; \\ &quot;run mmcboot;&quot; \\...... 配置 &amp; 编译 netop@mfgtools:~/u-boot$123make ARCH=arm CROSS_COMPILE=$&#123;CC&#125; distcleanmake ARCH=arm CROSS_COMPILE=$&#123;CC&#125; mx6sabresd_defconfigmake ARCH=arm CROSS_COMPILE=$&#123;CC&#125; Linux 内核内核我们采用 4.19 长期支持版。 下载源码 netop@mfgtools:~$123git clone https://github.com/RobertCNelson/armv7-multiplatformcd armv7-multiplatform/git checkout origin/v4.19.x -b tmp 编译 netop@mfgtools:~/armv7-multiplatform$1./build_kernel.sh 根文件系统根文件系统我们采用 Ubuntu18.04 LTS。 下载 netop@mfgtools:~$1wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 验证 netop@mfgtools:~$12sha256sum ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz# 输出信息: b28b356d75153bfb3beb5c96bf8eabe92025cf5e665e1a564b469bc70e5a363b ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 解压 netop@mfgtools:~$1tar xf ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz 总结本文介绍了 iMX6Q SABRE-SD 开发板系统软件的制作。通过这些操作可得到以下文件: 启动加载器, 目录: ~/u-boot/ SPL u-boot.img 内核相关，目录: ~/armv7-multiplatform/deploy 4.19.xx-armv7-xxx.zImage 4.19.xx-armv7-xxx-dtbs.tar.gz 4.19.xx-armv7-xxx-modules.tar.gz 根文件系统，目录: ~/imx6q/ubuntu-18.04.3-minimal-armhf-2020-02-10 armhf-rootfs-ubuntu-bionic.tar","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"U-Boot","slug":"U-Boot","permalink":"https://blog.mahyang.uk/tags/U-Boot/"},{"name":"Linux kernel","slug":"Linux-kernel","permalink":"https://blog.mahyang.uk/tags/Linux-kernel/"}]},{"title":"iMX USB loader & UTP 使用方法介绍","slug":"iMX-USB-loader-UTP-使用方法介绍","date":"2020-02-18T06:04:49.000Z","updated":"2020-02-18T09:59:03.000Z","comments":true,"path":"2020/02/18/iMX-USB-loader-UTP-使用方法介绍/","link":"","permalink":"https://blog.mahyang.uk/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。","text":"本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。 在使用 iMX6Q SabreSD 开发板时，如果我们对 Linux 内核或者根文件系统进行了定制则需要将新的软件部署到开发板。将软件部署到开发板的方法与开发板的启动方式有关，如果我们需要开发板从 eMMC 启动则需要将软件部署到 eMMC 存储器，使用 Freescale 提供的 iMX USB loader 和 UTP 2个工具能帮助我们完成这项工作。 软件环境 操作系统: Ubuntu14.04 开发板设置在操作之前需要将开发板设置到下载模式，iMX6Q SabreSD 的说明文档中提到: Mode Switch download mode(MFGTool mode) (SW6) 00001100 (from 1-8 bit) eMMC (MMC3) boot (SW6) 11100110 (from 1-8 bit) MMC4 (SD2) boot (SW6) 10000010 (from 1-8 bit) MMC2 (SD3) boot (SW6) 01000010 (from 1-8 bit) Freescale – Android User Guide 所以我们将开发板的启动拨码开关拨到如下位置: 将开发板的 USB 接到电脑端，使用 lsusb 命令可看到如下信息: 查看 USB 设备信息1234lsusb# ......# Bus 001 Device 003: ID 15a2:0054 Freescale Semiconductor, Inc. i.MX 6Dual/6Quad SystemOnChip in RecoveryMode# ...... 可看到电脑端成功识别了开发板，记录下 ID 信息: ID: 15a2:0054 在开始后面步骤之前请将开发板串口与电脑端连接，方便通过串口查看调试信息。 iMX USB loader 安装配置 安装 libusb。 install libusb1sudo apt-get install libusb-1.0-0-dev 获取 iMX USB loader 源代码。 git clone1git clone https://github.com/boundarydevices/imx_usb_loader.git 编译 compile12cd imx_usb_loadermake 修改配置文件 查看文件 imx_usb.conf 根据刚刚记录下来的 ID 值找到取对应的开发板配置文件: imx_usb.conf123......0x15a2:0x0054, mx6_usb_work.conf...... 将文件 mx6_usb_work.conf 的内容修改为如下: mx6_usb_work.conf12345678mx6_qsbhid,1024,0x910000,0x10000000,1G,0x00900000,0x40000firmware/u-boot.imx: dcdfirmware/zImage: load 0x12000000firmware/fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot: load 0x12C00000firmware/zImage-imx6q-sabresd.dtb: load 0x18000000firmware/u-boot.imx: clear_dcd,load,plug,jump header 使用 USB loader 创建 firmware 目录: 创建目录1mkdir firmware 将生成的镜像文件拷贝到 firmware 目录中后执行: 运行 imx_usb1./imx_usb 等待半分钟左右，可通过串口看到输出的启动信息: 串口输出信息123456......Starting UTPuuc 0.5 [built Jan 9 2020 12:41:11]UTP: Waiting for device to appearUTP: file/device node /dev/utp already exists...... 此时开发板通过 USB 将自己模拟成一个 sg 设备，在电脑端可以通过以下命令查看此设备: 查看 sg 设备12ls /dev/sg*# /dev/sg0 /dev/sg1 其中 /dev/sg1 就是开发板。通过此设备我们便可用 UTP 工具与开发板通信。 UTP 安装配置 安装 libsgutils2。 install libsgutils21sudo apt-get install libsgutils2-dev 获取 UTP 源代码。 git clone1git clone https://github.com/ixonos/utp_com.git 编译 compile12cd utp_commake 使用 utp_com 与开发板通信 使用 utp_com1./utp_com -d /dev/sg1 -c &quot;$ echo hello, world!&quot; 通过串口可看到开发板的输出信息: 串口输出12345UTP: received command &#x27;$ echo hello, world!&#x27;UTP: executing &quot;echo hello, world!&quot;hello, world!UTP: sending Success to kernel for command $ echo hello, world!.utp_poll: pass returned. 总结至此我们完成了 imx_usb 和 utp_com 的安装配置，使用 imx_usb 向开发板下载固件，以及使用 utp_com 与开发板通信向其发送并执行指令。具体工作如下: 开发板下载模式配置 iMX USB loader 安装配置 UTP com 安装配置","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://blog.mahyang.uk/tags/mfgtool/"},{"name":"imx_usb","slug":"imx-usb","permalink":"https://blog.mahyang.uk/tags/imx-usb/"},{"name":"utp_com","slug":"utp-com","permalink":"https://blog.mahyang.uk/tags/utp-com/"}]},{"title":"搭建 iMX6Q SabreSD Yocto 项目开发环境","slug":"搭建-iMX6Q-SabreSD-Yocto-项目开发环境","date":"2020-02-17T03:03:41.000Z","updated":"2020-02-18T05:50:17.000Z","comments":true,"path":"2020/02/17/搭建-iMX6Q-SabreSD-Yocto-项目开发环境/","link":"","permalink":"https://blog.mahyang.uk/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"本文将介绍 iMX6Q SabreSD 开发板的 Yocto Project 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。","text":"本文将介绍 iMX6Q SabreSD 开发板的 Yocto Project 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。 软件环境 操作系统: Ubuntu14.04 安装依赖包Yocto Project 的依赖包12sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\build-essential chrpath socat 其他依赖包123sudo apt-get install libsdl1.2-dev xterm sed cvs subversion coreutils texi2html \\docbook-utils python-pysqlite2 help2man make gcc g++ desktop-file-utils \\libgl1-mesa-dev libglu1-mesa-dev mercurial autoconf automake groff curl lzop asciidoc u-boot 工具1sudo apt-get install u-boot-tools 安装 repo 工具repo 是一个基于 git 的工具。使用 repo 可以方便地管理存在多个软件源的项目。安装 repo 分为以下几个步骤: 在 home 目录下创建一个 bin 目录。 安装 repo123mkdir ~/bincurl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 将下面2行加入 .bashrc 文件末尾，确保 ~/bin 在 PATH 变量中。 环境变量12export PATH=$&#123;PATH&#125;:~/binexport MACHINE=imx6qsabresd 构建 Yocto 项目Freescale Yocto Project BSP Release 目录包含如下内容: sources 目录包含一些用于构建的配方 一个或多个 build 目录 一些用于配置开发环境的脚本 以下步骤创建了一个 fsl-release-bsp 目录用于构建 Yocto 项目: 创建目录12mkdir fsl-release-bspcd fsl-release-bsp 配置 git 信息12345# git config --global user.name &quot;Your Name&quot;git config --global user.name &quot;ClarenceYk&quot;# git config --global user.email &quot;Your Email&quot;git config --global user.email &quot;xxx@xxx.com&quot;git config --list 同步源代码12repo init -u git://git.freescale.com/imx/fsl-arm-yocto-bsp.git -b imx-4.1.15-1.0.0_garepo sync 上面采用了 imx-4.1.15-1.0.0_ga 分支，可根据实际需求使用其他分支代码，如下: 编译构建 MFGTool向开发板烧录系统镜像可使用 MFGTool 完成。编译 MFGTool 镜像文件的配方分别是 linux-imx-mfgtool 和 u-boot-mfgtool。编译命令如下: 编译 MFGTool123cd ~/fsl-release-bspsource fsl-setup-release.sh -b build-mfgtools -e x11bitbake fsl-image-mfgtool-initramfs 编译过程需下载大量的源代码，为确保过程顺利建议使用 VPN 或者采用其他加速网络访问的方式。 成功编译之后，在目录 ~/fsl-mfgtools-bsp/build-mfgtools/tmp/deploy/images/imx6qsabresd 下会产生如下文件: u-boot.imx（u-boot） zImage（内核） zImage-imx6q-sabresd.dtb（设备树） fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot（内存文件系统） 总结通过以上步骤，我们完成了 Freescale iMX6Q Yocto Project 开发环境搭建，其中包含如下方面的工作: 安装项目依赖软件 安装 repo 配置 git 构建 Yocto 项目 编译 MFGTool 镜像","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://blog.mahyang.uk/tags/mfgtool/"},{"name":"yocto","slug":"yocto","permalink":"https://blog.mahyang.uk/tags/yocto/"}]},{"title":"VirtualBox 安装及配置 Ubuntu14.04 服务器版","slug":"VirtualBox-安装及配置-Ubuntu14-04-服务器版","date":"2020-02-15T08:02:18.000Z","updated":"2020-02-19T02:19:30.000Z","comments":true,"path":"2020/02/15/VirtualBox-安装及配置-Ubuntu14-04-服务器版/","link":"","permalink":"https://blog.mahyang.uk/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/","excerpt":"本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。","text":"本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。 运行环境 操作系统: Windows 10 VirtualBox: 6.0 下载及安装 VirtualBox本文创建时使用的 VirtualBox 版本为 6.0，你可根据自己的需要选择其他或者最新版本。 访问 Oracle VirtualBox 主页。 点击下载按钮，下载安装程序后双击此程序安装 VirtualBox。 此处可一路点击下一步直至安装完成，然后重启计算机。 下载 Ubuntu14.04 服务器版镜像文件 访问 Ubuntu 镜像发布页，点击如下图链接。 在如下页面中找到并下载服务器版本镜像。 创建虚拟机接下来开始创建虚拟机。 点击新建，选项配置如下： 名称: 自定义，如 ubuntu1404-mfgtools 表示此虚拟机操作系统为 ubuntu14.04 用于制作 mfgtools 文件夹: 自定义，此虚拟机相关文件存放位置 类型: Linux 版本: Ubuntu (64-bit) 内存大小: 不影响主机性能的情况下取最大 其他选项如上图，配置完成后点击创建。 创建虚拟磁盘: 文件大小: 根据需求配置 固定或动态大小: 同上 配置完成点击创建。 设置启动镜像 点击设置，选择存储： 依次点击如下所示选项： 然后在弹出的选项中点击选择一个虚拟光盘文件，然后在弹出的选项框中选择之前下载的系统镜像文件。 选择系统，将启动顺序改为如下图般: 配置完成后点击确认。 安装系统 主界面点击启动，进入系统安装界面。 根据提示操作，完成安装后如下图： 选择 Continue 结束安装。关闭窗口。 回到主界面点击设置，选择系统并将启动顺序改为如下图般: 点击 ok 保存设置。 额外的配置完成前面的步骤后一个可用的虚拟机已经创建完成，后面的步骤可以让虚拟机使用起来更方便。 设置端口转发 回到主界面点击设置，选择网络并点击高级选项卡: 点击端口转发之后，添加如下配置: 其中子系统IP填为虚拟机的 IP 地址。 这一步的作用是将虚拟机的 22 端口转发到主机的 2200 端口上，方面我们使用 SSH 连接虚拟机。 安装增强功能 登录虚拟机12# ssh -p &lt;端口&gt; &lt;用户&gt;@&lt;主机地址&gt;ssh -p 2200 test@192.168.1.101 安装依赖软件123sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential 点击如下图所示的安装增强功能: 挂载光盘123sudo mkdir /mnt/cdromsudo mount /dev/cdrom /mnt/cdrom/# mount: block device /dev/sr0 is write-protected, mounting read-only 运行安装程序123cd /mnt/cdrom/sudo ./VBoxLinuxAdditions.runsudo shutdown -h 0 -r 共享文件夹 加入 vboxsf 组12# sudo usermod -a -G vboxsf &lt;用户&gt;sudo usermod -a -G vboxsf test 回到设置，选择共享文件夹并点击如下所示按钮: 如下般设置: 挂载点不用填。 重启虚拟机1sudo shutdown -h 0 -r USB 设备支持 访问 VirtualBox 官网下载拓展包。注意，请找到对应自己版本的拓展包。 回到 VirtualBox 主界面，选择管理-&gt;全局设定-&gt;拓展: 选择刚刚下载的拓展包，安装。 总结以上我们就在虚拟机中安装好了 Ubuntu 操作系统，并做了以下设置: 将虚拟机的22端口转发到主机2200端口。 创建一个共享文件夹用于虚拟机与主机间的文件共享。 安装了拓展包使虚拟机支持 USB2.0 以及 USB3.0 设备。","categories":[],"tags":[{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"开发环境","slug":"开发环境","permalink":"https://blog.mahyang.uk/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}],"categories":[],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://blog.mahyang.uk/tags/WSL/"},{"name":"Kernel Module","slug":"Kernel-Module","permalink":"https://blog.mahyang.uk/tags/Kernel-Module/"},{"name":"面试","slug":"面试","permalink":"https://blog.mahyang.uk/tags/%E9%9D%A2%E8%AF%95/"},{"name":"C","slug":"C","permalink":"https://blog.mahyang.uk/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://blog.mahyang.uk/tags/%E7%AE%97%E6%B3%95/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://blog.mahyang.uk/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://blog.mahyang.uk/tags/OS/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.mahyang.uk/tags/Rust/"},{"name":"Asterisk","slug":"Asterisk","permalink":"https://blog.mahyang.uk/tags/Asterisk/"},{"name":"Cross Compilation","slug":"Cross-Compilation","permalink":"https://blog.mahyang.uk/tags/Cross-Compilation/"},{"name":"操作方法","slug":"操作方法","permalink":"https://blog.mahyang.uk/tags/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"QEMU","slug":"QEMU","permalink":"https://blog.mahyang.uk/tags/QEMU/"},{"name":"ARM64","slug":"ARM64","permalink":"https://blog.mahyang.uk/tags/ARM64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.mahyang.uk/tags/Ubuntu/"},{"name":"LXD","slug":"LXD","permalink":"https://blog.mahyang.uk/tags/LXD/"},{"name":"VoIP","slug":"VoIP","permalink":"https://blog.mahyang.uk/tags/VoIP/"},{"name":"FreePBX","slug":"FreePBX","permalink":"https://blog.mahyang.uk/tags/FreePBX/"},{"name":"systemd-nspawn","slug":"systemd-nspawn","permalink":"https://blog.mahyang.uk/tags/systemd-nspawn/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.mahyang.uk/tags/Linux/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://blog.mahyang.uk/tags/Operating-System/"},{"name":"Context Switch","slug":"Context-Switch","permalink":"https://blog.mahyang.uk/tags/Context-Switch/"},{"name":"rsync","slug":"rsync","permalink":"https://blog.mahyang.uk/tags/rsync/"},{"name":"clone file system","slug":"clone-file-system","permalink":"https://blog.mahyang.uk/tags/clone-file-system/"},{"name":"Architecture","slug":"Architecture","permalink":"https://blog.mahyang.uk/tags/Architecture/"},{"name":"Software Design","slug":"Software-Design","permalink":"https://blog.mahyang.uk/tags/Software-Design/"},{"name":"GPIO","slug":"GPIO","permalink":"https://blog.mahyang.uk/tags/GPIO/"},{"name":"memory map","slug":"memory-map","permalink":"https://blog.mahyang.uk/tags/memory-map/"},{"name":"iMX6Q","slug":"iMX6Q","permalink":"https://blog.mahyang.uk/tags/iMX6Q/"},{"name":"内存拓展","slug":"内存拓展","permalink":"https://blog.mahyang.uk/tags/%E5%86%85%E5%AD%98%E6%8B%93%E5%B1%95/"},{"name":"Watchdog","slug":"Watchdog","permalink":"https://blog.mahyang.uk/tags/Watchdog/"},{"name":"Embedded System","slug":"Embedded-System","permalink":"https://blog.mahyang.uk/tags/Embedded-System/"},{"name":"U-Boot","slug":"U-Boot","permalink":"https://blog.mahyang.uk/tags/U-Boot/"},{"name":"Linux kernel","slug":"Linux-kernel","permalink":"https://blog.mahyang.uk/tags/Linux-kernel/"},{"name":"mfgtool","slug":"mfgtool","permalink":"https://blog.mahyang.uk/tags/mfgtool/"},{"name":"imx_usb","slug":"imx-usb","permalink":"https://blog.mahyang.uk/tags/imx-usb/"},{"name":"utp_com","slug":"utp-com","permalink":"https://blog.mahyang.uk/tags/utp-com/"},{"name":"yocto","slug":"yocto","permalink":"https://blog.mahyang.uk/tags/yocto/"},{"name":"开发环境","slug":"开发环境","permalink":"https://blog.mahyang.uk/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}