<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用 LXD 容器化 VoIP 服务</title>
      <link href="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/"/>
      <url>/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/</url>
      
        <content type="html"><![CDATA[<img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/top_pic.jpg" class="" title="top_pic" alt="top_pic"><p>将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。</p><a id="more"></a><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>如果你的 VoIP 服务开发环境、测试环境和生产环境在同一台物理机上，也许不会察觉到环境搭建的繁琐以及消耗在配置环境上的时间。让我们来设想这样一个场景：客户指定使用某一个 Linux 发行版安装 Asterisk（或者配合 FreePBX）开发一套存在特定需求的 VoIP 服务，基于这个前提你拿到一台新的设备开始工作：</p><ol><li>首先安装配置某个指定 Linux 发行版（花费1、2个小时）；</li><li>接着编译、安装、配置 Asterisk（1个小时）；</li><li>然后安装配置 FreePBX（花费2小时解决无数个问题）；</li><li>最后完成测试（花费1小时）。</li></ol><p>终于在5、6个小时后你搭建好了开发环境，接着发现还有测试环境和生产环境需要搭建，于是你再花上2倍于之前的时间完成了环境搭建工作。总算可以开始开发了，你开始实现某一项功能，为了完成这项功能可能：</p><ol><li>需要变动 Asterisk 的配置；</li><li>需要变动 FreePBX 的接口；</li><li>系统某些环境变量、配置参数需要改动。</li></ol><p>于是你将这些变动都同步执行到测试和生产环境以保证各平台的环境一致，这将耗费开发人员大量的时间。同时，一个项目中面临几十上百项功能的开发需求，很快你就会发现因为环境配置失步导致的开发流程失控，比如开发环境能实现的功能在测试环境失效，在生产环境出现的问题在开发环境无法复现。</p><p>问题总结：</p><ol><li>开发人员在搭建环境和保证各平台环境配置同步的过程中耗费大量时间；</li><li>手动操作进行配置同步难免会出错，出现运行环境失控的情况。</li></ol><p>为了解决这2方面问题，我们可以将服务程序及其所依赖的环境打包进容器中使得整套环境容器化，然后在各个平台分发此容器以保证环境的一致性。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>本次测试的环境是 <code>Debian 10</code>，以下分4个步骤完成 VoIP 服务容器化：</p><ol><li>安装并配置 LXD；</li><li>制作根文件系统，其中安装了 Asterisk 以及 FreePBX；</li><li>将此根文件系统打包作为基础镜像导入 LXD；</li><li>从 LXD 中的基础镜像启动一个实例，并配置网络。</li></ol><h3 id="安装并配置-LXD"><a href="#安装并配置-LXD" class="headerlink" title="安装并配置 LXD"></a>安装并配置 LXD</h3><p>LXD 是一下代开源系统容器、虚拟机管理器。关于 LXD 更为详细的介绍请参考<a href="https://linuxcontainers.org/lxd/docs/master/index">官方文档</a>。</p><p>使用 <code>snap</code> 安装 LXD，如果系统没有 snap 先安装 snap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install snap</span><br><span class="line">sudo snap install core</span><br></pre></td></tr></table></figure><p>安装 <code>LXD</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install lxd</span><br></pre></td></tr></table></figure><p>将用户添加到 lxd 组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G lxd $YOUR_USERNAME</span><br></pre></td></tr></table></figure><h4 id="配置-LXD"><a href="#配置-LXD" class="headerlink" title="配置 LXD"></a>配置 LXD</h4><p>一般情况下直接在命令行中输入 <code>lxd init</code> 然后全部选择都使用默认选项即可。这里我希望使用自定义的存储设备作为 lxd 的 <code>storage pool</code>。</p><p>首先创建一个大小合适的空文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/lxd_storage</span><br><span class="line">dd if=/dev/zero of=$HOME/lxd_storage/disk bs=1M count=51200 # 50G</span><br></pre></td></tr></table></figure><p>创建新的 <code>loop device</code> 并将刚刚创建的空文件关联到此设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">losetup /dev/loop14 $HOME/lxd_storage/disk # 先查看 /dev 目录下是否已有 loop14，有则换一个如：loop15</span><br><span class="line">sudo reboot # 重启生效配置</span><br></pre></td></tr></table></figure><p>初始化 lxd 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uklar@debian:~# lxd init</span><br><span class="line">Would you like to use LXD clustering? (yes/no) [default=no]:</span><br><span class="line">Do you want to configure a new storage pool? (yes/no) [default=yes]:</span><br><span class="line">Name of the new storage pool [default=default]:</span><br><span class="line">Name of the storage backend to use (btrfs, dir) [default=btrfs]:</span><br><span class="line">Would you like to create a new btrfs subvolume under /var/lib/lxd? (yes/no) [default=yes]: no</span><br><span class="line">Create a new BTRFS pool? (yes/no) [default=yes]:</span><br><span class="line">Would you like to use an existing block device? (yes/no) [default=no]: yes</span><br><span class="line">Path to the existing block device: /dev/loop14</span><br><span class="line">Would you like to connect to a MAAS server? (yes/no) [default=no]:</span><br><span class="line">Would you like to create a new local network bridge? (yes/no) [default=yes]:</span><br><span class="line">What should the new bridge be called? [default=lxdbr0]:</span><br><span class="line">What IPv4 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:</span><br><span class="line">What IPv6 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]: none</span><br><span class="line">Would you like LXD to be available over the network? (yes/no) [default=no]:</span><br><span class="line">Would you like stale cached images to be updated automatically? (yes/no) [default=yes] no</span><br><span class="line">Would you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]:</span><br></pre></td></tr></table></figure><h3 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h3><p>这里使用 <code>debootstrap</code> 获取 debian 的根文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install debootstrap</span><br><span class="line">mkdir /tmp/debian</span><br><span class="line">sudo debootstrap buster /tmp/debian</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/debootstrap.png" class="" title="debootstrap" alt="debootstrap"><p>使用 <code>systemd-nspawn</code> 以 <code>chroot</code> 模式切换到 <code>/tmp/debian</code> 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install systemd-container # 此软件包中包含了 systemd-nspawn</span><br><span class="line">sudo systemd-container -D /tmp/debian</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/systemd-nspawn.png" class="" title="systemd-nspawn" alt="systemd-nspawn"><p>做一些基本配置，如设置 root 用户密码、添加普通用户以及配置网络等，然后退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br><span class="line"></span><br><span class="line">useradd -m $USERNAME</span><br><span class="line">passwd $USERNAME</span><br><span class="line"></span><br><span class="line">apt install sudo</span><br><span class="line">usermod -a -G sudo $USERNAME</span><br><span class="line">usermod --shell /bin/bash $USERNAME</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/network/interfaces</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The eth0 network interface</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>接着使用 <code>systemd-nspawn</code> 的容器模式启动 <code>/tmp/debian</code> 以 root 身份登陆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemd-nspawn -D /tmp/debian --boot</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/systemd-nspawn-login-root.png" class="" title="systemd-nspawn-login-root" alt="systemd-nspawn-login-root"><p>在容器中安装 Asterisk 以及 FreePBX，过程请参考：</p><ul><li><a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">Asterisk 安装脚本</a></li><li><a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">FreePBX 安装脚本</a></li></ul><p>配置 hostname：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install dbus</span><br><span class="line">hostnamectl set-hostname debian.voip.net</span><br><span class="line">echo &#x27;127.0.0.1 debian.voip.net&#x27; &gt;&gt;/etc/hosts</span><br></pre></td></tr></table></figure><p>访问服务器 Web 页面验证容器中的 VoIP 服务是否正常运行：</p><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/container-freepbx.png" class="" title="container-freepbx" alt="container-freepbx"><p>从 <code>systemd-nspawn</code> 容器中退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown now</span><br></pre></td></tr></table></figure><h3 id="创建-LXD-镜像"><a href="#创建-LXD-镜像" class="headerlink" title="创建 LXD 镜像"></a>创建 LXD 镜像</h3><p>将刚刚配置完成的根文件系统打包并压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/container/images/voip_base</span><br><span class="line">cd ~/container/images/voip_base</span><br><span class="line">sudo tar czf voip_base.tar.gz -C /tmp/debian .</span><br></pre></td></tr></table></figure><p>为镜像创建 metadata 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;./metadata.yaml</span><br><span class="line">architecture: &quot;x86_64&quot;</span><br><span class="line">creation_date: $(date +%s)</span><br><span class="line">properties:</span><br><span class="line">  architecture: &quot;x86_64&quot;</span><br><span class="line">  description: &quot;Debian(buster) with preinstalled Asterisk13&amp;FreePBX15 ($(date +%Y%m%d))&quot;</span><br><span class="line">  os: &quot;debian&quot;</span><br><span class="line">  release: &quot;buster&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">tar czf metadata.tar.gz metadata.yaml</span><br></pre></td></tr></table></figure><p>将压缩包作为镜像导入 LXD：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc image import \</span><br><span class="line">~/container/images/voip_base/metadata.tar.gz \</span><br><span class="line">~/container/images/voip_base/voip_base.tar.gz \</span><br><span class="line">--alias voip-base</span><br></pre></td></tr></table></figure><p>查看镜像是否成功导入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image list</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/lxc-image-list.png" class="" title="lxc-image-list" alt="lxc-image-list"><h3 id="从镜像启动实例"><a href="#从镜像启动实例" class="headerlink" title="从镜像启动实例"></a>从镜像启动实例</h3><p>有了基础镜像之后，启动一个新的 VoIP 服务实例只需一行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc launch voip-base test</span><br></pre></td></tr></table></figure><p>查看实例运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc list</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/lxc-instance-list.png" class="" title="lxc-instance-list" alt="lxc-instance-list"><p>可以看到 VoIP 服务实例（名字为 test）正在运行，分配的内部 IP 地址是 <code>10.72.18.48</code>。</p><p>可用以下命令登陆到实例中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc exec test bash</span><br></pre></td></tr></table></figure><p>查看各类服务使用的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i -P -n</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/listen-ports.png" class="" title="listen-ports" alt="listen-ports"><h3 id="宿主机网络配置"><a href="#宿主机网络配置" class="headerlink" title="宿主机网络配置"></a>宿主机网络配置</h3><p>让宿主机（IP 为 <code>192.168.0.107</code>）所在网络（<code>192.168.0.0/24</code>）的其他设备能够访问 VoIP 服务（IP 为 <code>10.72.18.48</code>），需要在宿主机上配置网络地址转换（NAT）：</p><ul><li>发送到宿主机 <code>5060</code> 端口的 UDP 包（PJSIP）转发到容器实例</li><li>发送到宿主机 <code>5160</code> 端口的 UDP 包（SIP）转发到容器实例</li><li>发送到宿主机 <code>10000 - 20000</code> 端口的 UDP 包（语音）转发到容器实例</li><li>发送到宿主机 <code>80</code> 端口的 TCP 包（Web 管理服务）转发到容器实例</li></ul><p>以上配置可根据实际需求更改。</p><p>这里使用 <code>iptables</code> 来完成，使用 <code>exit</code> 从实例退出返回宿主机，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5060 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5160 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 10000:20000 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p tcp --dport 80 -j DNAT --to 10.72.18.48</span><br></pre></td></tr></table></figure><p>查看 NAT 配置状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -v -L PREROUTING -n</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/iptables-nat.png" class="" title="listen-ports" alt="iptables-nat"><p>现在即可通过宿主机的 IP 访问宿主机上容器化的 VoIP 服务了。</p><h3 id="Asterisk-网络配置"><a href="#Asterisk-网络配置" class="headerlink" title="Asterisk 网络配置"></a>Asterisk 网络配置</h3><p>配置 Asterisk 的 SIP 参数：</p><ul><li><code>externip</code> 为 <code>192.168.0.107</code></li><li><code>localnet</code> 为 <code>10.72.18.0/24</code></li></ul><p>这样 VoIP 服务才能向 SIP 终端正确地发送 <code>contact</code> 参数，否则终端与服务器的 SIP 协议交互会出错。</p><p>直接使用 FreePBX 完成配置（Settings -&gt; Asterisk SIP Settings）：</p><img src="/blog/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/asterisk-sip-settings.png" class="" title="asterisk-sip-settings" alt="asterisk-sip-settings"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了如何将 VoIP 服务容器化，涉及的内容包括 LXD 的使用、systemd-nspawn 的使用、根文件系统制作、容器镜像制作以及和 VoIP 服务相关的网络配置。通过容器化的操作能让各平台的运行环境保持一致，减少开发人员不必要的时间损耗。至于选择 LXD 作为实现容器化的平台原因有2：</p><ol><li>VoIP 服务软件组成复杂，部署在一个带根文件系统的容器中更为方便；</li><li>LXD 的实现性能较好，关于业界几种容器化工具的性能对比分析请参考论文 <a href="http://www.beei.org/index.php/EEI/article/viewFile/1953/1596">Performance analysis of multi services on container Docker, LXC, and LXD</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LXD </tag>
            
            <tag> VoIP </tag>
            
            <tag> Asterisk </tag>
            
            <tag> FreePBX </tag>
            
            <tag> systemd-nspawn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OSTEP 练习题】测量操作系统切换上下文的耗时</title>
      <link href="/blog/2020/07/11/ostep-measure-cost-of-context-switch/"/>
      <url>/blog/2020/07/11/ostep-measure-cost-of-context-switch/</url>
      
        <content type="html"><![CDATA[<img src="/blog/2020/07/11/ostep-measure-cost-of-context-switch/measure_cost_of_context_switch.svg" class="" title="measure_ctx_switch" alt="measure_ctx_switch"><p>尝试解答 <code>OSTEP</code> <sup><a href="#%E6%B3%A8%E9%87%8A">1</a></sup> 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。</p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>使用的测试平台 CPU 是 Intel i5-6200U，主频 2.3GHz，操作系统是 Arch Linux，内核版本 5.7.7。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>为了尽量准确地测量进程上下文切换耗时，需要有如下几个前提：</p><ol><li>创建 2 个测试进程；</li><li>保证这 2 个进程运行在同一个 CPU 核上（鉴于目前的计算平台一般为多核 CPU）；</li><li>保证正在运行这 2 个测试进程的 CPU 核上没有运行其他用户进程；</li><li>尽量使操作系统在指定时刻执行进程调度（与此同时执行上下文切换）。</li></ol><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>使用 <code>fork</code> 系统调用创建子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// error handling</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// child process</span></span><br><span class="line">    <span class="comment">// do something in child process</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCESS);</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// parent process</span></span><br><span class="line">    <span class="comment">// do something in parent process</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sched-setaffinity"><a href="#sched-setaffinity" class="headerlink" title="sched_setaffinity"></a>sched_setaffinity</h3><p>使用 <code>sched_setaffinity</code> 指定进程运行在 <code>CPU3</code> 这个核心上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(CPU_NUM, &amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set successfully</span></span><br><span class="line"><span class="comment">// do other things</span></span><br></pre></td></tr></table></figure><p>此操作只需在父进程 fork 子进程之前执行即可，子进程默认情况下会和父进程运行在同一个 CPU 核上。</p><h3 id="内核启动参数"><a href="#内核启动参数" class="headerlink" title="内核启动参数"></a>内核启动参数</h3><p>为了保证指定的 CPU 核上只有用于测试的 2 个用户进程，需要设置 <code>isolcpus</code> 这个启动参数给内核。此参数告诉内核在调度其余用户进程时排除指定的 CPU 核心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br><span class="line"><span class="comment"># BOOT_IMAGE=... isolcpus=3 ...</span></span><br></pre></td></tr></table></figure><p>重新启动计算机，在进入 GRUB 启动界面时选择启动项并按下 <code>e</code>，进入启动项编辑界面，找到 <code>linux</code> 为开头的一行在行尾添加如下启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioslcpus=3 <span class="comment"># 3 代表测试平台中 CPU 的一个核的编号</span></span><br></pre></td></tr></table></figure><p>查看设备 CPU 核心数可在进入系统后命令行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>设置完后可以用 <code>stress</code> 命令测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S stress</span><br><span class="line">stress --cpu 8</span><br></pre></td></tr></table></figure><p>从下图可以看出内核在调度用户进程时绕开了 <code>CPU3</code>（从 0 开始计数）。</p><img src="/blog/2020/07/11/ostep-measure-cost-of-context-switch/stress_cpu.png" class="" title="stress_cpu" alt="stress_cpu"><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>以上几个步骤保证了在 <code>CPU3</code> 核心上只有用于测试的 2 个用户进程，接下来只需要让内核来回切换（调度）这 2 个测试进程即可。</p><p>使用的方法是：创建 2 个 <code>pipe</code>，子进程向 <code>pipe0</code> 写入一个字符然后从 <code>pipe1</code> 读取一个字符，父进程从 <code>pipe0</code> 读取一个字符然后将读取到的字符写入 <code>pipe1</code>，这样重复 N/2 次。当子进程在“等待”读取时内核就执行调度切换到父进程，当父进程在“等待”读取时内核执行调度切换到子进程，所以测试进程一次“读写”完成后内核执行了 2 次上下文切换，既总共完成了 N 次切换。更加直观的过程如<a href="#top">题图</a>所示。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在我的平台<sup><a href="#%E6%B3%A8%E9%87%8A">2</a></sup> 上的测试结果为：操作系统上下文切换平均耗时 3.42 微秒。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><script src="//gist.github.com/75ddfa9545480b9a44d329a5bf8c22f1.js?file=measure_cost_of_ctx.c"></script><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><sub>[1] Operating System: Three Easy Pieces - ARPACI-DUSSEAU</sub><br><sub>[2] Intel i5-6200U @ 2.3GHz, Arch Linux, Kernel 5.7.7</sub></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Operating System </tag>
            
            <tag> Context Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复刻 Linux 操作系统到另一台设备</title>
      <link href="/blog/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/"/>
      <url>/blog/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://rsync.samba.org/">rsync</a> 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 <code>rsync</code> 作为核心工具来介绍如何复刻 Linux 操作系统。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要注意的是源设备和目标设备之间的 CPU 架构需<strong>保持一致</strong>。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ol><li>一台被复刻的设备作为源设备（参考<a href="/blog/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">搭建 IPPBX 基础开发环境</a>）</li><li>一台新设备作为目标设备</li><li>一个 Linux USB 启动盘（制作方法网络上很多这里不多作介绍，我制作的是 <code>Debian10</code> USB 启动盘）</li></ol><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ol><li>rsync</li><li>openssh-server（可选）</li></ol><h2 id="配置源设备"><a href="#配置源设备" class="headerlink" title="配置源设备"></a>配置源设备</h2><p>在<a href="/blog/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">搭建 IPPBX 基础开发环境</a>一文中我们已经搭建好了一个开发环境，其中的 <code>/dev/sdb2</code> 设备里包含了一个完整的用于生产环境的操作系统。现在我们将 <code>/dev/sdb2</code> 用作拷贝源。</p><h3 id="源设备网络"><a href="#源设备网络" class="headerlink" title="源设备网络"></a>源设备网络</h3><p>简单的方法是将源设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和目标设备直接连接的方式，则需要自己配置静态 IP 地址。</p><h3 id="挂载-dev-sdb2"><a href="#挂载-dev-sdb2" class="headerlink" title="挂载 /dev/sdb2"></a>挂载 <code>/dev/sdb2</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /mnt/debian_10</span><br><span class="line">sudo mount /dev/sdb2 /mnt/debian_10</span><br></pre></td></tr></table></figure><h3 id="安装-amp-配置-rsync"><a href="#安装-amp-配置-rsync" class="headerlink" title="安装&amp;配置 rsync"></a>安装&amp;配置 rsync</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">enter your passwd:</span><br><span class="line"></span><br><span class="line">apt install rsync</span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /etc/rsyncd.conf</span></span><br><span class="line"><span class="string">uid = root</span></span><br><span class="line"><span class="string">gid = root</span></span><br><span class="line"><span class="string">use chroot = no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[all]</span></span><br><span class="line"><span class="string">    path = /</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">rsync --daemon</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="配置目标设备"><a href="#配置目标设备" class="headerlink" title="配置目标设备"></a>配置目标设备</h2><p>将目标设备从 USB 启动盘启动，然后将<a href="#%E8%BD%AF%E4%BB%B6">必备的软件</a>安装好。</p><h3 id="目标设备网络"><a href="#目标设备网络" class="headerlink" title="目标设备网络"></a>目标设备网络</h3><p>简单的方法是将目标设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和源设备直接连接的方式，则需要自己配置静态 IP 地址。</p><h2 id="使用-rsync-复刻系统"><a href="#使用-rsync-复刻系统" class="headerlink" title="使用 rsync 复刻系统"></a>使用 rsync 复刻系统</h2><p>使用 <code>rsync</code> 将源设备上 Linux 系统复刻到目标设备上的方法有两种：</p><ol><li>使用<a href="https://gist.github.com/ClarenceYk/d79d486097350a48ff653ccd028064c8">脚本</a>操作</li><li>手动操作</li></ol><p>推荐使用脚本，用 root 用户执行脚本之后根据提示信息操作即可。如果需要手动操作，则接着往下看（后面的操作均使用 root 用户执行）。</p><h3 id="对目标硬盘分区"><a href="#对目标硬盘分区" class="headerlink" title="对目标硬盘分区"></a>对目标硬盘分区</h3><p>首先查看一下分区信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 119.2G  0 disk</span><br><span class="line">├─sda1   8:1    0     4G  0 part</span><br><span class="line">└─sda2   8:2    0 115.2G  0 part</span><br><span class="line">sdb      8:16   1  14.3G  0 disk</span><br><span class="line">└─sdb1   8:17   1  14.3G  0 part /</span><br></pre></td></tr></table></figure><p>其中 <code>sdb</code> 是 USB 启动盘 <code>sda</code> 是目标设备上的硬盘。对 <code>sda</code> 分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1024 count=1</span><br><span class="line">sfdisk --force /dev/sda &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">1M,4G,S,</span></span><br><span class="line"><span class="string">,,L,*</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">mkswap /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure><p>这里我们将 <code>sda</code> 划了2个分区，第一个是4G的交换分区，剩余的空间划分为系统分区并格式化为 <code>ext4</code> 文件系统（分区方式需和源设备保持一致）。</p><h3 id="从源设备同步文件"><a href="#从源设备同步文件" class="headerlink" title="从源设备同步文件"></a>从源设备同步文件</h3><p>首先将刚刚创建好的系统分区挂载到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/rsync_tmp</span><br><span class="line">mount /dev/sda2 /mnt/rsync_tmp</span><br></pre></td></tr></table></figure><p>检查一下与源设备的连通性（假定源设备的 IP 地址是 <code>192.168.198.140</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 192.168.198.140</span><br></pre></td></tr></table></figure><p>开始同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avHX 192.168.198.140::all/mnt/debian_10/ /mnt/rsync_tmp/</span><br></pre></td></tr></table></figure><p>注意：路径结尾处的 <code>/</code> 必须有。</p><h3 id="重新安装-GRUB-启动器"><a href="#重新安装-GRUB-启动器" class="headerlink" title="重新安装 GRUB 启动器"></a>重新安装 GRUB 启动器</h3><p>从源设备同步完成之后，目标设备上的 GRUB 启动器以及其配置都未更新，所以需要更新。</p><p>首先获取2个分区的 <code>UUID</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ blkid /dev/sda1</span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;XXXX&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> PARTUUID=<span class="string">&quot;XXX&quot;</span></span><br><span class="line">$ blkid /dev/sda2</span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;XXXX&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure><p>将对应分区的 <code>UUID</code> 更新到 <code>/mnt/rsync_tmp/etc/fstab</code> 文件中后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> /proc /mnt/rsync_tmp/proc</span><br><span class="line">mount --<span class="built_in">bind</span> /sys /mnt/rsync_tmp/sys</span><br><span class="line">mount --<span class="built_in">bind</span> /dev /mnt/rsync_tmp/dev</span><br><span class="line">mount --<span class="built_in">bind</span> /run /mnt/rsync_tmp/run</span><br><span class="line">chroot /mnt/rsync_tmp</span><br></pre></td></tr></table></figure><p>进入到 <code>chroot</code> 环境后，更新 GRUB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure><h3 id="重启设备"><a href="#重启设备" class="headerlink" title="重启设备"></a>重启设备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>进入 BIOS 中将启动设备设置为硬盘后启动，即可进入完成复刻的 Linux 系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> rsync </tag>
            
            <tag> clone file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 IPPBX 基础开发环境</title>
      <link href="/blog/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/blog/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>整个开发环境里有如下设备：</p><ol><li>一台开发机，包含2块硬盘</li><li>N 台目标设备（最终业务运行在这些设备上）</li></ol><p>实际的开发场景应该是：开发机随时运行着，其运行状态为：2块硬盘各有一个 Linux 操作系统，其中一个为主系统另一个以类似容器的形式运行在主系统中。主系统中只安装各类开发工具，不运行任何与项目业务相关的服务，所有和项目业务相关的服务都运行在“容器<sup><a href="#%E6%B3%A8%E9%87%8A">1</a></sup>”中。开发人员通过 SSH 远程登陆到主系统中完成开发，或者本地开发完成后将软件服务同步到主系统，维护人员再将新的内容同步到“容器”中。</p><p>实际的系统部署场景应该是：当需要将系统部署到新设备上时，维护人员只需将开发机上2块硬盘中存放“容器”的那块硬盘中的数据“拷贝<sup><a href="#%E6%B3%A8%E9%87%8A">2</a></sup>”到新设备的硬盘中即可。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在着手搭建环境之前需要了解清楚开发环境搭建针对的目标，本例中的目标很简单只有如下2个：</p><ol><li>便于开发工作的进行。</li><li>能方便地将完成了开发工作的系统部署到新设备上。</li></ol><h2 id="拆分需求"><a href="#拆分需求" class="headerlink" title="拆分需求"></a>拆分需求</h2><p>结合前面<code>需求</code>和<code>目标</code>可得到如下细分的功能：</p><ol><li>开发机上需要在其中一块硬盘中安装并运行一个 Linux 操作系统。</li><li>开发机上的另一块硬盘安装一个 Linux 操作系统，此系统能脱离主系统独立运行，同时又能作为“容器”运行在主系统之中。</li><li>需要一个同步方法，能将“容器”同步到新设备的硬盘中。</li></ol><h2 id="选择操作系统及软件工具"><a href="#选择操作系统及软件工具" class="headerlink" title="选择操作系统及软件工具"></a>选择操作系统及软件工具</h2><p>对于开发机的主操作系统这部分没有严格的要求，选择一个适合自己使用习惯的较新的 Linux 发行版即可，这里作为演示我选择的是 <code>Ubuntu20.04</code>。</p><p>容器中运行的操作系统，同时也是最终设备中运行的操作系统，这部分对系统的稳定性以及很多软件的兼容性要求更高一些，所以我们选择 <code>Debian10</code>。</p><p>对于“容器化”的部分，目前有很多容器化技术，如功能非常少但使用非常简单的 <code>chroot</code>（甚至不能作为容器技术🙈）；又如功能非常强大但使用起来有一定门槛的 <code>docker</code>、<code>podman</code> 或者 Ubuntu 推出的 <code>LXC</code> 等；还有介于前面两种之间的 <code>systemd-nspawn</code>。鉴于本例中的使用场景，我们选择 <code>systemd-nspawn</code>，因为其不仅能在我们的<a href="#%E9%9C%80%E6%B1%82">需求</a>范围内很好地隔离主系统与“容器”而且使用方法相对简单。</p><p>对于“同步”这部分，我们选择 <code>rsync</code>，这是一个基于增量传输的文件同步软件，既可用通过单机本地同步也可通过网络同步，能满足我们开发环境中的同步需求。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="主系统"><a href="#主系统" class="headerlink" title="主系统"></a>主系统</h3><p>主操作系统我们选用的是 <code>Ubuntu20.04</code> 安装方法网络上很多，搜索一下即可，这里不再介绍。</p><h3 id="容器中的系统"><a href="#容器中的系统" class="headerlink" title="容器中的系统"></a>容器中的系统</h3><p>本例中我们采用的是 <code>Debian10</code>，安装方法同上。值得注意的是，此系统需安装到开发机的另一块硬盘上，同时在安装前可先取下安装了主系统的硬盘，这样主系统的启动条目就不会出现在“容器”的 grub 启动选项中。此外，分区方式推荐如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdb      8:16   0 232.9G  0 disk</span><br><span class="line">├─sdb1   8:17   0    16G  0 part [SWAP]</span><br><span class="line">└─sdb2   8:18   0 216.8G  0 part</span><br></pre></td></tr></table></figure><p>其中交换分区根据自己的实际需求划分，剩下的空间全部作为 <code>/</code> 分区。</p><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>在主系统中安装软件包 <code>systemd-contianer</code>（此中软件包中包含 <code>systemd-nspawn</code> 工具）以及安装同步工具 <code>rsync</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install systemd-contianer</span><br><span class="line">sudo apt install rsync</span><br></pre></td></tr></table></figure><p><em>注：关于使用 <code>rsync</code> 来同步容器到新设备的方法放在<a href="/blog/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87">另一篇文章</a>中阐述。</em></p><h2 id="运行“容器”"><a href="#运行“容器”" class="headerlink" title="运行“容器”"></a>运行“容器”</h2><p>将2块装好了操作系统的硬盘都接到主板上，然后启动开发机进入 <code>BIOS</code> 将装有 Ubuntu20.04 操作系统的硬盘设置到启动序列的第一位。进入主系统后，查看硬盘分区，大致如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line">sda      8:0    0 931.5G  0 disk</span><br><span class="line">├─sda1   8:1    0  15.3G  0 part [SWAP]</span><br><span class="line">├─sda2   8:2    0 122.1G  0 part /</span><br><span class="line">└─sda3   8:3    0 794.2G  0 part /home</span><br><span class="line">sdb      8:16   0 232.9G  0 disk</span><br><span class="line">├─sdb1   8:17   0    16G  0 part</span><br><span class="line">└─sdb2   8:18   0 216.8G  0 part</span><br></pre></td></tr></table></figure><p>其中 <code>sda</code> 中安装了我们的主系统（Ubuntu）也就是当前运行的系统，<code>sdb</code> 中安装了“容器”的系统（Debian）。</p><ul><li>创建挂载点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/debian_10</span><br></pre></td></tr></table></figure><ul><li>挂载 <code>sdb</code> 中的文件系统</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb2 /mnt/debian_10</span><br></pre></td></tr></table></figure><ul><li>使用 <code>systemd-nspawn</code> 进入“容器”环境</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemd-nspawn -D /mnt/debian_10 -b</span></span><br><span class="line">pawning container debian10 on /mntdebian_10.</span><br><span class="line">Press ^] three times within 1s to kill container.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Welcome to Debian GNU/Linux 10 (buster)!</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux 10 debian console</span><br><span class="line"></span><br><span class="line">debian login:</span><br></pre></td></tr></table></figure><p>到此我们就进入了“容器”环境。在容器内部我们可以认为在另一个操作系统里，于是可以执行任何命令以及安装各种软件但是并不影响主系统。例如我们可以<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">安装 Asterisk</a> 与 <a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">FreePBX</a></p><ul><li>退出容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown now</span><br></pre></td></tr></table></figure><p>或者在 1s 内按下 <code>^]</code> 3次。（<code>control 键</code> + <code>] 键</code>）</p><h2 id="容器中安装平台环境"><a href="#容器中安装平台环境" class="headerlink" title="容器中安装平台环境"></a>容器中安装平台环境</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure><h3 id="Asterisk"><a href="#Asterisk" class="headerlink" title="Asterisk"></a>Asterisk</h3><p>参考 Asterisk 自动安装<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">脚本</a>。</p><p><em>注意：此脚本仅在 <code>Ubuntu18.04</code> 以及 <code>Debian10</code> 中测试通过。</em></p><h3 id="FreePBX"><a href="#FreePBX" class="headerlink" title="FreePBX"></a>FreePBX</h3><p>参考 FreePBX 自动安装<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">脚本</a>。</p><p><em>注意：此脚本仅在 <code>Ubuntu18.04</code> 以及 <code>Debian10</code> 中测试通过。</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>搭建 IPPBX 基础开发环境</code> 中的操作系统、工具软件选择以及容器的制作与运行。下一篇将接着介绍如何将容器<code>同步</code>到新设备上。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><sub>[1] 这里的容器不是指完整的容器技术，仅仅采用了 Linux 容器的概念。</sub></p><p><sub>[2] 只借用“拷贝”的概念，实际操作要更复杂一些。</sub></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> systemd-nspawn </tag>
            
            <tag> rsync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简明架构</title>
      <link href="/blog/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/"/>
      <url>/blog/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。</p><p><em><strong>原文地址：</strong></em> <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></p><img src="/blog/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/w.jpg" class="" title="Architecture" alt="Architecture"><a id="more"></a><p>以下为译文。</p><p>在过去的几年间我们已经看到过各种各样关于系统架构的设想，如下：</p><ul><li>来自 Alistair Cockburn 的<a href="http://alistair.cockburn.us/Hexagonal+architecture">六边形架构</a>（也称接口与适配），此架构被 Steve Freeman 与 Nat Pryce 在其合著的《测试驱动的面向对象软件开发》一书中采纳</li><li>来自 Jeffrey Palermo 的<a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">洋葱架构</a></li><li>我去年在博客中提出的<a href="http://blog.cleancoders.com/2011-09-30-Screaming-Architecture">令人惊叹的架构</a></li><li>由 James Coplien 和 Trygve Reenskaug 提出的 <a href="http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/">DCI</a></li><li>Ivar Jacobson 在其所著的《实例驱动的面向对象软件工程》一书中提出的 <a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350">BCE</a></li></ul><p>虽然以上这些架构都在细节上有所不同，但在宏观上非常相似。它们有同一个的目标，关注对软件的拆分，通过将软件分解为不同的层次，以达到拆分的目的。每种架构都至少有一层用于描述业务规则，其他层次用于创建接口。</p><p>使用这些架构所产生的系统都有以下特点：</p><ol><li>独立于框架。架构不依赖于功能丰富的软件库。这让你能够将软件框架作为工具使用，而不用为了使用框架将其塞入系统以满足框架的限制。</li><li>可测试。业务规则能够在没有界面、数据库、Web 服务器或其他元素的情况下被测试。</li><li>独立于界面。可以在不改变系统其余部分的情况下很容易地修改界面。例如，可以将 Web 界面改为命令行界面却不改变业务规则。</li><li>独立于数据库。你可以随时弃用 Oracle 或 SQL Server 的数据库改为使用 Mongo、BigTable、CouchDB 或者其他数据库。因为你的业务规则不与数据库绑定。</li><li>独立于任意外部机构。事实上你的业务规则根本对外部世界一无所知。</li></ol><h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>图中每一个同心圆表示不同领域的软件。通常，项目开发得越久软件所处的层级越高。外层圆是机制，内层是策略。</p><p>使这个架构能够正常运转而起到决定性作用的规则是<strong>依赖规则</strong>。这个规则描述了源代码的<strong>依赖关系</strong>只能由<strong>外部指向内部</strong>，处于内圈的代码对处于外圈的代码一无所知。特别的，在外圈定义的对象的名称必不能被处于内圈的代码提及。这些对象包括：函数、类、变量或者其他有名称的软件实体。</p><p>出于同样的原因，在外圈使用的格式化数据不应该在内圈被使用，特别是由某种软件框架产生的格式化数据。我们不希望外圈的任何事物影响到内圈。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>实体封装了企业范围内的业务规则。实体可以是携带方法的对象也可以是由数据结构和函数组成的集合。实体只要能被企业中不同的应用程序使用即可，具体是什么则无关紧要。</p><p>如果你没有开发企业级软件而是在写单个应用程序，那么这些实体可以是应用程序的业务对象，其中封装了最普遍最高层次的规则。如果架构的外围发生了改变那么实体将会是最后一个需要修改的。例如，你不希望当页面导航或者安全保护方面产生了变更而影响到实体。总的来说，任意指定程序的操作变更都不应影响实体层。</p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>处于这一层的软件包含面向应用程序的业务规则，封装和实现所有系统用例。这些用例编排数据流动包括流向实体和从实体流入，以及引导实体使用企业业务规则来实现用例的目的。</p><p>同样，我们不希望这一层的变更影响实体。也不希望这一层受到外部变更的影响，比如数据库、UI 或者任意软件框架，此层与这些情况无关。</p><p>可以预期，应用程序操作的变更会影响用例进而影响处于此层的软件。如果用例本身发生了变化，那么处于此层的代码一定会受到影响。</p><h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><p>处于此层的软件通常是一组适配器。适配器的作用是将方便于用例和实体使用的数据格式转换为方便外部机构使用的数据格式。外部机构包括数据库、Web 等。比如在此层中会完全包含图形用户界面的 MVC 架构，表示器、视图以及控制器都属于此层。模型一般表示为数据结构，从控制器传给用例，再从用例返回到表示器和视图。</p><p>类似的，数据从方便用例和实体使用的形式转换到方便持久化框架（如数据库）使用的形式也发生在此层。从这一层向内的所有代码都对数据库不了解。如果数据是 SQL 数据库那么所有的 SQL 语句都应该被限制在此层用于与数据库交互的部分。</p><p>当然此层还有另一种必备的适配器，用于将来自外部服务的数据格式转换为用例和实体使用的内部数据格式。</p><h2 id="框架和驱动"><a href="#框架和驱动" class="headerlink" title="框架和驱动"></a>框架和驱动</h2><p>最外一层通常是由软件框架与工具组成，例如数据库、Web 开发框架等。一般你不需要在此层写大量代码而是写一些“胶水”代码用于与紧邻的内层通信。</p><p>这一层是所有具体细节出现的地方，例如 Web、数据库都充满各种细节需要关注，将这类事物放到最外层可以最大可能地减少对整体系统的影响。</p><h2 id="仅有四层？"><a href="#仅有四层？" class="headerlink" title="仅有四层？"></a>仅有四层？</h2><p>不是，此图只是概念展示。在实际操作中你会发现所需的不止四层，也没有规定一定只能有四层。无论怎样<strong>依赖原则</strong>始终有效，即源代码总是向内依赖。越往内越抽象。最外圈是最低层次包含最具体的细节，越往内软件越为抽象封装更高层次的策略，最中心的圈也就最一般化。</p><h2 id="跨越边界"><a href="#跨越边界" class="headerlink" title="跨越边界"></a>跨越边界</h2><p>在图示中的右下角可以看到一个示例展示了我们如何跨越不同层次的边界。可以看到控制器和表示器通过它们隔壁层的用例来互相通信。注意控制的流向，它从控制器开始，通过用例最后在表示器中执行以结束。在看源代码的依赖方向，它们都向内指向用例，这就产生了矛盾。</p><p>通常我们使用<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置原则</a>解决这个显而易见的冲突。诸如 Java 一类的编程语言我们可以通过组织一组接口和类继承关系使得在适当的时候让源代码的依赖方向和控制方向相反以实现跨越边界。</p><p>例如，考虑当用例需要调用表示器的情况。这种调用方式必不能直接实现，因为这样违反了依赖原则：内部事物对外部一无所知。因此我们让用例定义以及调用接口（interface）也就是图中内圈的 Use Case Output Port，而让外圈的表示器实现这个接口（interface）。</p><p>这个技巧可以用在整个架构中所有需要跨越边界的地方。我们利用面向对象编程语言的动态多态性这个特点创建与控制流向相反的源代码依赖。这样不论控制流动的方向是什么我们都能让设计符合<strong>依赖原则</strong>。</p><h2 id="哪些数据会跨越边界"><a href="#哪些数据会跨越边界" class="headerlink" title="哪些数据会跨越边界"></a>哪些数据会跨越边界</h2><p>一般跨越边界的是简单的数据结构。可以根据自己的需要选择基本数据结构或者简单的数据传输对象或者函数调用时传入的参数，也可以将数据打包进哈稀表或者构建到对象里，关键在于用于跨越边界的数据要足够简单和具备独立性。我们并不希望让<strong>实体</strong>或数据库的原始数据行跨越边界，同样不希望跨越边界的结构里包含任意会违背<strong>依赖原则</strong>的数据。</p><p>比如，许多数据库框架会用便于使用的数据格式作为查询的响应，我们把这样的数据称为 RowStructure。我们不希望跨越边界时传递这样的结构，这样可能会违背<strong>依赖原则</strong>因为这有几率迫使内部的代码必须了解外部的数据定义。</p><p>因此，我们传递的数据跨越边界时，最常用是便于内层使用的格式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遵循这些简单的规则并不费劲，并且可以省去开发过程中很多麻烦。将整体软件分层并配合<strong>依赖原则</strong>，你可以创建一个具备极好测试性的系统，这会带来非常多的好处。当系统外部任意部分成为了整体系统的瓶颈，如数据库或者 Web 开发框架，你能只花很小的代价就将其撤换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Software Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Go 语言控制 GPIO</title>
      <link href="/blog/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/"/>
      <url>/blog/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/</url>
      
        <content type="html"><![CDATA[<p>GPIO 也就是通用输入/输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 <code>mmap</code> 系统调用来完成控制的方法。</p><a id="more"></a><h2 id="软硬件环境"><a href="#软硬件环境" class="headerlink" title="软硬件环境"></a>软硬件环境</h2><ul><li>CPU: iMX6Q(ARM)</li><li>Kernel: Linux 4.19.72</li><li>OS: Ubuntu18.04</li></ul><h2 id="GPIO-控制流程简介"><a href="#GPIO-控制流程简介" class="headerlink" title="GPIO 控制流程简介"></a>GPIO 控制流程简介</h2><p>iMX6Q 芯片手册上有如下描述:</p><img src="/blog/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/IMX6DQRM_28_4_3_0.png" class="" title="GPIO Programming" alt="GPIO Programming"><p>由此可知读取 GPIO 某一个管脚上的信号分为3个步骤:</p><ol><li>配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。</li><li>配置管脚方向寄存器，设置此管脚为输入。</li><li>从管脚数据寄存器中读取值。</li></ol><p>反之，如果要向外输出信号则为以下3步骤:</p><ol><li>配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。</li><li>配置管脚方向寄存器，设置此管脚为输出。</li><li>向管脚数据寄存器写入值。</li></ol><h2 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h2><p>iMX6Q 有7组 GPIO 每组有8个 32-bit 的寄存器，每个寄存器上 1-bit 控制着其对应的1个管脚的配置，也就是每组 GPIO 有32个管脚，每个管脚有8个配置项。关于 iMX6Q GPIO 更为详细的介绍可参阅 <a href="https://www.kosagi.com/w/index.php?title=Definitive_GPIO_guide">Definitive GPIO guide</a>。</p><p>对于只使用输入/输出功能的情况，8个寄存器中我们只需关心数据寄存器和方向寄存器这2个（对于管脚复用寄存器，因为默认状态下几乎所有管脚都是 GPIO 模式所以基本不用关心，具体情况请参考芯片手册）。</p><p>GPIO 控制寄存器的基地址为 <code>0x0209C000</code>，地址宽度为 <code>0x4000</code> 也就是第一组 GPIO 的控制寄存器在地址 <code>0x0209C000</code> 上，第二组在 <code>0x020A0000</code>，以此类推。每一个寄存器是 32-bit 大小所以，第一组 GPIO 的数据寄存器在 <code>0x0209C000</code> 方向寄存器在 <code>0x0209C004</code>，如下图:</p><img src="/blog/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/IMX6DQRM_28_5_0.png" class="" title="GPIO register" alt="GPIO register"><p>由此可以在代码中做如下定义:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    gpioBaseAddr  <span class="keyword">uint32</span> = <span class="number">0x0209C000</span></span><br><span class="line">    gpioAddrWidth <span class="keyword">uint32</span> = <span class="number">0x4000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于指定的某一组 GPIO 的寄存器地址可这样获得:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGPIOMMapper</span><span class="params">(group <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">uint32</span>, error)</span></span> &#123;</span><br><span class="line">    gaddr := gpioBaseAddr + (<span class="keyword">uint32</span>(group)<span class="number">-1</span>)*gpioAddrWidth</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存地址转换"><a href="#内存地址转换" class="headerlink" title="内存地址转换"></a>内存地址转换</h2><p>当程序运行起来后操作系统为每一个进程分配了一个虚拟地址空间，而寄存器的地址在实地址空间中，所以需要使用内存地址转换将实地址映射到虚拟地址空间，这样我们才能通过内存地址访问 GPIO 寄存器。</p><p>执行终端命令 <code>man mmap</code> 可查阅关于 mmap 详细的资料，这里我们通过 Go 语言 <code>unix</code> 包中封装的 <code>Mmap</code> 函数来使用 mmap 系统调用，如下:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGPIOMMapper</span><span class="params">(group <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">uint32</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b, err := unix.Mmap(<span class="keyword">int</span>(memMapFile.Fd()), <span class="keyword">int64</span>(gaddr), <span class="number">8</span>, unix.PROT_READ|unix.PROT_WRITE, unix.MAP_SHARED)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中指定映射的地址长度为8字节，原因是这里我们只使用前2个寄存器。<code>memMapFile</code> 可由如下函数获得:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initGPIOMemMap</span><span class="params">()</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;/dev/mem&quot;</span>, os.O_RDWR, <span class="number">0600</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="keyword">return</span> file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成地址转换之后 <code>unix.Mmap</code> 函数返回一个 <code>byte</code> 类型的切片，而每个寄存器是 32-bit 宽度，也就是一个寄存器对应 4 个 byte，这样操作起来比较麻烦。为了简化操作可以将 <code>[]byte</code> 转换为 <code>[]uint32</code> 类型:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byte2uint32</span><span class="params">(b []<span class="keyword">byte</span>)</span> []<span class="title">uint32</span></span> &#123;</span><br><span class="line">    sl := reflect.SliceHeader&#123;&#125;</span><br><span class="line">    sl.Cap = <span class="built_in">len</span>(b) / <span class="number">4</span></span><br><span class="line">    sl.Len = <span class="built_in">len</span>(b) / <span class="number">4</span></span><br><span class="line">    sl.Data = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;sl))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-GPIO-外设输出或读取值"><a href="#通过-GPIO-外设输出或读取值" class="headerlink" title="通过 GPIO 外设输出或读取值"></a>通过 GPIO 外设输出或读取值</h2><p>完成以上操作之后，假定得到的内存映射保存在 <code>var mapper []uint32</code> 中。如果我们要设置管脚 10 为输出，并且对外输出高电平，则可通过以下操作完成:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方向寄存器中第 10 bit 为1表示管脚10为输出</span></span><br><span class="line">mapper[<span class="number">1</span>] = mapper[<span class="number">1</span>] | <span class="keyword">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 设置数据寄存器中第 10 bit 为1表示管脚10输出高电平</span></span><br><span class="line">mapper[<span class="number">0</span>] = mapper[<span class="number">0</span>] | <span class="keyword">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>如果我们要设置管脚 10 为输入，并且读取管脚上的电平信息，则可通过以下操作完成:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方向寄存器中第 10 bit 为0表示管脚10为输入</span></span><br><span class="line">mapper[<span class="number">1</span>] = mapper[<span class="number">1</span>] &amp; ^<span class="keyword">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 读取数据寄存器中第 10 bit 的值</span></span><br><span class="line">value := mapper[<span class="number">0</span>] &amp; <span class="keyword">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 GPIO 的基本操作、iMX6Q GPIO 外设寄存器的分布以及 Go 语言中使用内存映射的方法，最后实现了使用 Go 语言对 GPIO 进行控制。对于以上的过程我们可以进一步将其封装成 <code>struct</code> 方便使用，类似如下:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GPIOPin <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group   <span class="keyword">int</span></span><br><span class="line">    Pin     <span class="keyword">int</span></span><br><span class="line">    mmapper []<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span> <span class="title">SetDir</span><span class="params">(dir <span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span> <span class="title">Direction</span><span class="params">()</span> <span class="title">string</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span> <span class="title">Set</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了内存映射之外，还可以使用其他方法操作 GPIO，例如通过 <code>sysfs</code> 文件系统或者使用 <code>/dev/gpiochip</code> 设备文件等，这里就不做过多介绍了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GPIO </tag>
            
            <tag> memory map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q 2GB 内存支持</title>
      <link href="/blog/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/"/>
      <url>/blog/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。</p><a id="more"></a><h2 id="系统启动过程现象"><a href="#系统启动过程现象" class="headerlink" title="系统启动过程现象"></a>系统启动过程现象</h2><p>系统启动过程中可看到 U-Boot 输出如下信息:</p><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2019.10-rc1-00134-gacda5922db-dirty (Mar 16 2020 - 15:27:54 +0800)</span><br><span class="line"></span><br><span class="line">CPU:   Freescale i.MX6Q rev1.6 996 MHz (running at 792 MHz)</span><br><span class="line">CPU:   Automotive temperature grade (-40C to 125C) at 36C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Model: Freescale i.MX6 Quad SABRE Smart Device Board</span><br><span class="line">Board: MX6-SabreSD</span><br><span class="line">I2C:   ready</span><br><span class="line">DRAM:  1 GiB</span><br><span class="line">PMIC:  PFUZE100 ID=0x10</span><br><span class="line">MMC:   FSL_SDHC: 0, FSL_SDHC: 3</span><br></pre></td></tr></table></figure><p>其中 <code>DRAM:  1 GiB</code> 这一行表示 U-Boot 识别到的内存空间大小为 1GB。</p><p>进入操作系统之后，终端执行如下命令:</p><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@arm:~$ cat /proc/meminfo</span><br><span class="line">MemTotal:        1031138 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可知操作系统识别到的内存空间大小也是 1GB。</p><h2 id="识别内存大小的过程"><a href="#识别内存大小的过程" class="headerlink" title="识别内存大小的过程"></a>识别内存大小的过程</h2><p>查看 U-Boot 源码，初始化函数 <code>board_init_f</code> 会执行一系列初始化操作:</p><figure class="highlight c"><figcaption><span>u-boot/common/board_f.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">hang();</span><br></pre></td></tr></table></figure><p><code>init_sequence_f</code> 是一个数组，所有初始化函数都放在这个数组中，其中有2个函数:</p><figure class="highlight c"><figcaption><span>imx6q/u-boot/common/board_f.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    announce_dram_init,</span><br><span class="line">    dram_init,<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>announce_dram_init</code> 函数只有一行代码作用是输出 <code>DRAM:</code>。真正需要我们关心的是 <code>dram_init</code>，这个函数继续调用了另一个函数 <code>imx_ddr_size</code>，接着往下追发现如下注释信息:</p><figure class="highlight c"><figcaption><span>u-boot/arch/arm/mach-imx/cpu.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * imx_ddr_size - return size in bytes of DRAM according MMDC config</span></span><br><span class="line"><span class="comment"> * The MMDC MDCTL register holds the number of bits for row, col, and data</span></span><br><span class="line"><span class="comment"> * width and the MMDC MDMISC register holds the number of banks. Combine</span></span><br><span class="line"><span class="comment"> * all these bits to determine the meme size the MMDC has been configured for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">imx_ddr_size</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">esd_mmdc_regs</span> *<span class="title">mem</span> =</span> (struct esd_mmdc_regs *)MEMCTL_BASE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到函数 <code>imx_ddr_size</code> 根据 <code>MMDC</code> 的配置返回内存空间大小，配置信息存储在寄存器 <code>MMDC_MDCTL</code> 中。</p><h2 id="适配-2GB-内存"><a href="#适配-2GB-内存" class="headerlink" title="适配 2GB 内存"></a>适配 2GB 内存</h2><p>从前面的代码中可看到寄存器 <code>MMDC_MDCTL</code> 的地址在定义 <code>MEMCTL_BASE</code> 中，接着查看 MEMCTL_BASE 的定义，可得到如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MEMCTL_BASE</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">MMDC_P0_BASE_ADDR</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">AIPS2_OFF_BASE_ADDR + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">ATZ2_BASE_ADDR + 0x80000 + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">AIPS2_ARB_BASE_ADDR + 0x80000 + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">0x02100000 + 0x80000 + 0x30000 &#x3D; 0x021b0000</span><br></pre></td></tr></table></figure><p>所以 MMDC_MDCTL 寄存器地址为 <code>0x021b0000</code>。此处代码是从寄存器中读取配置的值，那么一定会有其他的代码去配置这个寄存器的值，继续查找可发现:</p><figure class="highlight c"><figcaption><span>u-boot/board/freescale/mx6sabresd/mx6sabresd.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mx6q_dcd_table[] = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">0x021b0040</span>, <span class="number">0x00000027</span>,</span><br><span class="line">    <span class="number">0x021b0000</span>, <span class="number">0x831A0000</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始 codebase 中向寄存器 MMDC_MDCTL 配置了值 <code>0x831A0000</code> 以及向寄存器 MMDC_MDASP 配置了值 <code>0x00000027</code>。</p><p>接着从 iMX6Q 芯片参考手册中可查到寄存器 MMDC_MDCTL 数据位的分配:</p><img src="/blog/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/IMX6DQRM_44_12_1_0.png" class="" title="寄存器 MMDC_MDCTL" alt="寄存器 MMDC_MDCTL"><p>从而得知原始代码中，寄存器 MMDC_MDCTL 配置的含义为：</p><ul><li>使能 CS0</li><li>关闭 CS1</li><li>行地址宽度 14bit</li><li>列地址宽度 10bit</li><li>burst 长度 8</li><li>数据总线大小 64bit</li></ul><p>我们运行平台上的内存芯片和 iMX6Q SABRESD 开发板上的内存芯片是一样的封装，只是容量是后者的2倍，也就是<code>行地址宽度</code>多了1bit，所以将 MMDC_MDCTL 寄存器的值配置为 <code>0x841A0000</code>。</p><p>对于寄存器 <code>MMDC_MDASP</code>，芯片手册中描述如下:</p><blockquote><p>MMDCx_MDASP[CS0_END] should be set to DDR_CS_SIZE/32MB + 0x7 (DDR base address begins at 0x10000000)</p><footer><strong>Freescale</strong><cite>i.MX 6Dual/6Quad Applications Processor Reference Manual</cite></footer></blockquote><p>所以寄存器 MMDC_MDASP 的值应该配置为 <code>内存大小/32MB + 0x7</code> 也就是 <code>0x00000047</code>，最后配置如下:</p><figure class="highlight c"><figcaption><span>u-boot/board/freescale/mx6sabresd/mx6sabresd.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mx6q_dcd_table[] = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">0x021b0040</span>, <span class="number">0x00000047</span>,</span><br><span class="line">    <span class="number">0x021b0000</span>, <span class="number">0x841A0000</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备树修改"><a href="#设备树修改" class="headerlink" title="设备树修改"></a>设备树修改</h2><p>将 U-Boot 以及内核设备树与内存大小相关的地方修改为 2GB:</p><figure class="highlight dts"><figcaption><span>u-boot/arch/arm/dts/imx6qdl-sabresd.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">memory@10000000 </span>&#123;</span><br><span class="line">    reg = <span class="params">&lt;<span class="number">0x10000000</span> <span class="number">0x80000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，将以上修改保存到设备中，启动系统之后可以看到 U-Boot 以及操作系统均识别到 2GB 内存空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 U-Boot 在启动时识别内存大小的过程，以及 iMX6Q 关于内存信息的几个寄存器的配置，最终实现让系统平台识别并且使用 2GB 内存空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> 内存拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统中 Watchdog 的应用</title>
      <link href="/blog/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/blog/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何在 Linux 系统的用户层使用 Watchdog。</p><a id="more"></a><h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><ul><li>硬件环境: iMX6Q SABRE-SD 开发板</li><li>操作系统内核: Linux 4.19.72-armv7</li><li>操作系统发行版: Ubuntu18.04</li></ul><h2 id="开启-Watchdog"><a href="#开启-Watchdog" class="headerlink" title="开启 Watchdog"></a>开启 Watchdog</h2><p>在<a href="/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6#Linux-%E5%86%85%E6%A0%B8">编译内核</a>时开启 <code>Watchdog</code>:</p><figure class="highlight bash"><figcaption><span>./tools/rebuild.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核配置选项位置</span></span><br><span class="line">Device Drivers -&gt; Watchdog Timer Support</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/compile-kernel-watchdog.png"></p><p><em>开启 <code>Disable watchdog shutdown on close</code> 这一项。</em></p><p>内核文档中关于此选项的解释如下:</p><blockquote><p>When the device is closed, the watchdog is disabled, unless the “MagicClose” feature is supported (see below).  This is not always such a good idea, since if there is a bug in the watchdog daemon and it crashes the system will not reboot.  Because of this, some of the drivers support the configuration option “Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT.  If it is set to Y when compiling the kernel, there is no way of disabling the watchdog once it has been started.  So, if the watchdog daemon crashes, the system will reboot after the timeout has passed. Watchdog devices also usually support the nowayout module parameter so that this option can be controlled at runtime.</p><p>Magic Close feature:</p><p>If a driver supports “Magic Close”, the driver will not disable the watchdog unless a specific magic character ‘V’ has been sent to /dev/watchdog just before closing the file.  If the userspace daemon closes the file without sending this special character, the driver will assume that the daemon (and userspace in general) died, and will stop pinging the watchdog without disabling it first.  This will then cause a reboot if the watchdog is not re-opened in sufficient time.</p><footer><strong>Christer Weingel</strong><cite><a href="https://www.kernel.org/doc/Documentation/watchdog/watchdog-api.txt">The Linux Watchdog driver API.</a></cite></footer></blockquote><p>简单来说，开启此选项之后一旦我们打开了 Watchdog 设备，只要程序没对此 Watchdog 做文档中指定的操作，那么 Watchdog 就会重启系统。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>操作系统内核会将 CPU 芯片上的 Watchdog 外设抽象为文件系统中的一个字符设备:</p><figure class="highlight bash"><figcaption><span>ubuntu@arm:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/watchdog*</span><br><span class="line"><span class="comment"># /dev/watchdog  /dev/watchdog0</span></span><br></pre></td></tr></table></figure><p>上面命令列出来系统中的 Watchdog 设备（<code>/dev/watchdog</code>、<code>/dev/watchdog0</code> 在底层指向同一个硬件）。使用其中任一设备都可以。</p><ol start="0"><li>打开设备</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_open</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchdog_fd = open(watchdog_dev, O_RDWR);</span><br></pre></td></tr></table></figure><p>根据头文件 <code>linux/watchdog.h</code> 中的定义，我们可以通过得到的<code>文件描述符</code>对 watchdog 设备做后面这些操作。</p><ol><li>设置 watchdog 超时时间</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_settimeout</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &amp;seconds);</span><br></pre></td></tr></table></figure><ol start="2"><li>feed watchdog</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_feed</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_KEEPALIVE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>可以将上面的这些操作<a href="https://gist.github.com/ClarenceYk/c71502b63378e3fbcd763fdaa658803d">封装成函数接口</a>，在函数内部做一些错误处理。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">wait_time</span> =</span> &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (api_watchdog_init(WATCHDOG_DEV, WATCHDOG_TIMEOUT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Watchdog opened!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">api_watchdog_feed();</span><br><span class="line">nanosleep(&amp;wait_time, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，先初始化 watchdog 然后每秒 feed watchdog 一次，此时系统如常运行。当 kill 此程序后，由于前面在内核开启了 <code>Disable watchdog shutdown on close</code> 选项 watchdog 会继续工作，同时没有继续 feed 的操作所以系统进入重启流程。</p><h2 id="引入外部-Kick-信号"><a href="#引入外部-Kick-信号" class="headerlink" title="引入外部 Kick 信号"></a>引入外部 Kick 信号</h2><p>以一个具体的应用场景为例，如下:</p><figure class="highlight plain"><figcaption><span>硬件连接</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------   GPIO  --------</span><br><span class="line">| CPU | &lt;------ | FPGA |</span><br><span class="line">-------         --------</span><br></pre></td></tr></table></figure><p>FPGA 通过 CPU 的 GPIO 外设向开发板输入一个周期性翻转信号。CPU 在每一个周期开始时重置 watchdog，我们可以检测 GPIO 的上升沿或者下降沿获得周期开始的信息。</p><p>对 GPIO 的操作在 Linux 环境中有很多方法实现，这里我们使用 <a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 库来实现对 GPIO 上升沿信号的检测。</p><p><code>libgpiod</code> 中封装了很多便于使用的 API。在当前使用场景中，只需调用函数 <code>gpiod_ctxless_event_monitor</code> 就可实现我们想要的功能，其函数签名以及相应的文档注释如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wait for events on a single GPIO line.</span></span><br><span class="line"><span class="comment"> * @param device Name, path, number or label of the gpiochip.</span></span><br><span class="line"><span class="comment"> * @param event_type Type of events to listen for.</span></span><br><span class="line"><span class="comment"> * @param offset GPIO line offset to monitor.</span></span><br><span class="line"><span class="comment"> * @param active_low The active state of this line - true if low.</span></span><br><span class="line"><span class="comment"> * @param consumer Name of the consumer.</span></span><br><span class="line"><span class="comment"> * @param timeout Maximum wait time for each iteration.</span></span><br><span class="line"><span class="comment"> * @param poll_cb Callback function to call when waiting for events.</span></span><br><span class="line"><span class="comment"> * @param event_cb Callback function to call for each line event.</span></span><br><span class="line"><span class="comment"> * @param data User data passed to the callback.</span></span><br><span class="line"><span class="comment"> * @return 0 if no errors were encountered, -1 if an error occurred.</span></span><br><span class="line"><span class="comment"> * @note The way the ctxless event loop works is described in detail in</span></span><br><span class="line"><span class="comment"> *       ::gpiod_ctxless_event_monitor_multiple - this is just a wrapper aound</span></span><br><span class="line"><span class="comment"> *       this routine which calls it for a single GPIO line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpiod_ctxless_event_monitor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *device, <span class="keyword">int</span> event_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, <span class="keyword">bool</span> active_low,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *consumer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> struct timespec *timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                gpiod_ctxless_event_poll_cb poll_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                                gpiod_ctxless_event_handle_cb event_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> *data)</span> GPIOD_API</span>;</span><br></pre></td></tr></table></figure><p>如上可以看出几个关键参数，通过 <code>device</code>、<code>offset</code> 参数指定使用的 GPIO 管脚，<code>event_type</code> 指定检测事件（如，上升沿事件），<code>event_cb</code> 是触发指定事件后调用的回调函数，其调用方法大致如下:</p><figure class="highlight c"><figcaption><span>上升沿检测</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WDOG_GPIO_SIG_CHIP &quot;/dev/gpiochip6&quot;</span></span><br><span class="line"><span class="comment">// WDOG_GPIO_SIG_PORT 7</span></span><br><span class="line">gpiod_ctxless_event_monitor(WDOG_GPIO_SIG_CHIP, GPIOD_CTXLESS_EVENT_RISING_EDGE,</span><br><span class="line">                        WDOG_GPIO_SIG_PORT, <span class="literal">false</span>, <span class="string">&quot;wdog&quot;</span>, &amp;timeout,</span><br><span class="line">                        <span class="literal">NULL</span>, gpio6_port7_rising_edge_handle_cb, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>接下来只需要再定义回调函数即可，回调函数的函数签名如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Simple event callback signature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The callback function takes the following arguments: event type (int),</span></span><br><span class="line"><span class="comment"> * GPIO line offset (unsigned int), event timestamp (const struct timespec *)</span></span><br><span class="line"><span class="comment"> * and a pointer to user data (void *).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This callback is called by the ctxless event loop functions for each GPIO</span></span><br><span class="line"><span class="comment"> * event. If the callback returns ::GPIOD_CTXLESS_EVENT_CB_RET_ERR, it should</span></span><br><span class="line"><span class="comment"> * also set errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*gpiod_ctxless_event_handle_cb)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> struct timespec *, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>所以我们定义的上升沿事件回调函数大致如下:</p><figure class="highlight c"><figcaption><span>定义回调函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio6_port7_rising_edge_handle_cb</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *timestamp, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wdog_count ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wdog_count &gt;= WDOG_FEED_PERIOD / FPGA_WDOG_SIG_PERIOD) &#123;</span><br><span class="line">        api_watchdog_feed();</span><br><span class="line">        wdog_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GPIOD_CTXLESS_EVENT_CB_RET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键在于 <code>api_watchdog_feed()</code>。</p><p>以上就实现了外部 Kick 信号的引入。</p><h2 id="配置-systemd-服务"><a href="#配置-systemd-服务" class="headerlink" title="配置 systemd 服务"></a>配置 systemd 服务</h2><p>我们希望 watchdog 程序随着系统自动启动，所以配置如下的 systemd 服务:</p><figure class="highlight plain"><figcaption><span>wdog_fpga.service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Watchdog systemd service.</span><br><span class="line">ConditionKernelCommandLine&#x3D;!disable_wdog</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;wdog_fpga</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>其中我们定义了 <code>ConditionKernelCommandLine</code> 参数为 <code>!disable_wdog</code>。这样当系统启动之后 systemd 会检测内核启动命令行参数中是否存在<code>disable_wdog</code>，如果不存在则启动 watchdog，反之依然。这样配置的好处是，我们可以在系统启动之前配置是否开启 watchdog。</p><h2 id="U-Boot-环境设置内核命令行参数"><a href="#U-Boot-环境设置内核命令行参数" class="headerlink" title="U-Boot 环境设置内核命令行参数"></a>U-Boot 环境设置内核命令行参数</h2><p>如果我们不想开启 watchdog，则在 U-Boot 启动后暂停引导内核，然后将 <code>disable_wdog</code> 参数设置到内核命令行参数中，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs ... 其他参数 ... disable_wdog</span><br></pre></td></tr></table></figure><p>然后再引导内核启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run bootcmd</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本介绍了如何在 Linux 操作系统中使用 watchdog，分为以下方面的工作:</p><ul><li>内核选项配置</li><li>部分 API 介绍</li><li>设备操作接口封装</li><li>实际应用场景示例</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Watchdog </tag>
            
            <tag> Embedded System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q SABRE-SD 开发板软件烧录</title>
      <link href="/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/"/>
      <url>/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 <code>iMX6Q SABRE-SD</code> 开发板的软件烧录流程。</p><a id="more"></a><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0"><li><p>使开发板进入工厂模式<br>具体操作请参考此<a href="/blog/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D">文档</a>。</p></li><li><p>开发板系统软件<br>制作开发板系统软件请参考此<a href="/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">文档</a>。</p></li></ol><h2 id="烧录流程"><a href="#烧录流程" class="headerlink" title="烧录流程"></a>烧录流程</h2><p>烧录过程中会使用 <code>utp_com</code> 向开发板发送指令，开发板收到指令后执行。</p><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><ol start="0"><li>分区脚本</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">END &gt;/tmp/mkmmc.sh</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">node=\$1</span></span><br><span class="line"><span class="string"># partition size in MB</span></span><br><span class="line"><span class="string">BOOT_ROM_SIZE=10</span></span><br><span class="line"><span class="string"># wait for the SD/MMC device node ready</span></span><br><span class="line"><span class="string">while [ ! -e \$&#123;node&#125; ]</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">sleep 1</span></span><br><span class="line"><span class="string">echo &quot;wait for \$&#123;node&#125; appear&quot;</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string"># destroy the partition table</span></span><br><span class="line"><span class="string">dd if=/dev/zero of=\$&#123;node&#125; bs=1024 count=1</span></span><br><span class="line"><span class="string"># call sfdisk to create partition table</span></span><br><span class="line"><span class="string">sfdisk --force \$&#123;node&#125; &lt;&lt;EOF</span></span><br><span class="line"><span class="string">1M,,L,*</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">END</span></span><br></pre></td></tr></table></figure><ol><li>发送并执行分区脚本</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f /tmp/mkmmc.sh</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ sh \$FILE /dev/mmcblk3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="建立-U-Boot-分区"><a href="#建立-U-Boot-分区" class="headerlink" title="建立 U-Boot 分区"></a>建立 U-Boot 分区</h3><ol start="0"><li>boot 分区写使能</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo 0 &gt; /sys/block/mmcblk3boot0/force_ro&quot;</span></span><br></pre></td></tr></table></figure><ol><li>发送 SPL、U-Boot 并写入</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;SPL 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ dd if=\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=1&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;U-Boot 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ dd if=\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=69&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>boot 分区只读使能</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo 1 &gt; /sys/block/mmcblk3boot0/force_ro&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使能 boot 分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mmc bootpart enable 1 1 /dev/mmcblk3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建系统分区"><a href="#创建系统分区" class="headerlink" title="创建系统分区"></a>创建系统分区</h3><ol start="0"><li>建立 EXT4 分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ while [ ! -e /dev/mmcblk3p1 ]; do sleep 1; echo \&quot;waiting...\&quot;; done&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkfs.ext4 -L rootfs /dev/mmcblk3p1&quot;</span></span><br></pre></td></tr></table></figure><ol><li>挂载系统分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkdir -p /mnt/rootfs&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mount /dev/mmcblk3p1 /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h3><ol start="0"><li>写入根文件系统</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;pipe tar -x[文件压缩方式] -C /mnt/rootfs&quot;</span> -f &lt;rootfs 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;frf&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ chown root:root /mnt/rootfs&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ chmod 755 /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><ol><li>设置 <code>uname_r</code></li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo &#x27;uname_r=&lt;内核版本信息&gt;&#x27; &gt;&gt; /mnt/rootfs/boot/uEnv.txt&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>写入内核、设备树、内核模块</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;kernel 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ cp \$FILE /mnt/rootfs/boot/vmlinuz-&lt;内核版本信息&gt;&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;dtb 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkdir -p /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ tar xf \$FILE -C /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;modules 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ tar xf \$FILE -C /mnt/rootfs/&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>更新 fstab</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo &#x27;/dev/mmcblk2p1  /  auto  errors=remount-ro  0  1&#x27; &gt;&gt; /mnt/rootfs/etc/fstab&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>同步，取消挂载</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ sync&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ umount /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><h2 id="启动开发板"><a href="#启动开发板" class="headerlink" title="启动开发板"></a>启动开发板</h2><p>将开发板的<a href="/blog/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">启动拨码开关</a>拨至 <code>11100110</code>，然后上电启动可看到串口输出:</p><figure class="highlight bash"><figcaption><span>串口输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu 18.04.3 LTS arm ttymxc0</span><br><span class="line"></span><br><span class="line">default username:password is [ubuntu:temppwd]</span><br><span class="line"></span><br><span class="line">arm login: </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>iMX6Q SABRE-SD</code> 开发板的软件烧录流程，总结为以下4个步骤:</p><ul><li>创建分区表</li><li>建立 U-Boot 分区</li><li>创建系统分区</li><li>安装操作系统</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q SABRE-SD 开发板系统软件</title>
      <link href="/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/"/>
      <url>/blog/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍适用于 <code>iMX6Q SABRE-SD</code> 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。</p><a id="more"></a><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="ARM-交叉编译工具链"><a href="#ARM-交叉编译工具链" class="headerlink" title="ARM 交叉编译工具链"></a>ARM 交叉编译工具链</h2><ol start="0"><li>下载 &amp; 解压</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz</span><br><span class="line">tar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz</span><br></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=`<span class="built_in">pwd</span>`/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line"><span class="variable">$&#123;CC&#125;</span>gcc --version</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc (Linaro GCC 6.5-2018.12) 6.5.0</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h2 id="启动加载器-U-Boot"><a href="#启动加载器-U-Boot" class="headerlink" title="启动加载器: U-Boot"></a>启动加载器: U-Boot</h2><ol start="0"><li>下载源码</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/u-boot/u-boot</span><br><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line">git checkout v2019.07 -b tmp</span><br></pre></td></tr></table></figure><ol><li>打补丁</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/u-boot$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://raw.githubusercontent.com/eewiki/u-boot-patches/master/v2019.07-rc4/0001-mx6sabresd-fixes.patch</span><br><span class="line">patch -p1 &lt; 0001-mx6sabresd-fixes.patch</span><br></pre></td></tr></table></figure><ol start="2"><li>修改代码</li></ol><p>用编辑器打开文件 <code>~/u-boot/include/configs/mx6sabre_common.h</code>，找到如下代码:</p><figure class="highlight c"><figcaption><span>vi ~/u-boot/include/configs/mx6sabre_common.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="string">&quot;setenv interface mmc;&quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv mmcdev 0;&quot;</span> \</span><br><span class="line"><span class="string">&quot;run mmcboot;&quot;</span> \</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>添加2行代码，结果如下:</p><figure class="highlight c"><figcaption><span>vi ~/u-boot/include/configs/mx6sabre_common.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="string">&quot;setenv interface mmc;&quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv mmcdev 3;&quot;</span> \</span><br><span class="line"><span class="string">&quot;run mmcboot;&quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv mmcdev 0;&quot;</span> \</span><br><span class="line"><span class="string">&quot;run mmcboot;&quot;</span> \</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 &amp; 编译</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/u-boot$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span> distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span> mx6sabresd_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h2><p>内核我们采用 <code>4.19</code> 长期支持版。</p><ol start="0"><li>下载源码</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RobertCNelson/armv7-multiplatform</span><br><span class="line"><span class="built_in">cd</span> armv7-multiplatform/</span><br><span class="line">git checkout origin/v4.19.x -b tmp</span><br></pre></td></tr></table></figure><ol><li>编译</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/armv7-multiplatform$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build_kernel.sh</span><br></pre></td></tr></table></figure><h2 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h2><p>根文件系统我们采用 <code>Ubuntu18.04 LTS</code>。</p><ol start="0"><li>下载</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br></pre></td></tr></table></figure><ol><li>验证</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sha256sum ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br><span class="line"><span class="comment"># 输出信息: b28b356d75153bfb3beb5c96bf8eabe92025cf5e665e1a564b469bc70e5a363b  ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span></span><br></pre></td></tr></table></figure><ol start="2"><li>解压</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>iMX6Q SABRE-SD</code> 开发板系统软件的制作。通过这些操作可得到以下文件:</p><ol start="0"><li>启动加载器, <code>目录: ~/u-boot/</code></li></ol><ul><li>SPL</li><li>u-boot.img</li></ul><ol><li>内核相关，<code>目录: ~/armv7-multiplatform/deploy</code></li></ol><ul><li>4.19.xx-armv7-xxx.zImage</li><li>4.19.xx-armv7-xxx-dtbs.tar.gz</li><li>4.19.xx-armv7-xxx-modules.tar.gz</li></ul><ol start="2"><li>根文件系统，<code>目录: ~/imx6q/ubuntu-18.04.3-minimal-armhf-2020-02-10</code></li></ol><ul><li>armhf-rootfs-ubuntu-bionic.tar</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> U-Boot </tag>
            
            <tag> Linux kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX USB loader &amp; UTP 使用方法介绍</title>
      <link href="/blog/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/blog/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。</p><a id="more"></a><p>在使用 iMX6Q SabreSD 开发板时，如果我们对 Linux 内核或者根文件系统进行了定制则需要将新的软件部署到开发板。将软件部署到开发板的方法与开发板的启动方式有关，如果我们需要开发板从 eMMC 启动则需要将软件部署到 eMMC 存储器，使用 Freescale 提供的 <code>iMX USB loader</code> 和 <code>UTP</code> 2个工具能帮助我们完成这项工作。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="开发板设置"><a href="#开发板设置" class="headerlink" title="开发板设置"></a>开发板设置</h2><p>在操作之前需要将开发板设置到下载模式，iMX6Q SabreSD 的说明文档中提到:</p><blockquote><table><thead><tr><th>Mode</th><th>Switch</th></tr></thead><tbody><tr><td>download mode(MFGTool mode)</td><td>(SW6) 00001100 (from 1-8 bit)</td></tr><tr><td>eMMC (MMC3) boot</td><td>(SW6) 11100110 (from 1-8 bit)</td></tr><tr><td>MMC4 (SD2) boot</td><td>(SW6) 10000010 (from 1-8 bit)</td></tr><tr><td>MMC2 (SD3) boot</td><td>(SW6) 01000010 (from 1-8 bit)</td></tr></tbody></table><p><em><strong>Freescale</strong></em> – <em>Android User Guide</em></p></blockquote><p>所以我们将开发板的启动拨码开关拨到如下位置:</p><p><img src="/blog/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/imx-usb-loader-boot-switch.jpg"></p><p>将开发板的 USB 接到电脑端，使用 <code>lsusb</code> 命令可看到如下信息:</p><figure class="highlight bash"><figcaption><span>查看 USB 设备信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># Bus 001 Device 003: ID 15a2:0054 Freescale Semiconductor, Inc. i.MX 6Dual/6Quad SystemOnChip in RecoveryMode</span></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure><p>可看到电脑端成功识别了开发板，记录下 <code>ID</code> 信息:</p><ul><li>ID: 15a2:0054</li></ul><p><em>在开始后面步骤之前请将开发板串口与电脑端连接，方便通过串口查看调试信息。</em></p><h2 id="iMX-USB-loader-安装配置"><a href="#iMX-USB-loader-安装配置" class="headerlink" title="iMX USB loader 安装配置"></a>iMX USB loader 安装配置</h2><ol start="0"><li>安装 <code>libusb</code>。</li></ol><figure class="highlight bash"><figcaption><span>install libusb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><ol><li>获取 iMX USB loader <a href="https://github.com/boundarydevices/imx_usb_loader">源代码</a>。</li></ol><figure class="highlight bash"><figcaption><span>git clone</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/boundarydevices/imx_usb_loader.git</span><br></pre></td></tr></table></figure><ol start="2"><li>编译</li></ol><figure class="highlight bash"><figcaption><span>compile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> imx_usb_loader</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置文件</li></ol><p>查看文件 <code>imx_usb.conf</code> 根据刚刚记录下来的 <code>ID</code> 值找到取对应的开发板配置文件:</p><figure class="highlight plain"><figcaption><span>imx_usb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">0x15a2:0x0054, mx6_usb_work.conf</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>将文件 <code>mx6_usb_work.conf</code> 的内容修改为如下:</p><figure class="highlight plain"><figcaption><span>mx6_usb_work.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mx6_qsb</span><br><span class="line">hid,1024,0x910000,0x10000000,1G,0x00900000,0x40000</span><br><span class="line"></span><br><span class="line">firmware&#x2F;u-boot.imx: dcd</span><br><span class="line">firmware&#x2F;zImage: load 0x12000000</span><br><span class="line">firmware&#x2F;fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot: load 0x12C00000</span><br><span class="line">firmware&#x2F;zImage-imx6q-sabresd.dtb: load 0x18000000</span><br><span class="line">firmware&#x2F;u-boot.imx: clear_dcd,load,plug,jump header</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 USB loader</li></ol><p>创建 <code>firmware</code> 目录:</p><figure class="highlight bash"><figcaption><span>创建目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir firmware </span><br></pre></td></tr></table></figure><p>将<a href="/blog/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83#%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA-MFGTool">生成的镜像文件</a>拷贝到 <code>firmware</code> 目录中后执行:</p><figure class="highlight bash"><figcaption><span>运行 imx_usb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./imx_usb </span><br></pre></td></tr></table></figure><p>等待半分钟左右，可通过串口看到输出的启动信息:</p><figure class="highlight bash"><figcaption><span>串口输出信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Starting UTP</span><br><span class="line">uuc 0.5 [built Jan  9 2020 12:41:11]</span><br><span class="line">UTP: Waiting <span class="keyword">for</span> device to appear</span><br><span class="line">UTP: file/device node /dev/utp already exists</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此时开发板通过 USB 将自己模拟成一个 <code>sg</code> 设备，在电脑端可以通过以下命令查看此设备:</p><figure class="highlight bash"><figcaption><span>查看 sg 设备</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/sg*</span><br><span class="line"><span class="comment"># /dev/sg0  /dev/sg1</span></span><br></pre></td></tr></table></figure><p>其中 <code>/dev/sg1</code> 就是开发板。通过此设备我们便可用 <code>UTP</code> 工具与开发板通信。</p><h2 id="UTP-安装配置"><a href="#UTP-安装配置" class="headerlink" title="UTP 安装配置"></a>UTP 安装配置</h2><ol start="0"><li>安装 <code>libsgutils2</code>。</li></ol><figure class="highlight bash"><figcaption><span>install libsgutils2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsgutils2-dev</span><br></pre></td></tr></table></figure><ol><li>获取 UTP <a href="https://github.com/ixonos/utp_com">源代码</a>。</li></ol><figure class="highlight bash"><figcaption><span>git clone</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ixonos/utp_com.git</span><br></pre></td></tr></table></figure><ol start="2"><li>编译</li></ol><figure class="highlight bash"><figcaption><span>compile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> utp_com</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 utp_com 与开发板通信</li></ol><figure class="highlight bash"><figcaption><span>使用 utp_com</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>通过串口可看到开发板的输出信息:</p><figure class="highlight bash"><figcaption><span>串口输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UTP: received <span class="built_in">command</span> <span class="string">&#x27;$ echo hello, world!&#x27;</span></span><br><span class="line">UTP: executing <span class="string">&quot;echo hello, world!&quot;</span></span><br><span class="line">hello, world!</span><br><span class="line">UTP: sending Success to kernel <span class="keyword">for</span> <span class="built_in">command</span> $ <span class="built_in">echo</span> hello, world!.</span><br><span class="line">utp_poll: pass returned.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们完成了 <code>imx_usb</code> 和 <code>utp_com</code> 的安装配置，使用 imx_usb 向开发板下载固件，以及使用 utp_com 与开发板通信向其发送并执行指令。具体工作如下:</p><ul><li>开发板下载模式配置</li><li>iMX USB loader 安装配置</li><li>UTP com 安装配置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> mfgtool </tag>
            
            <tag> imx_usb </tag>
            
            <tag> utp_com </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 iMX6Q SabreSD Yocto 项目开发环境</title>
      <link href="/blog/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/blog/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 <a href="">iMX6Q SabreSD</a> 开发板的 <a href="">Yocto Project</a> 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。</p><a id="more"></a><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight bash"><figcaption><span>Yocto Project 的依赖包</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \</span><br><span class="line">build-essential chrpath socat</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>其他依赖包</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev xterm sed cvs subversion coreutils texi2html \</span><br><span class="line">docbook-utils python-pysqlite2 help2man make gcc g++ desktop-file-utils \</span><br><span class="line">libgl1-mesa-dev libglu1-mesa-dev mercurial autoconf automake groff curl lzop asciidoc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>u-boot 工具</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install u-boot-tools</span><br></pre></td></tr></table></figure><h2 id="安装-repo-工具"><a href="#安装-repo-工具" class="headerlink" title="安装 repo 工具"></a>安装 <code>repo</code> 工具</h2><p><code>repo</code> 是一个基于 <code>git</code> 的工具。使用 repo 可以方便地管理存在多个软件源的项目。安装 repo 分为以下几个步骤:</p><ol start="0"><li>在 <code>home</code> 目录下创建一个 <code>bin</code> 目录。</li></ol><figure class="highlight bash"><figcaption><span>安装 repo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><ol><li>将下面2行加入 <code>.bashrc</code> 文件末尾，确保 <code>~/bin</code> 在 <code>PATH</code> 变量中。</li></ol><figure class="highlight bash"><figcaption><span>环境变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:~/bin</span><br><span class="line"><span class="built_in">export</span> MACHINE=imx6qsabresd</span><br></pre></td></tr></table></figure><h2 id="构建-Yocto-项目"><a href="#构建-Yocto-项目" class="headerlink" title="构建 Yocto 项目"></a>构建 Yocto 项目</h2><p><code>Freescale Yocto Project BSP Release</code> 目录包含如下内容:</p><ul><li><code>sources</code> 目录包含一些用于构建的配方</li><li>一个或多个 <code>build</code> 目录</li><li>一些用于配置开发环境的脚本</li></ul><p>以下步骤创建了一个 <code>fsl-release-bsp</code> 目录用于构建 Yocto 项目:</p><figure class="highlight bash"><figcaption><span>创建目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir fsl-release-bsp</span><br><span class="line"><span class="built_in">cd</span> fsl-release-bsp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>配置 git 信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git config --global user.name &quot;Your Name&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;ClarenceYk&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email &quot;Your Email&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>同步源代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo init -u git://git.freescale.com/imx/fsl-arm-yocto-bsp.git -b imx-4.1.15-1.0.0_ga</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>上面采用了 <code>imx-4.1.15-1.0.0_ga</code> 分支，可根据实际需求使用<a href="http://git.freescale.com/git/cgit.cgi/imx/fsl-arm-yocto-bsp.git/">其他分支代码</a>，如下:</p><p><img src="/blog/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/fsl-arm-yocto-bsp-git.jpg"></p><h2 id="编译构建-MFGTool"><a href="#编译构建-MFGTool" class="headerlink" title="编译构建 MFGTool"></a>编译构建 MFGTool</h2><p>向开发板烧录系统镜像可使用 MFGTool 完成。编译 MFGTool 镜像文件的配方分别是 <code>linux-imx-mfgtool</code> 和 <code>u-boot-mfgtool</code>。编译命令如下:</p><figure class="highlight bash"><figcaption><span>编译 MFGTool</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fsl-release-bsp</span><br><span class="line"><span class="built_in">source</span> fsl-setup-release.sh -b build-mfgtools -e x11</span><br><span class="line">bitbake fsl-image-mfgtool-initramfs</span><br></pre></td></tr></table></figure><p><em>编译过程需下载大量的源代码，为确保过程顺利建议使用 VPN 或者采用其他加速网络访问的方式。</em></p><p>成功编译之后，在目录 <code>~/fsl-mfgtools-bsp/build-mfgtools/tmp/deploy/images/imx6qsabresd</code> 下会产生如下文件:</p><ul><li>u-boot.imx（u-boot）</li><li>zImage（内核）</li><li>zImage-imx6q-sabresd.dtb（设备树）</li><li>fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot（内存文件系统）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，我们完成了 <code>Freescale iMX6Q Yocto Project</code> 开发环境搭建，其中包含如下方面的工作:</p><ul><li>安装项目依赖软件</li><li>安装 repo</li><li>配置 git</li><li>构建 Yocto 项目</li><li>编译 MFGTool 镜像</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> mfgtool </tag>
            
            <tag> yocto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 安装及配置 Ubuntu14.04 服务器版</title>
      <link href="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/"/>
      <url>/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。</p><a id="more"></a><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>操作系统: Windows 10</li><li>VirtualBox: 6.0</li></ul><h2 id="下载及安装-VirtualBox"><a href="#下载及安装-VirtualBox" class="headerlink" title="下载及安装 VirtualBox"></a>下载及安装 VirtualBox</h2><p>本文创建时使用的 VirtualBox 版本为 <code>6.0</code>，你可根据自己的需要选择其他或者最新版本。</p><ol start="0"><li>访问 Oracle VirtualBox <a href="https://www.virtualbox.org/">主页</a>。</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualbox.png"></p><ol><li>点击<code>下载</code>按钮，下载安装程序后双击此程序安装 VirtualBox。</li></ol><p><em>此处可一路点击<code>下一步</code>直至安装完成，然后重启计算机。</em></p><h2 id="下载-Ubuntu14-04-服务器版镜像文件"><a href="#下载-Ubuntu14-04-服务器版镜像文件" class="headerlink" title="下载 Ubuntu14.04 服务器版镜像文件"></a>下载 Ubuntu14.04 服务器版镜像文件</h2><ol start="0"><li>访问 Ubuntu 镜像<a href="http://releases.ubuntu.com/">发布页</a>，点击如下图<a href="http://releases.ubuntu.com/trusty/">链接</a>。</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/ubuntu-trusty.jpg"></p><ol><li>在如下页面中找到并下载<em><strong>服务器版本</strong></em>镜像。</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/ubuntu-trusty-image.jpg"></p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>接下来开始创建虚拟机。</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualbox-new.jpg"></p><ol start="0"><li>点击新建，选项配置如下：</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-config.jpg"></p><ul><li>名称: 自定义，如 <code>ubuntu1404-mfgtools</code> 表示此虚拟机操作系统为 <code>ubuntu14.04</code> 用于制作 <code>mfgtools</code></li><li>文件夹: 自定义，此虚拟机相关文件存放位置</li><li>类型: Linux</li><li>版本: Ubuntu (64-bit)</li><li>内存大小: 不影响主机性能的情况下取最大</li></ul><p>其他选项如上图，配置完成后点击<code>创建</code>。</p><ol><li>创建虚拟磁盘:</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-disk.jpg"></p><ul><li>文件大小: 根据需求配置</li><li>固定或动态大小: 同上</li></ul><p>配置完成点击<code>创建</code>。</p><h2 id="设置启动镜像"><a href="#设置启动镜像" class="headerlink" title="设置启动镜像"></a>设置启动镜像</h2><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings.jpg"></p><ol start="0"><li>点击<code>设置</code>，选择<code>存储</code>：</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-storage.jpg"></p><ol><li>依次点击如下所示选项：</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-storage-sel-image.jpg"></p><p>然后在弹出的选项中点击<code>选择一个虚拟光盘文件</code>，然后在弹出的选项框中选择之前下载的<code>系统镜像</code>文件。</p><ol start="2"><li>选择<code>系统</code>，将<code>启动顺序</code>改为如下图般:</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-system-boot.jpg"></p><p>配置完成后点击<code>确认</code>。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol start="0"><li>主界面点击<code>启动</code>，进入系统安装界面。</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install.jpg"></p><ol><li>根据提示操作，完成安装后如下图：</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install-complete.jpg"></p><p>选择 <code>Continue</code> 结束安装。关闭窗口。</p><ol start="2"><li>回到主界面点击<code>设置</code>，选择<code>系统</code>并将<code>启动顺序</code>改为如下图般:</li></ol><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-system-boot-1.jpg"></p><p>点击 <code>ok</code> 保存设置。</p><h2 id="额外的配置"><a href="#额外的配置" class="headerlink" title="额外的配置"></a>额外的配置</h2><p>完成前面的步骤后一个可用的虚拟机已经创建完成，后面的步骤可以让虚拟机使用起来更方便。</p><ol start="0"><li>设置端口转发</li></ol><p>回到主界面点击<code>设置</code>，选择<code>网络</code>并点击<code>高级</code>选项卡:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-network.jpg"></p><p>点击<code>端口转发</code>之后，添加如下配置:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-port.jpg"></p><p>其中<code>子系统IP</code>填为虚拟机的 <code>IP</code> 地址。</p><p><em>这一步的作用是将虚拟机的 <code>22</code> 端口转发到主机的 <code>2200</code> 端口上，方面我们使用 <code>SSH</code> 连接虚拟机。</em></p><ol><li>安装增强功能</li></ol><figure class="highlight bash"><figcaption><span>登录虚拟机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh -p &lt;端口&gt; &lt;用户&gt;@&lt;主机地址&gt;</span></span><br><span class="line">ssh -p 2200 <span class="built_in">test</span>@192.168.1.101</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>安装依赖软件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>点击如下图所示的<code>安装增强功能</code>:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install-enhance.jpg"></p><figure class="highlight bash"><figcaption><span>挂载光盘</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/cdrom</span><br><span class="line">sudo mount /dev/cdrom /mnt/cdrom/</span><br><span class="line"><span class="comment"># mount: block device /dev/sr0 is write-protected, mounting read-only</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>运行安装程序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/cdrom/</span><br><span class="line">sudo ./VBoxLinuxAdditions.run</span><br><span class="line">sudo shutdown -h 0 -r</span><br></pre></td></tr></table></figure><ol start="2"><li>共享文件夹</li></ol><figure class="highlight bash"><figcaption><span>加入 vboxsf 组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo usermod -a -G vboxsf &lt;用户&gt;</span></span><br><span class="line">sudo usermod -a -G vboxsf <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>回到<code>设置</code>，选择<code>共享文件夹</code>并点击如下所示按钮:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-new-share.jpg"></p><p>如下般设置:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-new-share-settings.jpg"></p><p><em>挂载点不用填。</em></p><figure class="highlight bash"><figcaption><span>重启虚拟机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h 0 -r</span><br></pre></td></tr></table></figure><ol start="3"><li>USB 设备支持</li></ol><p>访问 VirtualBox 官网下载<a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0">拓展包</a>。<em>注意，请找到对应自己版本的拓展包。</em></p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-extension-pack.jpg"></p><p>回到 VirtualBox 主界面，选择<code>管理</code>-&gt;<code>全局设定</code>-&gt;<code>拓展</code>:</p><p><img src="/blog/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-extension-pack-sel.jpg"></p><p>选择刚刚下载的拓展包，安装。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们就在虚拟机中安装好了 Ubuntu 操作系统，并做了以下设置:</p><ul><li>将虚拟机的<code>22</code>端口转发到主机<code>2200</code>端口。</li><li>创建一个共享文件夹用于虚拟机与主机间的文件共享。</li><li>安装了拓展包使虚拟机支持 USB2.0 以及 USB3.0 设备。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
