<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust Journey - Part1</title>
      <link href="/2025/08/03/Rust-Journey-Part-1/"/>
      <url>/2025/08/03/Rust-Journey-Part-1/</url>
      
        <content type="html"><![CDATA[<p>诸如在任何一门其他的编程语言中存在的变量、基础数据类型、函数、流程控制以及注释这些基础概念，在 Rust 语言中同样存在。这一篇中来介绍在 Rust 语境中这些概念的用法。</p><span id="more"></span><h2 id="变量及可变性"><a href="#变量及可变性" class="headerlink" title="变量及可变性"></a>变量及可变性</h2><h3 id="let-变量"><a href="#let-变量" class="headerlink" title="let 变量"></a>let 变量</h3><p>默认情况下，Rust 中的变量是不可变的。听上去有点反直觉，但是这是 Rust 建议的做法。同时 Rust 也提供了方法让变量可变。</p><p>我们通过 <code>cargo new variables</code> 创建一个新项目来探索一下可变性的概念，在 <em>src&#x2F;main.rs</em> 中写上如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存然后编译会发现有报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">2 |     let x = 5;</span><br><span class="line">  |         - first assignment to `x`</span><br><span class="line">3 |     println!(&quot;The value of x is: &#123;x&#125;&quot;);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line">  |</span><br><span class="line">help: consider making this binding mutable</span><br><span class="line">  |</span><br><span class="line">2 |     let mut x = 5;</span><br><span class="line">  |         +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br><span class="line">error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure><p>错误信息当中，已经明确说明了：<code>cannot assign twice to immutable variable</code>，我们给一个不可变变量第二次赋值，所以报错。这里值得注意的是这个错误报在了编译期间，Rust 在编译的时候检查出了写的代码和我们的意图不一致，因为变量 <em>x</em> 是不可变的，但是我们却在给它第二次赋值。所以 Rust 保证的是如果我们希望一个变量是不可变的那么它一定不会被修改。</p><p>但是，变量可变同样对程序员很重要，因为写程序会方便一些。我们可以在定义变量的时候在变量名之前加一个关键字 <code>mut</code> 来表达意图：这个变量是可变的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><p>当希望将绑定在 <code>x</code> 上的值从 <code>5</code> 改为 <code>6</code> 就必须使用 <code>mut</code>。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>和不可变变量一样，常量绑定的值也不可修改的。但是，它们之间也有一些不同的地方。首先不能在常量前加 <code>mut</code>，常量永远都是不可变的；第二，定义常量用的是 <code>const</code> 而不是 <code>let</code>；第三，定义常量时必须同时指定数据类型；第四，常量可以定义在任意作用范围包括全局作用范围，而变量只能定义在函数内部；最后，常量只能用常量表达式来初始化，也就是定义常量的值必须是能够在编译阶段就决定的而不是在运行时。</p><p>定义常量的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这里，常量的名称是 <code>THREE_HOURS_IN_SECONDS</code>，其值为 60 乘以 60 乘以 3。Rust 中命名常量的习惯是用全大写字符和下划线。</p><p>在整个程序的运行期间，常量在其定义的作用范围中都是有效的。这样当我们需要在程序的多个部分都使用同一个值时，使用常量就会很方便，并切含义一致。</p><h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p>当定义后一个变量时使用前一个变量的名称，我们就说后一个变量遮蔽（shadow）了前一个变量。对于编译器来说在此之后它就只会看到第二个变量。那什么时候这个作用会消失呢？那就有 2 种情况，第一，第二个变量继续被第三个变量遮蔽；第二，第二个变量的作用域结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，我们首先绑定 <code>x</code> 到 <code>5</code> 上，然后重复用 <code>let x = </code> 创建了一个新变量 <code>x</code>，此时的 <code>x</code> 遮蔽了之前的 <code>x</code>。同时绑定到值 <code>5 + 1</code> 也就是 <code>6</code>。在花括号内部，我们继续创建第三个新变量 <code>x</code>，绑定值到 <code>6 * 2</code> 也就是 <code>12</code>，同时遮蔽了第一和第二个 <code>x</code>，当花括号结束后，第三个 <code>x</code> 超出作用域，于是遮蔽失效，编译器就看到了第二个 <code>x</code>，其值就是 <code>6</code>。</p><p>运行这段代码，结果就是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:<span class="comment">///projects/variables)</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.31</span>s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: <span class="number">12</span></span><br><span class="line">The value of x is: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>和 <code>mut</code> 不同的是，如果我们意外给 <code>x</code> 重新赋值，而没有用 <code>let</code> 来遮蔽，那么编译器就会报错，因为 <code>x</code> 是不可修改的。另外一点是，因为我们实际上是创建一个新的变量 <code>x</code> 所以第二个 <code>x</code> 的类型是可以和第一个 <code>x</code> 不一样的，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 Rust 中的每一个值都有一个特定的类型，这样 Rust 就知道如果处理这个值。在 Rust 中，基本数据类型可以分为 2 种：标量和复合类型。</p><p>Rust 是一门静态类型语言，这表示必须在编译阶段就知道所有变量的类型。Rust 编译器同时也很强大，可以在编译的时候通过变量的值以及我们r如何使用变量来推断其类型。当遇到一个值可能会出现多种类型时，例如，将字符串转换成数字时，得到的结果可能是很多类型（i32，u32等），此时我们就必须显示标记变量类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果没有标记类型，那么在编译的时候就会报错，提示我们编译器不知道具体要使用哪种类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)</span><br><span class="line">error[E0284]: type annotations needed</span><br><span class="line"> --&gt; src/main.rs:2:9</span><br><span class="line">  |</span><br><span class="line">2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</span><br><span class="line">  |         ^^^^^        ----- type must be known at this point</span><br><span class="line">  |</span><br><span class="line">  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`</span><br><span class="line">help: consider giving `guess` an explicit type</span><br><span class="line">  |</span><br><span class="line">2 |     let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</span><br><span class="line">  |              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0284`.</span><br><span class="line">error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>标量类型用来表示单个值。在 Rust 中有 4 种基本的标量类型：整型、浮点型、布尔型以及字符。</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型是不带小数的数字。下表中列出了 Rust 中自带的所有整型类型：</p><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>architecture dependent</td><td>isize</td><td>usize</td></tr></tbody></table><p>其中，<code>isize</code>、<code>usize</code> 类型依赖于程序运行的电脑上的 CPU 架构。例如 CPU 是 64bit 的那么它们的大小就是 64 位。</p><p>在程序中书写整型可以使用以下格式中的任一种：</p><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody><tr><td>Decimal</td><td>98_222</td></tr><tr><td>Hex</td><td>0xff</td></tr><tr><td>Octal</td><td>0o77</td></tr><tr><td>Binary</td><td>0b1111_0000</td></tr><tr><td>Byte(<code>u8</code> only)</td><td>b’A’</td></tr></tbody></table><p>还能在数字字面值的后面加上后缀，例如 <code>57u8</code>，去指定类型。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Rust 也有 2 中基本的浮点数类型：<code>f32</code> 和 <code>f64</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点数遵循 IEEE-754 标准。</p><h4 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h4><p>Rust 支持所有基本的数学运行操作：加减乘除以及取余。整数除法会丢掉商的小数部分。下面是一个做数学运算的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// addition</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subtraction</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span> - <span class="number">4.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiplication</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// division</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span> / <span class="number">32.2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">truncated</span> = -<span class="number">5</span> / <span class="number">3</span>; <span class="comment">// Results in -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remainder</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remainder</span> = <span class="number">43</span> % <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>和大多数其他编程语言一样，在 Rust 中布尔类型有 2 种可能的值：<code>true</code> 以及 <code>false</code>。布尔值在大小上占用一个字节。在 Rust 中用 <code>bool</code> 表示布尔型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用布尔型值的场景是条件判断，比如在 <code>if</code> 表达式中使用。</p><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>Rust 的字符类型是语言中最基本的字母类型。以下是一些字符类型变量的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用单引号指定 <code>char</code> 字面量，而字符串字面量则使用双引号。Rust 的 <code>char</code> 类型大小为 4 个字节，表示 Unicode 标量值，这意味着它不仅可以表示 ASCII 码，还可以表示很多其他字符。在 Rust 中，重音字母、中文、日文和韩文字符、表情符号和零宽度空格都是有效的字符值。Unicode 标量值的范围为 <code>U+0000</code> 至 <code>U+D7FF</code> 和 <code>U+E000</code> 至 <code>U+10FFFF</code>（含）。不过，“字符”在 Unicode 中并不是一个真正的概念，所以我们在直觉上对“字符”的理解可能与 Rust 中的字符不一致。我们将在后面详细讨论这个问题。</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>复合类型可以将多个值组合在一个类型中。Rust 中有 2 个基本的复合类型：元组和数组（tuple and array）。</p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组用于将不同类型的值放在一起组合成一个类型。元组具有固定长度，也就是一旦定义它的大小就不能改变。</p><p>定义元组可以用以下方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将不同类型在圆括号中用逗号隔开。类型可以相同也可以不同。</p><p>上面定义的 <code>tup</code> 变量绑定到整个元组，因为元组被视为单个元素。如果想获取元组中的单个值，我们可以使用模式匹配来取消元组组合：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还能直接通过 <code>.</code> 后面跟上一个索引值来访问对应的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不包含任何值的元组具有特别的含义，称为 <em>unit</em>。它的值以及类型都写作 <code>()</code> 用来表示一个空值或者空回返类型。任何表达式如果不返回其他任何值那么它就隐式返回 unit 值。</p><p>我们还可以单独修改可变元组中的一个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">i32</span>) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    x.<span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">    x.<span class="number">1</span> += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>将多个值放在一个集合中的另外一种方式就是数组。和元组不同的是，在数组中的每一个元素的类型必须相同；和部分其他编程语言中的数组不同的是 Rust 中的数组是固定长度的。</p><p>数组的值用在方括号中以逗号将各个元素列出的方式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们遇到以下场景的时候数组就很有用：</p><ul><li>将一组数据分配在栈上而不是堆上</li><li>在使用一组数据时希望它的元素个数是固定的</li></ul><p>我们这样来表达数组的类型：方括号里面先写元素类型，紧接着跟上一个分号，最后写上元素个数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>初始化一个每个元素值都是相同的数组可以用一个简便写法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这样写的效果和 <code>let a = [3, 3, 3, 3, 3];</code> 是一样的。</p><h5 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h5><p>和绝大多数编程语言一致，Rust 中数组元素的访问也用方括号里写上元素索引来表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组的非法访问"><a href="#数组的非法访问" class="headerlink" title="数组的非法访问"></a>数组的非法访问</h5><p>当我们越界访问数组的元素在 Rust 中会发生什么呢？下面这个程序示范了这种情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of the element at index &#123;index&#125; is: &#123;element&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码能编译通过，但是在执行程序时，如果我们提供输入为 <code>10</code> 的时候就会发生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:19:19:</span><br><span class="line">index out of bounds: the len is 5 but the index is 10</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>程序在索引操作中使用无效值时出现运行时错误。程序带着错误信息退出，并且没有执行最后的 <code>println!</code> 当你尝试使用索引访问元素时，Rust 会检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 就会触发 panic 机制。这种检查必须在运行时进行，因为编译器不可能提前知道用户稍后运行代码时会输入什么值。</p><p>这是 Rust 内存安全原则发挥作用的一个例子。在许多底层语言中，这种检查是不存在的，当你提供了一个不正确的索引时，无效的内存就会被访问。而 Rust 会立即退出，而不是允许访问内存并继续，从而防止出现这种错误。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数在 Rust 中很常见，我们已经看到过一个函数就是 <code>main</code> 它也是整个程序的入口。<code>fn</code> 关键字用于定义一个函数。在 Rust 中使用 snake 命名法来命名函数名和变量名，也就是这些名字都用小写字母加下划线，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数时用 <code>fn</code> 加上一个函数名字以及一对圆括号，之后再跟上一对花括号用于告诉函数体的开始和结束。调用函数时，使用函数名字后面跟上一对圆括号。在 Rust 中不需要关心函数定义的位置，都能调用。只要函数定义的作用域中调用这能看到即可。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>定义的函数可以同时定义形式参数，参数是函数签名的一部分。在调用函数时，可以通过圆括号传入实际参数，但是为了方便描述，一般不去区分形式参数和实际参数。我们为上面定义的 <code>another_function</code> 加一个参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling functions v0.<span class="number">1.0</span> (file:<span class="comment">///projects/functions)</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">1.21</span>s</span><br><span class="line">     Running `target/debug/functions`</span><br><span class="line">The value of x is: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>在函数的签名当中，定义每个参数时必须指明其类型，这是故意设计的，因为编译器很难知道在另外一个地方使用定义的函数时所需的参数类型是怎样的。</p><p>定义多个函数参数可以用逗号隔开：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_labeled_measurement</span>(<span class="number">5</span>, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_labeled_measurement</span>(value: <span class="type">i32</span>, unit_label: <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The measurement is: &#123;value&#125;&#123;unit_label&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>函数体由一系列的语句组成，并且可以用一个表达式作为结束。目前我们还没有遇到用表达式作为函数体结束的情况。因为 Rust 是一门居于表达式的语言，这是一个很重要的区别，其他语言则没有这样的区分。首先来看看语句和表达式的差异，以及如何影响函数体：</p><ul><li>语句是一条指令，用于执行命令不会产生返回值</li><li>表达式会产生返回值</li></ul><p>用 <code>let</code> 关键字定义一个变量和用 <code>fn</code> 关键字定义一个函数都是语句（调用函数不是语句）。因为语句没有返回值，所以我们不能将 <code>let</code> 语句赋值给其他变量，如下，会产生编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误大概是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">error: expected expression, found `let` statement</span><br><span class="line"> --&gt; src/main.rs:2:14</span><br><span class="line">  |</span><br><span class="line">2 |     let x = (let y = 6);</span><br><span class="line">  |              ^^^</span><br><span class="line">  |</span><br><span class="line">  = note: only supported directly in conditions of `if` and `while` expressions</span><br><span class="line"></span><br><span class="line">warning: unnecessary parentheses around assigned value</span><br><span class="line"> --&gt; src/main.rs:2:13</span><br><span class="line">  |</span><br><span class="line">2 |     let x = (let y = 6);</span><br><span class="line">  |             ^         ^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_parens)]` on by default</span><br><span class="line">help: remove these parentheses</span><br><span class="line">  |</span><br><span class="line">2 -     let x = (let y = 6);</span><br><span class="line">2 +     let x = let y = 6;</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">warning: `functions` (bin &quot;functions&quot;) generated 1 warning</span><br><span class="line">error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error; 1 warning emitted</span><br></pre></td></tr></table></figure><p>语句 <code>let y = 6</code> 没有返回值，所以 <code>x</code> 没法绑定任何值，这在如 <code>C</code> 和 <code>Ruby</code> 之类的变成语言中是不一样的。在这些语言中赋值操作本身会产生被赋值的值，所以在这些语言中可以使用连续赋值操作：<code>x = y = 6</code>，在 rust 中没有这样的操作。</p><p>表达式的形式有如下几种，但不限于：</p><ul><li>数学运算：<code>5 + 6</code></li><li>语句 <code>let y = 6;</code> 中的 <code>6</code></li><li>调用函数</li><li>调用宏</li><li>一个新定义的 scope block，例如</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个块，最终会得到 <code>4</code> 这个值，<code>4</code> 有会绑定到 <code>y</code> 上，作为 <code>let</code> 语句的组成部分。注意，<code>x + 1</code> 这里是没有结束时的分号，因为表达式不带分号，如果加上分号就变成了语句，也就意味着不会产生返回值了。</p><h3 id="带返回值的函数"><a href="#带返回值的函数" class="headerlink" title="带返回值的函数"></a>带返回值的函数</h3><p>函数会返回一个值给其调用者。函数的返回值不用命名，但是我们必须用 <code>-&gt;</code> 指定返回值的类型。在 Rust 中函数的返回值和函数体中最后一行表达式的值是一致的。我们也可以用 <code>return</code> 关键字来提前让函数返回同时提供返回值，但大多数情况下都隐式地用最后一行表达式的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>five</code> 函数中除了一个 <code>5</code> 表达式其余什么都没有，这在 rust 中也是完全合法的。可以看到函数的返回值类型通过 <code>-&gt; i32</code> 来指定了，运行代码可以得到如下结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling functions v0.<span class="number">1.0</span> (file:<span class="comment">///projects/functions)</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.30</span>s</span><br><span class="line">     Running `target/debug/functions`</span><br><span class="line">The value of x is: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>一些需要注意的细节：</p><ul><li>因为 <code>five</code> 的返回值是 <code>5</code>，所以返回值类型是 <code>i32</code></li><li>语句 <code>let x = five();</code> 用函数的返回值来初始化变量，所以和语句 <code>let x = 5;</code> 的效果一样</li><li><code>five</code> 没有定义形参，但定义了返回值类型；<code>5</code> 后面没有分号，所以这个表达式的值可以作为函数的返回值</li></ul><p>再看一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码会在屏幕上打印出：<code>The value of x is: 6</code>，但如果在 <code>x + 1</code> 后面加上分号，也就是将表达式改为了语句，那么我们会得到一个编译错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling functions v0.1.0 (file:///projects/functions)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:7:24</span><br><span class="line">  |</span><br><span class="line">7 | fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">  |    --------            ^^^ expected `i32`, found `()`</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">8 |     x + 1;</span><br><span class="line">  |          - help: remove this semicolon to return this value</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure><p>这段报错信息指出了一个核心信息就是 <code>mismatched types</code>，<code>plus_one</code> 函数定义的返回值类型是 <code>i32</code>，但是语句没有返回值，函数没有返回值时会隐式返回 <code>()</code> 其类型为单元类型，于是报出了类型不匹配错误。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>编程人员会尽力写出容易理解的代码，但是代码有时候需要有额外的解释，这时编程人员会在代码中留下<em>注释</em>给其他人看。编译器在编译期间会忽略注释。</p><p>单行注释如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello, world</span></span><br></pre></td></tr></table></figure><p>多行注释如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// So we&#x27;re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">// explain what&#x27;s going on.</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>/*</code> 和 <code>*/</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* So we’re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">   multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">   explain what’s going on. */</span></span><br></pre></td></tr></table></figure><p>也可以和代码写在同一行中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>; <span class="comment">// I&#x27;m feeling lucky today</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 还提供一种称为<em>文档注释</em>的注释，这个在后面讨论。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust Journey - Part0</title>
      <link href="/2025/07/26/Rust-Journey-Part-0/"/>
      <url>/2025/07/26/Rust-Journey-Part-0/</url>
      
        <content type="html"><![CDATA[<p>Rust Programming language 是一个相对年轻的编程语言（和 C 比较起来的话）也是一门潜力十足的语言。甚至不能说是“潜力”了，因为在产业中已经有很多应用的案例，比如最近的 DebConf25 大会上 Fabian 指出，Debian Sid 中大约有 8% 的源码包至少基于一个 librust* 包进行构建；又比如 Ubuntu 正在积极探索将基于 Rust 编写的 uutils 用于替换 GNU Core Utilities。</p><p>另外，Rust 语言本身的功能和特性也趋于稳定，其工具链也相当成熟了，同时 Rust 社区也是非常的活跃。还有就是 Linus 也比较支持 Rust 进入 Linux Kernel（虽然年初的时候发生了好几起有争议的事件）。基于以上，我觉得现在是一个很好的学习 Rust 的时机。</p><span id="more"></span><p>学习一门新语言当然要从搭建环境开始。正好今年购入一台 M4 的 MacBook Air，所以就在 MacOS 的环境中搭建 Rust 编程环境。</p><h2 id="Rust-Rover"><a href="#Rust-Rover" class="headerlink" title="Rust Rover"></a>Rust Rover</h2><p>JetBrain 是 IDE 领域的龙头，他家的系列编程 IDE 都非常的好用，例如针对 C&#x2F;C++ 开发人员推出的 Clion，针对 Go 开发人员的 GoLand。这次我使用的 Rust Rover 也是他家推出的。正好最近免费了（个人非商业用途），于是尝试一下。</p><p>直接从官方网站下载即可：<a href="https://www.jetbrains.com/rust/">Rust Rover</a>。Mac 用户下载时注意区分一下 CPU 类型（Apple silicon &#x2F; Intel）。</p><h2 id="Rust-toolchian"><a href="#Rust-toolchian" class="headerlink" title="Rust toolchian"></a>Rust toolchian</h2><p>安装 Rust 语言的工具链也很简单，打开终端，键入如下命令再敲回车即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p>此外，如果 Mac 上没有安装过开发工具那么需要再执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br></pre></td></tr></table></figure><p>安装之后 Mac 上就有了 C&#x2F;C++ compiler 以及 linker 了。Rust 的工具链依赖这个。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h2><p>准备工作做好之后就可以开始我们的 Rust 之旅了。</p><h3 id="创建一个目录"><a href="#创建一个目录" class="headerlink" title="创建一个目录"></a>创建一个目录</h3><p>任何一个项目都需要创建一个目录便于管理文件，Rust 项目也不例外。这个项目目录在哪里无管紧要，重要的是需要这样一个目录。</p><p>打开终端，键入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/projects</span><br><span class="line">$ cd ~/projects</span><br><span class="line">$ mkdir hello_world</span><br><span class="line">$ cd hello_world</span><br></pre></td></tr></table></figure><h3 id="编写并运行程序"><a href="#编写并运行程序" class="headerlink" title="编写并运行程序"></a>编写并运行程序</h3><p>首先在不使用 IDE 的情况下写一个程序，可以熟悉一下编译 Rust 程序的操作流程。Rust 程序源码文件总是用 <code>.rs</code> 结尾的。现在创建并打开 <code>main.rs</code> 文件并输入如下源码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并关闭文件之后回到终端里，进入目录 <code>~/projects/hello_world</code>，输入如下命令来编译和运行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>到这里，我们就编写了第一个 Rust 程序。</p><h2 id="Rust-程序的构成"><a href="#Rust-程序的构成" class="headerlink" title="Rust 程序的构成"></a>Rust 程序的构成</h2><p>让我们更仔细地看一下 “Hello, world!” 程序的构成。首先是如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行定义了一个名称为 <code>main</code> 的函数，<code>main</code> 函数比较特殊它是每个 Rust 程序执行的入口。这里定义的 <code>main</code> 函数没有形式参数以及返回值。如果一个函数有形式参数的话，这些参数会定义在圆括号内。</p><p>函数的函数体被包含在 <code>&#123;&#125;</code> 里。Rust 中要求所有的函数体都包含在花括号内。同时，一个比较好的编码风格是将花括号的第一个写在函数名的同一行，并且隔开一个空格。此外，如果懒得去注意这些编码风格，可以直接使用 Rust 工具链中自带的 <code>rustfmt</code> 程序来自动规范编码风格（当然使用 IDE 的话，IDE 基本都带自动 format 功能）。</p><p>我们的程序里，函数体里只有一行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>这行代码就实现了全部功能——打印文字到终端输出上。这里虽然只有一行代码，但是却需要注意3点：</p><p>第一，<code>println!</code> 调用的是 Rust 的<strong>宏</strong>，如果 <code>println</code> 是个函数的话，那么调用它应该直接用 <code>println</code>（没有感叹号）。目前我们只需要知道宏也是 Rust 的代码，但是这类代码是通过生成代码来拓展 Rust 语法的。调用宏需要使用感叹号，而调用函数不需要。</p><p>第二，<code>Hello, world!</code> 是一个字符串，我们把这个字符串作为参数传给了 <code>println!</code>。</p><p>第三，在这行的结尾处使用了分号，用于表示表达式的结束以及下一个表达式的开始。绝大多数的 Rust 代码都用分号结尾。</p><p>对于简单的程序，我们使用 <code>rustc</code> 来编译就够了，但是随着项目的开发我们需要一个工具来帮助我们管理各种选项甚至是和其他人共同开发，这就是 <code>Cargo</code> 的作用。使用它可以帮助我们写出 <code>real-world</code> Rust 程序。</p><h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p><code>Cargo</code> 是一个工具用来编译 Rust 项目以及进行包管理。因为 Cargo 可以简化很多操作包括但不限于以下：</p><ul><li>编译项目源码</li><li>自动下载并编译项目依赖的库</li></ul><p>所以几乎所有 Rust 程序员都会在项目中使用这个工具。像我们前面写的简单项目，只能用到 Cargo 的部分功能（编译），但随着项目的逐渐变大需要用到第三方库时，使用 Cargo 就能简化这个过程。</p><p>前面我们在安装 Rust 工具链中已经包含了 Cargo，可以执行以下命令来确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo --version</span><br></pre></td></tr></table></figure><h3 id="使用-Cargo-来创建项目"><a href="#使用-Cargo-来创建项目" class="headerlink" title="使用 Cargo 来创建项目"></a>使用 Cargo 来创建项目</h3><p>这次我们用 Cargo 来创建一个“Hello, world!”项目，看看和前文创建的项目有什么不一样。回到我们的项目目录下，同时执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_cargo</span><br><span class="line">$ cd hello_cargo</span><br></pre></td></tr></table></figure><p>第一行命令会创建一个新的目录名叫 <code>hello_cargo</code> 同时这也是项目的名字，Cargo 会在这个目录下自动创建相应的项目文件。</p><p>进入这个目录当中同时列出所有的文件，我们会看到 Cargo 创建了 2 个文件以及一个目录：</p><ul><li>Cargo.toml</li><li>src</li><li>src&#x2F;main.rc</li></ul><p>同时 Cargo 会初始化一个 git 仓库。需要注意的是如果指定的目录下已经存在一个 git 仓库了 Cargo 就不会执行这个动作。</p><p>打开 <code>Cargo.toml</code> 文件，我们可以看到以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2024&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>此文件是 Cargo 的配置文件，采用 TOML 文件格式。<code>[package]</code> 是配置段的头，表示之后的内容用于配置此软件包。后面的三行表示这个软件包的配置内容，例如，软件包的名字、版本信息以及使用什么版本的 rustc 来编译源代码。</p><p>最后一个行 <code>[dependencies]</code> 表示依赖段，我们可以将项目依赖的其他包列在这里。在 Rust 中一般把软件包称作 <em>crates</em>。目前这个项目还不依赖任何软件包，所以这个可以留空。</p><p>现在打开 <code>src/main.rs</code> 看看：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cargo 自动生成了一个程序和我们之前写的一模一样。到目前 Cargo 生成的项目和之前的项目不同的地方在于源码文件 <code>main.rs</code> 放在了 <code>src</code> 目录中以及多了一个 <code>.toml</code> 文件。</p><p>使用 Cargo 来组织项目文件的话，最好把源代码文件都放在 src 目录下，而项目顶层目录可以放一些和源码无关的文件，例如：README、授权信息文件、配置文件等。</p><h3 id="编译和运行-Cargo-项目"><a href="#编译和运行-Cargo-项目" class="headerlink" title="编译和运行 Cargo 项目"></a>编译和运行 Cargo 项目</h3><p>通过 Cargo 来编译项目只需要执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs</span><br></pre></td></tr></table></figure><p>这条命令会编译出一个可执行文件 <code>target/debug/hello_cargo</code>。因为默认是编译 debug 文件，所以路径是 debug 下。这个文件可以直接执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>可以看到终端中输出了“Hello, world!”。当第一次执行 <code>cargo build</code> 时，Cargo 会创建一个 <em>Cargo.lock</em> 文件，这个文件用于记录目录使用的第三方库的版本，我们不用自己去维护这个文件，交给 Cargo 就好。</p><p>我们也可以直接执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running `target/debug/hello_cargo`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>来运行编译之后的文件。可以看到这次没有编译项相关的输出，这是因为我们没有修改源码，Cargo 判断出不需要重新编译。但是如果我们修改了源码，再执行这个条命令的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs</span><br><span class="line">     Running `target/debug/hello_cargo`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>Cargo 就会重新编译代码之后再执行程序。</p><p>另外，Cargo 还提供了一个 check 命令。这个命令的作用是确保源代码没有错误可以编译通过，但不会创建可执行文件，这样就比 <code>cargo build</code> 要执行得快一些。</p><p>总结一下 Cargo 的用法：</p><ul><li>创建项目用：<code>cargo new</code></li><li>编译项目用：<code>cargo build</code></li><li>编译并运行项目用：<code>cargo run</code></li><li>确保项目没有错误用：<code>cargo check</code></li></ul><h3 id="编译-Release-目标文件"><a href="#编译-Release-目标文件" class="headerlink" title="编译 Release 目标文件"></a>编译 Release 目标文件</h3><p>当项目最后需要释放了，就可以使用 <code>cargo build --release</code> 来编译目标文件，这个命令会需要更多的时间来执行，但是会优化代码使得最终的可执行文件运行效率更高。同时这个可执行文件在目录 <em>target&#x2F;release</em> 中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 WSL 中访问 U 盘</title>
      <link href="/2023/09/17/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E8%AE%BF%E9%97%AE-U-%E7%9B%98/"/>
      <url>/2023/09/17/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E8%AE%BF%E9%97%AE-U-%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>在 WSL 中可以通过 <code>/mnt/</code> 目录很方便地访问 Windows 主机的文件系统，但是如果我们 PC 上接 U 盘，这个 U 盘只能在 Windows 系统里访问而不能在 WSL 里访问。如果想要在 WSL 中使用 <code>dd</code> 命令读写 U 盘或者挂载 U 盘到 WSL 系统，则需要让 USB 设备连接到 WSL，但是默认情况下 WSL 不支持这种操作所以我们需要对 WSL 进行一些修改。</p><span id="more"></span><h2 id="自己编译内核"><a href="#自己编译内核" class="headerlink" title="自己编译内核"></a>自己编译内核</h2><p>首先需要做的是编译自己的 WSL 内核并且让 WSL 使用我们自己编译的内核，具体的操作步骤可参考这篇：<a href="/2023/09/16/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97">如何在 WSL 中编译加载内核模块</a>。</p><p>在编译之前需要通过 <code>make menuconfig</code> 配置内核，将 USB 存储相关的驱动打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">     ---&gt; USB support</span><br><span class="line">          ---&gt; USB Mass Storage support</span><br></pre></td></tr></table></figure><h2 id="安装-usbip"><a href="#安装-usbip" class="headerlink" title="安装 usbip"></a>安装 usbip</h2><p>usbip 是一个服务程序，它可以将 USB 协议通过网络转发，从而实现将一个设备的 USB 设备通过网络转发到另外一台设备。同样我们可以利用这个程序将 USB 设备从 Windows 主机通过本地网络转发到 WSL 系统。</p><h3 id="Windows-上的操作"><a href="#Windows-上的操作" class="headerlink" title="Windows 上的操作"></a>Windows 上的操作</h3><p>我们需要安装 <code>usbipd</code> 这个服务，可以通过下载安装包的方式，也可以通过 <code>winget</code> 安装，我使用后一种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure><h3 id="WSL-中的操作"><a href="#WSL-中的操作" class="headerlink" title="WSL 中的操作"></a>WSL 中的操作</h3><p>直接通过 Ubuntu 的软件仓库安装并启用 <code>usbip</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-tools-generic hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20</span><br></pre></td></tr></table></figure><h2 id="usbip-的使用"><a href="#usbip-的使用" class="headerlink" title="usbip 的使用"></a>usbip 的使用</h2><h3 id="Windows-上的操作-1"><a href="#Windows-上的操作-1" class="headerlink" title="Windows 上的操作"></a>Windows 上的操作</h3><p>首先将 U 盘插入到 PC 上，然后使用管理员权限打开 Windows PowerShell，输入以下命令：</p><p>列出所有可用的 USB 设备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl list</span><br></pre></td></tr></table></figure><p>会得到类似如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUSID  VID:PID    DEVICE                                                        STATE</span><br><span class="line">1-3    04f2:b569  Integrated Camera                                             Not attached</span><br><span class="line">1-4    138a:0011  Synaptics FP Sensors (WBF) (PID=0011)                         Not attached</span><br><span class="line">1-7    8087:0a2a  英特尔(R) 无线 Bluetooth(R)                                    Not attached</span><br><span class="line">3-2    05e3:0736  USB 大容量存储设备                                             Not attached</span><br></pre></td></tr></table></figure><p>可以看到 BUSID <code>3-2</code> 就是我们的 U 盘，然后就可以把它加入到 WSL 中了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl attach --busid 3-2</span><br></pre></td></tr></table></figure><h3 id="WSL-中的操作-1"><a href="#WSL-中的操作-1" class="headerlink" title="WSL 中的操作"></a>WSL 中的操作</h3><p>使用 <code>lsusb</code> 查看 USB 设备是否已经连接到了 WSL 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 05e3:0736 Genesys Logic, Inc. Colour arc SD Card Reader [PISEN]</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>这个 <code>Bus 001</code> 就是我们的 U 盘，说明已经成功连上 USB 设备了。</p><p>然后通过 <code>lsblk</code> 查看是否有新的存储设备出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sdd      8:48   1   7.2G  0 disk</span><br><span class="line">└─sdd1   8:49   1   7.2G  0 part</span><br></pre></td></tr></table></figure><p>说明 USB 存储设备也成功识别了。接下来我们就可以通过 <code>dd</code> 命令进行镜像烧写，或者在 U 盘中已经有文件系统的情况下，挂载 U 盘到 WSL 从而进行文件访问。</p><p>在 WSL 中使用完 U 盘之后，我们需要回到 Windows 系统将 U 盘取消连接，同样在 powershell 中输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl detach --busid 3-2</span><br></pre></td></tr></table></figure><p>就可以取消连接 WSL。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 WSL 中编译加载内核模块</title>
      <link href="/2023/09/16/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/09/16/%E5%A6%82%E4%BD%95%E5%9C%A8-WSL-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Windows 系统中集成的 WSL 子系统非常好用，特别是到了 WSL2 这个版本，配合 Ubuntu 发行版可以应付绝大多数工作需求。但是这个系统中使用的内核是微软提供的，不允许加载内核模块，导致自己编译的模块无法使用。如果想要加载内核模块则需要自己编译内核供 WSL 使用。</p><span id="more"></span><h2 id="编译-WSL-内核"><a href="#编译-WSL-内核" class="headerlink" title="编译 WSL 内核"></a>编译 WSL 内核</h2><p>我们可以从微软的<a href="https://github.com/microsoft/WSL2-Linux-Kernel">开源仓库</a>中拉取最新的内核源码，然后自己编译内核。</p><p>拉取源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/microsoft/WSL2-Linux-Kernel.git</span><br></pre></td></tr></table></figure><p>配置内核：</p><p>这里直接使用微软的默认配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv Microsoft/config-wsl ./.config</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><h2 id="WSL-启动新编译内核"><a href="#WSL-启动新编译内核" class="headerlink" title="WSL 启动新编译内核"></a>WSL 启动新编译内核</h2><p>将新编译好的内核拷贝到任意位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp arch/x86_64/boot/bzImage /mnt/c/Users/uklar/</span><br></pre></td></tr></table></figure><p>在启动 WSL 的用户的根目录中创建 WSL 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /mnt/c/Users/uklar/.wslconfig</span><br></pre></td></tr></table></figure><p>同时将如下内容写入配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">kernel=C:\\Users\\uklar\\bzImage</span><br></pre></td></tr></table></figure><p>这里的配置就是指定 WSL 启动使用的内核。</p><p>关闭 WSL 再启动，以生效更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>hello.c 程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/printk.h&gt;</span><br><span class="line"></span><br><span class="line">static int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Hello, world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Goodbye, world\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure><p>Makefile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">PWD := $(CURDIR)</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C /home/uklar/WSL2-Linux-Kernel M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        make -C /home/uklar/WSL2-Linux-Kernel M=$(PWD) clean</span><br></pre></td></tr></table></figure><p><em>注意：这里要使用自己下载的内核源码的路径。</em></p><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>此时我们会得到 <code>hello.ko</code></p><p>使用 <code>sudo insmod hello.ko</code> 测试是否可以加载模块，在 <code>dmesg</code> 命令的输出中我们可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[11114.649475] Hello, world</span><br></pre></td></tr></table></figure><p>说明此时内核模块已经成功加载了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> Kernel Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘一道面试算法题</title>
      <link href="/2023/06/08/%E5%A4%8D%E7%9B%98%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2023/06/08/%E5%A4%8D%E7%9B%98%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近面试一个开发岗位，遇到一道算法题，现场我只给出了思路，没能在规定时间里写出代码也就没法现场验证，在这里复盘一下。</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>只能回忆起部分内容，大致是，从一个给定的字符串中找出最长的重复的子串。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假定输入字符串是 <code>asdfddfbiibhddf234</code>，长度为 18 个字符。</p><ol><li>子串：长度至少要为 1 个字符，最大 17 个字符。</li><li>重复子串：当确定以一个子串，如以 <code>asd</code> 为目标寻找重复子串，那么寻找的范围必须是输入字符串中 <code>a</code> 字符之后的部分。</li><li>需要遍历所有情况。</li></ol><p>基于以上 3 条规则，我们可以得出如下思路：</p><ol><li>利用双重循环遍历所有可能出现的子串。</li><li>使用 <code>strstr</code> 从输入字符串的子串首字母之后的部分中寻找是否有重复子串。</li><li>更新最长子串记录。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">substring</span><span class="params">(<span class="type">char</span> *input, <span class="type">char</span> **output)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line">    <span class="type">int</span> in_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *tmp;</span><br><span class="line">    tmp = <span class="built_in">malloc</span>(in_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重循环负责遍历所有子串</span></span><br><span class="line">    <span class="comment">// j 从 i+1 开始保证子串最短为 1 个字符</span></span><br><span class="line">    <span class="comment">// j &lt; in_len 保证子串最大为 in_len-1 个字符</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; in_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; in_len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子串长度</span></span><br><span class="line">            n = j - i;</span><br><span class="line">            <span class="comment">// 取子串</span></span><br><span class="line">            <span class="built_in">strncpy</span>(tmp, input + i, n);</span><br><span class="line">            tmp[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 从子串首字符之后的剩余部分找重复子串</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(input + i + <span class="number">1</span>, tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; max)</span><br><span class="line">                &#123;</span><br><span class="line">                    *output = input + i;</span><br><span class="line">                    max = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *out;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; input: \&quot;%s\&quot;\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    len = substring(argv[<span class="number">1</span>], &amp;out);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;output: \&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, out[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试字符串：<code>asdfddfbiibhddf234</code><br>结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> input: &quot;asdfddfbiibhddf234&quot;</span><br><span class="line">output: &quot;ddf&quot;</span><br></pre></td></tr></table></figure><p>测试字符串：<code>aaa</code><br>结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> input: &quot;aaa&quot;</span><br><span class="line">output: &quot;aa&quot;</span><br></pre></td></tr></table></figure><p>测试字符串：<code>bbbb</code><br>结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> input: &quot;bbbb&quot;</span><br><span class="line">output: &quot;bbb&quot;</span><br></pre></td></tr></table></figure><p>测试字符串：<code>c</code><br>结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> input: &quot;c&quot;</span><br><span class="line">output: &quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSR 学习笔记 - 第3.1章</title>
      <link href="/2022/11/21/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3-1%E7%AB%A0/"/>
      <url>/2022/11/21/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3-1%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>ROSR 是『RISC-V OS using Rust』的缩写，是由 <a href="https://osblog.stephenmarz.com/">Stephen Marz</a> 在他的系列博客中提供的操作系统开发教程。</p><p>本章描述系统堆内存管理。</p><p>前面章节已经描述过我们通过 QEMU 给整个系统提供了 128M 字节内存空间，ELF 文件加载到内存中后除开代码、全局变量、栈等占用的内存之外，其余部分我们都分配了堆。所以堆的部分就由操作系统来管理分配。</p><p>管理系统堆空间时，分为 3 个部分：</p><ol><li><strong>页分配</strong></li><li>字节分配</li><li>编程内存管理单元</li></ol><p>本 3.1 节主要描述<strong>页分配</strong>。</p><span id="more"></span><p>按页分配表示以页为粒度来分配内存空间，RISC-V 和大多数架构一样最小页空间占用 4096 字节。按页分配的方法有很多，这里采用描述符分配方式。</p><p>在进入正题之前，我们先来看几个重要的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROVIDE(_heap_start = _stack_end);</span><br><span class="line">PROVIDE(_heap_size = _memory_end - _heap_start);</span><br></pre></td></tr></table></figure><p>linker script 提供了 2 个重要符号：堆起始地址（<code>_heap_start</code>）和堆大小（<code>_heap_size</code>），这些符号又通过 <code>mem.S</code> 文件作为全局常量传入 rust：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global HEAP_START</span><br><span class="line">HEAP_START: .dword _heap_start</span><br><span class="line"></span><br><span class="line">.global HEAP_SIZE</span><br><span class="line">HEAP_SIZE: .dword _heap_size</span><br></pre></td></tr></table></figure><p>在 <code>page.rs</code> 的 <code>init</code> 函数中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num_pages</span> = HEAP_SIZE / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">ALLOC_START = <span class="title function_ invoke__">align_val</span>(</span><br><span class="line">                    HEAP_START</span><br><span class="line">                    + num_pages * size_of::&lt;Page,&gt;(),</span><br><span class="line">                    PAGE_ORDER,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一行算出堆内存总共的页数，最后一行算出用于分配的堆内存起始地址。</p><h2 id="描述符分配法"><a href="#描述符分配法" class="headerlink" title="描述符分配法"></a>描述符分配法</h2><p>每次分配都按照连续页分配，并且只存储首页地址。为了达到此目标必须每页内存都有一个字节大小的描述符。此描述符包含 2 种标志：1）此页是否被分配；2）是否为连续分配内存的最后一页。</p><p>由此定义如下数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PageBits</span> &#123;</span><br><span class="line">    Empty = <span class="number">0</span>,</span><br><span class="line">    Taken = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    Last = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    flags: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配内存页"><a href="#分配内存页" class="headerlink" title="分配内存页"></a>分配内存页</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">alloc</span>(pages: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(pages &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_pages</span> = HEAP_SIZE / PAGE_SIZE;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = HEAP_START <span class="keyword">as</span> *<span class="keyword">mut</span> Page;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..num_pages - pages &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="title function_ invoke__">if</span> (*ptr.<span class="title function_ invoke__">add</span>(i)).<span class="title function_ invoke__">is_free</span>() &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> i..i + pages &#123;</span><br><span class="line">                    <span class="title function_ invoke__">if</span> (*ptr.<span class="title function_ invoke__">add</span>(j)).<span class="title function_ invoke__">is_taken</span>() &#123;</span><br><span class="line">                        found = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> found &#123;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">k</span> <span class="keyword">in</span> i..i + pages - <span class="number">1</span> &#123;</span><br><span class="line">                    (*ptr.<span class="title function_ invoke__">add</span>(k)).<span class="title function_ invoke__">set_flag</span>(PageBits::Taken);</span><br><span class="line">                &#125;</span><br><span class="line">                (*ptr.<span class="title function_ invoke__">add</span>(i+pages-<span class="number">1</span>)).<span class="title function_ invoke__">set_flag</span>(PageBits::Taken);</span><br><span class="line">                (*ptr.<span class="title function_ invoke__">add</span>(i+pages-<span class="number">1</span>)).<span class="title function_ invoke__">set_flag</span>(PageBits::Last);</span><br><span class="line">                <span class="title function_ invoke__">return</span> (ALLOC_START + PAGE_SIZE * i)</span><br><span class="line">                       <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">null_mut</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上为内存页分配函数，函数参数为需要的页数。</p><p>第 2 行：判断页数是否有效；<br>第 4 行：算出堆内存空间总页数；<br>第 5 行：将堆起始地址类型转换为可变页指针；<br>第 6～26 行：找出满足要求连续空闲页并分配；<br>第 8～16 行：在第 i 页为空闲的前提下看其后是否有满足所需页数的连续页；<br>第 17～25 行：如果找到了满足所需页数的连续空闲页，将除最后一页的内存页标记为占用，最后一页标记为占用以及尾，并返回页指针。</p><h3 id="回收内存页"><a href="#回收内存页" class="headerlink" title="回收内存页"></a>回收内存页</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">dealloc</span>(ptr: *<span class="keyword">mut</span> <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(!ptr.<span class="title function_ invoke__">is_null</span>());</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">addr</span> =</span><br><span class="line">            HEAP_START + (ptr <span class="keyword">as</span> <span class="type">usize</span> - ALLOC_START) / PAGE_SIZE;</span><br><span class="line">        <span class="built_in">assert!</span>(addr &gt;= HEAP_START &amp;&amp; addr &lt; HEAP_START + HEAP_SIZE);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = addr <span class="keyword">as</span> *<span class="keyword">mut</span> Page;</span><br><span class="line">        <span class="title function_ invoke__">while</span> (*p).<span class="title function_ invoke__">is_taken</span>() &amp;&amp; !(*p).<span class="title function_ invoke__">is_last</span>() &#123;</span><br><span class="line">            (*p).<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            p = p.<span class="title function_ invoke__">add</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">                (*p).<span class="title function_ invoke__">is_last</span>() == <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Possible double-free detected! (Not taken found \</span></span><br><span class="line"><span class="string">                 before last)&quot;</span></span><br><span class="line">        );</span><br><span class="line">        (*p).<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上为内存页回收函数，函数参数为需要回收的页指针。</p><p>第 2 行：判断页指针是否有效；<br>第 4～7 行：算出此页内存所对应的页描述符；<br>第 8～17 行：依次将所有分配的内存页对应的页描述符标记清零，表示设置为未占用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSR 学习笔记 - 第2章</title>
      <link href="/2022/11/11/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0/"/>
      <url>/2022/11/11/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>ROSR 是『RISC-V OS using Rust』的缩写，是由 <a href="https://osblog.stephenmarz.com/">Stephen Marz</a> 在他的系列博客中提供的操作系统开发教程。</p><p>本章描述使用 Rust 的 unsafe 功能操作 MMIO 来控制 UART 进而实现 <code>println!</code> 等宏。</p><span id="more"></span><h2 id="Universal-Asynchronous-Reciever-Transmitter-UART"><a href="#Universal-Asynchronous-Reciever-Transmitter-UART" class="headerlink" title="Universal Asynchronous Reciever &#x2F; Transmitter (UART)"></a>Universal Asynchronous Reciever &#x2F; Transmitter (UART)</h2><p>QEMU 内部虚拟了一个 NS16550A UART 芯片，查看 <a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">qemu&#x2F;hw&#x2F;riscv&#x2F;virt.c</a> 代码可知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry virt_memmap[] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [VIRT_UART0] =        &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过物理地址 0x10000000，即可访问 NS16550A 芯片的寄存器。BTW，这种通过物理地址访问的 IO 被称为 MMIO。</p><p>从下图可以看到发送（THR）接收（RBR）寄存器都是 8 bit（1 byte），我们只要从地址 0x10000000 读取就能从 UART 接收一个字节，向地址 0x10000000 写入就能发送一个字节。</p><p><img src="/2022/11/11/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0/ns16550a.png"></p><h2 id="Rust-中的-MMIO"><a href="#Rust-中的-MMIO" class="headerlink" title="Rust 中的 MMIO"></a>Rust 中的 MMIO</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// # Safety</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// We label the mmio function unsafe since</span></span><br><span class="line"><span class="comment">/// we will be working with raw memory. Rust cannot</span></span><br><span class="line"><span class="comment">/// make any guarantees when we do this.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">unsafe</span> <span class="title function_ invoke__">mmio_write</span>(address: <span class="type">usize</span>, offset: <span class="type">usize</span>, value: <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="comment">// Set the pointer based off of the address</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reg</span> = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write_volatile is a member of the *mut raw</span></span><br><span class="line">    <span class="comment">// and we can use the .add() to give us another pointer</span></span><br><span class="line">    <span class="comment">// at an offset based on the original pointer&#x27;s memory</span></span><br><span class="line">    <span class="comment">// address. <span class="doctag">NOTE:</span> The add uses pointer arithmetic so it is</span></span><br><span class="line">    <span class="comment">// new_pointer = old_pointer + sizeof(pointer_type) * offset</span></span><br><span class="line">    reg.<span class="title function_ invoke__">add</span>(offset).<span class="title function_ invoke__">write_volatile</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// # Safety</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// We label the mmio function unsafe since</span></span><br><span class="line"><span class="comment">/// we will be working with raw memory. Rust cannot</span></span><br><span class="line"><span class="comment">/// make any guarantees when we do this.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">unsafe</span> <span class="title function_ invoke__">mmio_read</span>(address: <span class="type">usize</span>, offset: <span class="type">usize</span>, value: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="comment">// Set the pointer based off of the address</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reg</span> = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read_volatile() is much like write_volatile() except it</span></span><br><span class="line">    <span class="comment">// will grab 8-bits from the pointer and give that value to us.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t add a semi-colon at the end here so that the value</span></span><br><span class="line">    <span class="comment">// is &quot;returned&quot;.</span></span><br><span class="line">    reg.<span class="title function_ invoke__">add</span>(offset).<span class="title function_ invoke__">read_volatile</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rust-UART-驱动"><a href="#Rust-UART-驱动" class="headerlink" title="Rust UART 驱动"></a>Rust UART 驱动</h2><p>UART 驱动包括：</p><ul><li>数据结构用于存储基地址</li><li>初始化方法</li><li>输出一个字符函数（put）</li><li>读取一个字符函数（get）</li><li>实现 Write traits</li></ul><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UartDriver</span> &#123;</span><br><span class="line">    base_address: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加初始化方法"><a href="#增加初始化方法" class="headerlink" title="增加初始化方法"></a>增加初始化方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">UartDriver</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.base_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lcr</span> = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">3</span>).<span class="title function_ invoke__">write_volatile</span>(lcr);</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">2</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">divisor</span>: <span class="type">u16</span> = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">divisor_least</span>: <span class="type">u8</span> = (divisor &amp; <span class="number">0xff</span>) <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">divisor_most</span>:  <span class="type">u8</span> = (divisor &gt;&gt; <span class="number">8</span>) <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">3</span>).<span class="title function_ invoke__">write_volatile</span>(lcr | <span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">0</span>).<span class="title function_ invoke__">write_volatile</span>(divisor_least);</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>).<span class="title function_ invoke__">write_volatile</span>(divisor_most);</span><br><span class="line">            </span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">3</span>).<span class="title function_ invoke__">write_volatile</span>(lcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7~9行，设置8位数据、无停止位、无奇偶（因为是模拟的 UART，一般硬件设置为 8N1）</p><p>10、11行，开启收中断、开启 FIFO</p><p>13~18行，设置波特率 115200（因为是模拟的 UART 所以波特率设置不影响）</p><p>根据 NS16550A 芯片资料，其内部有一个全局时钟频率为 22.729 MHz（22729000 Hz），所以要设置 115200 波特率： divisor &#x3D; 22729000 &#x2F; (115200 * 16) &#x3D; 12。</p><p>并且在设置波特率之前需把 LCR 寄存器的 DLAB 位置1，设置完后再置0。</p><h3 id="增加-put-方法"><a href="#增加-put-方法" class="headerlink" title="增加 put 方法"></a>增加 put 方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">UartDriver</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">put</span>(&amp;<span class="keyword">self</span>, c: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.base_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ptr.<span class="title function_ invoke__">add</span>(<span class="number">0</span>).<span class="title function_ invoke__">write_volatile</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加-get-方法"><a href="#增加-get-方法" class="headerlink" title="增加 get 方法"></a>增加 get 方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">UartDriver</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.base_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ptr.<span class="title function_ invoke__">add</span>(<span class="number">5</span>).<span class="title function_ invoke__">read_volatile</span>() &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(ptr.<span class="title function_ invoke__">add</span>(<span class="number">0</span>).<span class="title function_ invoke__">read_volatile</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的内核还没处理中断，所以采用 poll 的方式检测是否有数据。</p><h3 id="实现-Write-traits"><a href="#实现-Write-traits" class="headerlink" title="实现 Write traits"></a>实现 Write traits</h3><p>这一步是为了 print! 宏做准备。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::fmt::&#123;Error, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">UartDriver</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">put</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-print-宏"><a href="#实现-print-宏" class="headerlink" title="实现 print! 宏"></a>实现 print! 宏</h2><p>第1章中，<code>lib.rs</code> 文件中的 print! 宏的实现是空，现在我们可以填入内容了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print</span><br><span class="line">&#123;</span><br><span class="line">    ($($args:tt)+) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = <span class="built_in">write!</span>(uart::UartDriver::<span class="title function_ invoke__">new</span>(<span class="number">0x1000_0000</span>), $($args)+);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h2><p>在 kmain 入口处初始化 UART 后就可以向终端输出信息了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">kmain</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_uart</span> = uart::UartDriver::<span class="title function_ invoke__">new</span>(<span class="number">0x1000_0000</span>);</span><br><span class="line">    my_uart.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也能从终端获取用户输入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">kmain</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(c) = my_uart.<span class="title function_ invoke__">get</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="number">8</span> | <span class="number">127</span> =&gt; &#123;</span><br><span class="line">                    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, <span class="number">8</span> <span class="keyword">as</span> <span class="type">char</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">8</span> <span class="keyword">as</span> <span class="type">char</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="number">10</span> | <span class="number">13</span> =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                _ =&gt; &#123;</span><br><span class="line">                    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c <span class="keyword">as</span> <span class="type">char</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSR 学习笔记 - 第1章</title>
      <link href="/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/"/>
      <url>/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>ROSR 是『RISC-V OS using Rust』的缩写，是由 <a href="https://osblog.stephenmarz.com/">Stephen Marz</a> 在他的系列博客中提供的操作系统开发教程。</p><p>本章描述使用汇编语言编写引导程序为 Rust 语言创建执行环境。</p><span id="more"></span><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol><li>将源码编译出目标文件</li><li>使用 linker script 通过链接器将目标文件链接成 ELF 文件</li><li>QEMU 使用 ELF 文件启动</li><li>QEMU 根据 ELF 文件指定的内存地址将代码段、数据段等放置到内存中相应的位置</li><li>QEMU 模拟器开始执行程序</li></ol><h2 id="QEMU-内存映射"><a href="#QEMU-内存映射" class="headerlink" title="QEMU 内存映射"></a>QEMU 内存映射</h2><p>查看 <a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">qemu&#x2F;hw&#x2F;riscv&#x2F;virt.c</a> 文件可知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry virt_memmap[] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [VIRT_DRAM] =         &#123; <span class="number">0x80000000</span>,           <span class="number">0x0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QEMU 从内存地址 <code>0x80000000</code> 开始执行程序，所以我们需要把代码链接到此地址上，这一点从第0章的 linker script 也能看出。</p><h2 id="启动并执行-Rust-程序"><a href="#启动并执行-Rust-程序" class="headerlink" title="启动并执行 Rust 程序"></a>启动并执行 Rust 程序</h2><p>分为 3 个步骤：</p><ol><li>选择用于启动的 CPU （一般选择 id 为 #0 的）</li><li>初始化 BSS 段为 0</li><li>跳转 Rust</li></ol><h3 id="选择启动-CPU"><a href="#选择启动-CPU" class="headerlink" title="选择启动 CPU"></a>选择启动 CPU</h3><p>选择一个 CPU 来执行启动流程，原因在于在这个阶段我们并不想去处理并发或者资源竞争等问题。通过 <a href="https://github.com/riscv/riscv-isa-manual">RISC-V 特权级规范手册</a> 的 3.1.5 节可知，我们能使用 <code>mhartid</code> 寄存器来确定当前指令正在被哪个 CPU 执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csrrt0, mhartid</span><br><span class="line">bnezt0, 3f</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">wfi</span><br><span class="line">j3b</span><br></pre></td></tr></table></figure><p>这段代码让 id#0 之外的 CPU 都跳转到 <code>wfi</code>（等待中断） 指令处。</p><h3 id="初始化-BSS-段"><a href="#初始化-BSS-段" class="headerlink" title="初始化 BSS 段"></a>初始化 BSS 段</h3><p>确定好由哪个 CPU 执行启动流程后，就需要使用它将 BSS 段初始化清零：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">la        a0, _bss_start</span><br><span class="line">la        a1, _bss_end</span><br><span class="line">bgeu      a0, a1, 2f</span><br><span class="line">1:</span><br><span class="line">sd        zero, (a0)</span><br><span class="line">addi      a0, a0, 8</span><br><span class="line">bltu      a0, a1, 1b</span><br></pre></td></tr></table></figure><p>其中标号 <code>_bss_start</code> 以及 <code>_bss_end</code> 由 linker script 确定。</p><h3 id="跳转-Rust"><a href="#跳转-Rust" class="headerlink" title="跳转 Rust"></a>跳转 Rust</h3><p>在跳转执行 Rust 代码前我们必须为 Rust 准备执行环境，也就是设置好栈指针（SP）以及异常程序计数器（mepc）然后利用中断返回（mret）让 CPU 跳转到主函数入口（kmain）。</p><p>但是此时的 CPU 并没有被中断，要使用中断返回就必须模拟一个中断的场景使得 mret 指令能够正确执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">la        sp, _stack</span><br><span class="line">li        t0, (0b11 &lt;&lt; 11) | (1 &lt;&lt; 7) | (1 &lt;&lt; 3)</span><br><span class="line">csrw      mstatus, t0</span><br><span class="line">la        t1, kmain</span><br><span class="line">csrw      mepc, t1</span><br><span class="line">la        t2, asm_trap_vector</span><br><span class="line">csrw      mtvec, t2</span><br><span class="line">li        t3, (1 &lt;&lt; 3) | (1 &lt;&lt; 7) | (1 &lt;&lt; 11)</span><br><span class="line">csrw      mie, t3</span><br></pre></td></tr></table></figure><p>上面这段代码中的第1行就是设置 SP 寄存器，同样 <code>_statck</code> 符号由 linker script 提供。</p><p>第2、3行将 <code>mstatus</code> 寄存器的 <code>MIE</code>、<code>MPIE</code>、<code>MPP</code> 位分别置 <code>b&#39;1</code>、<code>b&#39;1</code> 以及 <code>b&#39;11</code>，使得 mret 执行后 <code>MIE</code> 为 <code>b&#39;1</code>，<code>MPIE</code> 为 <code>b&#39;1</code>，<code>MPP</code> 为 <code>b&#39;00</code>，并且 CPU 处于 M 态。</p><p>第4、5行将 Rust 程序的入口写入 <code>mepc</code> 寄存器，当 mret 执行后 CPU 就会跳转到此处。</p><p>第6、7行设置陷阱向量基地址，暂时不用关心。</p><p>第8、9行开启软中断、时钟中断、外部中断。</p><h3 id="Rust-Code"><a href="#Rust-Code" class="headerlink" title="Rust Code"></a>Rust Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Steve Operating System</span></span><br><span class="line"><span class="comment">// Stephen Marz</span></span><br><span class="line"><span class="comment">// 21 Sep 2019</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![feature(panic_info_message)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ///////////////////////////////////</span></span><br><span class="line"><span class="comment">// / RUST MACROS</span></span><br><span class="line"><span class="comment">// ///////////////////////////////////</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($($args:tt)+) =&gt; &#123;&#123;&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println</span><br><span class="line">&#123;</span><br><span class="line">() =&gt; (&#123;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">($fmt:expr) =&gt; (&#123;</span><br><span class="line"><span class="built_in">print!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">($fmt:expr, $($args:tt)+) =&gt; (&#123;</span><br><span class="line"><span class="built_in">print!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\r\n&quot;</span>), $($args)+)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ///////////////////////////////////</span></span><br><span class="line"><span class="comment">// / LANGUAGE STRUCTURES / FUNCTIONS</span></span><br><span class="line"><span class="comment">// ///////////////////////////////////</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">eh_personality</span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(info: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Aborting: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(p) = info.<span class="title function_ invoke__">location</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;line &#123;&#125;, file &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">            p.<span class="title function_ invoke__">line</span>(),</span><br><span class="line">            p.<span class="title function_ invoke__">file</span>(),</span><br><span class="line">            info.<span class="title function_ invoke__">message</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no information available.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">abort</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// The asm! syntax has changed in Rust.</span></span><br><span class="line">            <span class="comment">// For the old, you can use llvm_asm!, but the</span></span><br><span class="line">            <span class="comment">// new syntax kicks ass--when we actually get to use it.</span></span><br><span class="line">            asm!(<span class="string">&quot;wfi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">kmain</span>() &#123;</span><br><span class="line">    <span class="comment">// Main should initialize all sub-systems and get</span></span><br><span class="line">    <span class="comment">// ready to start scheduling. The last thing this</span></span><br><span class="line">    <span class="comment">// should do is start the timer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码和作者原先的代码有如下差异：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; #![feature(panic_info_message,asm)]</span><br><span class="line">---</span><br><span class="line">&gt; #![feature(panic_info_message)]</span><br><span class="line">&gt;</span><br><span class="line">&gt; use core::arch::asm;</span><br></pre></td></tr></table></figure><p>大概因为目前的 Rust 编译器以及提供了对 <code>asm</code> 稳定支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSR 学习笔记 - 第0章</title>
      <link href="/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC0%E7%AB%A0/"/>
      <url>/2022/11/10/ROSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC0%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>ROSR 是『RISC-V OS using Rust』的缩写，是由 <a href="https://osblog.stephenmarz.com/">Stephen Marz</a> 在他的系列博客中提供的操作系统开发教程。</p><p>本章描述实验环境的搭建。</p><span id="more"></span><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>现在 Rust 编译器已经增加了对 RISC-V 的支持，所以搭建开发环境变得容易了很多：</p><ol><li>安装 rustup</li><li>配置 Rust 编译环境</li><li>安装 RISC-V 交叉编译工具链</li><li>安装 QEMU 的 RISC-V 模拟环境</li></ol><p>在 Ubuntu 20.04 上搭建开发环境的具体步骤如下：</p><h3 id="安装-rustup"><a href="#安装-rustup" class="headerlink" title="安装 rustup"></a>安装 rustup</h3><p>参考 Rust 官方文档。</p><h3 id="配置-Rust-编译环境"><a href="#配置-Rust-编译环境" class="headerlink" title="配置 Rust 编译环境"></a>配置 Rust 编译环境</h3><p>命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustup default nightly</span><br><span class="line">rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">cargo install cargo-binutils</span><br></pre></td></tr></table></figure><p>使用 nightly 构建是因为需要使用一些 Rust 的稳定版本中没有的语言特性 <code>#![features]</code>。</p><h3 id="安装-RISC-V-交叉编译工具链"><a href="#安装-RISC-V-交叉编译工具链" class="headerlink" title="安装 RISC-V 交叉编译工具链"></a>安装 RISC-V 交叉编译工具链</h3><p>使用 ubuntu 软件仓提供的工具链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure><h3 id="安装-QEMU-的-RISC-V-模拟环境"><a href="#安装-QEMU-的-RISC-V-模拟环境" class="headerlink" title="安装 QEMU 的 RISC-V 模拟环境"></a>安装 QEMU 的 RISC-V 模拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-system-riscv64</span><br></pre></td></tr></table></figure><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new myos --lib</span><br></pre></td></tr></table></figure><p>在 <code>Cargo.toml</code> 项目配置文件中增加：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;staticlib&quot;</span>]</span><br></pre></td></tr></table></figure><p>创建 <code>.cargo/config</code> 文件：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&#x27;-Clink-arg=-Tsrc/lds/virt.lds&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[target.riscv64gc-unknown-none-elf]</span></span><br><span class="line"><span class="attr">runner</span> = <span class="string">&quot;qemu-system-riscv64 -machine virt -cpu rv64 -smp 4 -m 128M -drive if=none,format=raw,file=hdd.dsk,id=foo -device virtio-blk-device,scsi=off,drive=foo -nographic -serial mon:stdio -bios none -device virtio-rng-device -device virtio-gpu-device -device virtio-net-device -device virtio-tablet-device -device virtio-keyboard-device -kernel &quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>src/lds/</code> 目录中创建 linker script <code>virt.lds</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    ram   (wxa!ri) : ORIGIN = 0x80000000, LENGTH = 128M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHDRS</span><br><span class="line">&#123;</span><br><span class="line">    text PT_LOAD;</span><br><span class="line">    data PT_LOAD;</span><br><span class="line">    bss PT_LOAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .text : &#123;</span><br><span class="line">    PROVIDE(_text_start = .);</span><br><span class="line">    *(.text.init) *(.text .text.*)</span><br><span class="line">    PROVIDE(_text_end = .);</span><br><span class="line">    &#125; &gt;ram AT&gt;ram :text</span><br><span class="line">    PROVIDE(_global_pointer = .);</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">    PROVIDE(_rodata_start = .);</span><br><span class="line">    *(.rodata .rodata.*)</span><br><span class="line">    PROVIDE(_rodata_end = .);</span><br><span class="line">    &#125; &gt;ram AT&gt;ram :text</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">    . = ALIGN(4096);</span><br><span class="line">    PROVIDE(_data_start = .);</span><br><span class="line">    *(.sdata .sdata.*) *(.data .data.*)</span><br><span class="line">    PROVIDE(_data_end = .);</span><br><span class="line">    &#125; &gt;ram AT&gt;ram :data</span><br><span class="line"></span><br><span class="line">    .bss :&#123;</span><br><span class="line">    PROVIDE(_bss_start = .);</span><br><span class="line">    *(.sbss .sbss.*) *(.bss .bss.*)</span><br><span class="line">    PROVIDE(_bss_end = .);</span><br><span class="line">    &#125; &gt;ram AT&gt;ram :bss</span><br><span class="line"></span><br><span class="line">    PROVIDE(_memory_start = ORIGIN(ram));</span><br><span class="line">    PROVIDE(_stack = _bss_end + 0x80000);</span><br><span class="line">    PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram));</span><br><span class="line">    PROVIDE(_heap_start = _stack);</span><br><span class="line">    PROVIDE(_heap_size = _memory_end - _stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">## BUILD</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line">CC=riscv64-unknown-elf-g++</span><br><span class="line">CFLAGS=-Wall -Wextra -pedantic -Wextra -O0 -g -std=c++17</span><br><span class="line">CFLAGS+=-static -ffreestanding -nostdlib -fno-rtti -fno-exceptions</span><br><span class="line">CFLAGS+=-march=rv64gc -mabi=lp64d</span><br><span class="line">INCLUDES=</span><br><span class="line">LINKER_SCRIPT=-Tsrc/lds/virt.lds</span><br><span class="line">TYPE=debug</span><br><span class="line">RUST_TARGET=./target/riscv64gc-unknown-none-elf/<span class="variable">$(TYPE)</span></span><br><span class="line">LIBS=-L<span class="variable">$(RUST_TARGET)</span></span><br><span class="line">SOURCES_ASM=<span class="variable">$(<span class="built_in">wildcard</span> src/asm/*.S)</span></span><br><span class="line">LIB=-lsos -lgcc</span><br><span class="line">OUT=os.elf</span><br><span class="line"></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">## QEMU</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line">QEMU=qemu-system-riscv64</span><br><span class="line">MACH=virt</span><br><span class="line">CPU=rv64</span><br><span class="line">CPUS=4</span><br><span class="line">MEM=128M</span><br><span class="line">DRIVE=hdd.dsk</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    cargo build</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LINKER_SCRIPT)</span> <span class="variable">$(INCLUDES)</span> -o <span class="variable">$(OUT)</span> <span class="variable">$(SOURCES_ASM)</span> <span class="variable">$(LIBS)</span> <span class="variable">$(LIB)</span></span><br><span class="line">    </span><br><span class="line"><span class="section">run: all</span></span><br><span class="line">    <span class="variable">$(QEMU)</span> -machine <span class="variable">$(MACH)</span> -cpu <span class="variable">$(CPU)</span> -smp <span class="variable">$(CPUS)</span> -m <span class="variable">$(MEM)</span>  -nographic -serial mon:stdio -bios none -kernel <span class="variable">$(OUT)</span> -drive if=none,format=raw,file=<span class="variable">$(DRIVE)</span>,id=foo -device virtio-blk-device,scsi=off,drive=foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    cargo clean</span><br><span class="line">    rm -f <span class="variable">$(OUT)</span></span><br></pre></td></tr></table></figure><p>创建硬盘镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=hdd.dsk count=32 bs=1M</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asterisk 交叉编译</title>
      <link href="/2021/11/02/asterisk-cross-compilation/"/>
      <url>/2021/11/02/asterisk-cross-compilation/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何交叉编译 Asterisk。</p><span id="more"></span><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>开发环境：</p><ul><li>操作系统: <code>Ubuntu 20.04 LTS</code></li><li>CPU 架构: <code>x86_64</code></li></ul><p>目标环境：</p><ul><li>操作系统: <code>Linux 平台(内核版本 2.6.32)</code></li><li>CPU 架构: <code>mipsel</code></li></ul><h2 id="Asterisk-依赖要求"><a href="#Asterisk-依赖要求" class="headerlink" title="Asterisk 依赖要求"></a>Asterisk 依赖要求</h2><p>Asterisk 与各模块间的依赖如下图：</p><p><img src="/2021/11/02/asterisk-cross-compilation/dependencies.png"></p><h2 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h2><p>安装必备的构建工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y \</span><br><span class="line">  build-essential \</span><br><span class="line">  autoconf \</span><br><span class="line">  automake \</span><br><span class="line">  bison \</span><br><span class="line">  flex \</span><br><span class="line">  git \</span><br><span class="line">  libtool \</span><br><span class="line">  libtool-bin \</span><br><span class="line">  make \</span><br><span class="line">  pkg-config</span><br></pre></td></tr></table></figure><p>准备交叉编译工具链：</p><p>这一步需要注意的是，在安装交叉编译工具链时，需要指定一个目标架构，这里我们使用 <code>mipsel</code>，这个架构是 <code>mipsel-linux-gnu-gcc</code> 的目标架构。</p><p>对于 <code>mipsel</code> 架构所对应的交叉编译工具软件包可从上游厂商处获取。其他架构如 <code>arm</code>、<code>arm64</code> 可从 ARM 官方下载，或直接通过软件包管理工具获取（debian 仓库），或者下载第三方提供的二进制文件（如 Linaro 提供）。</p><p>工作目录准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIPSEL_Cross-Compile</span><br><span class="line">├── build_opt</span><br><span class="line">├── build_source</span><br><span class="line">├── build_start</span><br><span class="line">└── toolchain</span><br></pre></td></tr></table></figure><p>建立目录 <code>MIPSEL_Cross-Compile</code> 与子目录 <code>build_opt</code>、<code>build_source</code>、<code>build_start</code>、<code>toolchain</code>，并将 <code>MIPSEL_Cross-Compile/toolchain</code> 目录中的交叉编译工具链添加到环境变量中，以便后续的编译操作可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/home/ubuntu/MIPSEL_Cross-Compile/toolchain/gcc-4.4-gnu/bin&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/home/ubuntu/MIPSEL_Cross-Compile/toolchain/gcc-4.4-gnu/mipsel-linux/lib&quot;</span><br></pre></td></tr></table></figure><ul><li><code>build_opt</code>: 存放编译后产生的可执行文件、库文件等</li><li><code>build_source</code>: 存放源代码压缩包</li><li><code>build_start</code>: 存放源代码</li><li><code>toolchain</code>: 存放交叉编译工具链</li></ul><p>准备源代码：</p><p>各个所需模块的源代码通过下载获取（搜索一下便可得到下载地址），并将源代码压缩包拷贝到 <code>build_source</code> 目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">asterisk-18-current.tar.gz</span><br><span class="line">asterisk-g72x.zip</span><br><span class="line">bcg729-1.1.1.tar.gz</span><br><span class="line">libedit-20210910-3.1.tar.gz</span><br><span class="line">libuuid-1.0.3.tar.gz</span><br><span class="line">libxml2-2.9.12.tar.gz</span><br><span class="line">ncurses-6.2.tar.gz</span><br><span class="line">openssl-1.1.1l.tar.gz</span><br><span class="line">sqlite-autoconf-3360000.tar.gz</span><br><span class="line">zlib-1.2.11.tar.gz</span><br></pre></td></tr></table></figure><p>将这些压缩包都解压到 <code>build_start</code> 目录中。</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>编译顺序为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ncurses</span><br><span class="line">libedit</span><br><span class="line">sqlite3</span><br><span class="line">libuuid</span><br><span class="line">zlib</span><br><span class="line">libxml2</span><br><span class="line">openssl</span><br><span class="line">asterisk</span><br><span class="line">bcg729</span><br><span class="line">asterisk-g72x</span><br></pre></td></tr></table></figure><h3 id="ncurses"><a href="#ncurses" class="headerlink" title="ncurses"></a>ncurses</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/ncurses-6.2</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--disable-stripping \</span><br><span class="line">--with-shared --without-ada --enable-termcap \</span><br><span class="line">--with-build-cc=gcc --with-build-cpp=gcc \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 参数 <code>--with-build-cc</code> 以及 <code>--with-build-cpp</code> 指定的是开发环境本地编译使用的 gcc 工具链，而非交叉编译工具链。</p></blockquote><h3 id="libedit"><a href="#libedit" class="headerlink" title="libedit"></a>libedit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libedit-20210910-3.1</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc \</span><br><span class="line">CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include/ncurses&quot; \</span><br><span class="line">LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/lib&quot; \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Tips: <code>libedit</code> 依赖于 <code>ncurses</code>，所以需要指定 <code>CFLAGS</code>、<code>LDFLAGS</code> 等参数，以便编译时能够正确搜索 <code>ncurses</code> 相关的头文件和库文件。</p></blockquote><h3 id="sqlite3"><a href="#sqlite3" class="headerlink" title="sqlite3"></a>sqlite3</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/sqlite-autoconf-3360000</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="libuuid"><a href="#libuuid" class="headerlink" title="libuuid"></a>libuuid</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libuuid-1.0.3</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/zlib-1.2.11</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc CXX=mipsel-linux-g++ \</span><br><span class="line">./configure --prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="libxml2"><a href="#libxml2" class="headerlink" title="libxml2"></a>libxml2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/libxml2-2.9.12</span><br><span class="line"></span><br><span class="line">./autogen.sh CC=mipsel-linux-gcc \</span><br><span class="line">CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/include&quot; \</span><br><span class="line">LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/lib&quot; \</span><br><span class="line">--build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Tips: <code>libxml2</code> 依赖于 <code>zlib</code>，所以需要指定 <code>CFLAGS</code>、<code>LDFLAGS</code> 等参数，以便编译时能够正确搜索 <code>zlib</code> 相关的头文件和库文件。</p><p>Notice: 与前面编译命令不同 <code>libxml2</code> 使用 <code>./autogen.sh</code> 而不是 <code>./configure</code>，autogen.sh 会生成并运行 configure 同时将传给 autogen.sh 的编译参数传给 configure。</p></blockquote><h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/openssl-1.1.1l</span><br><span class="line"></span><br><span class="line">./Configure linux-mips32 \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \</span><br><span class="line">--openssldir=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \</span><br><span class="line">shared</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/\(CROSS_COMPILE=\).*/\1mipsel-linux-/g&quot; Makefile</span><br><span class="line">sed -i &quot;s/\(CFLAGS=.*\)/\1 -mabi=32 -mglibc -march=mips32/g&quot; Makefile</span><br><span class="line">sed -i &quot;s/\(CXXFLAGS=.*\)/\1 -mabi=32 -mglibc -march=mips32/g&quot; Makefile</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Notice: <code>Configure</code> 是大写的 <code>C</code>，并且执行完成后需要手动修改 Makefile。</p></blockquote><h3 id="asterisk"><a href="#asterisk" class="headerlink" title="asterisk"></a>asterisk</h3><p>设置编译 Asterisk 使用的 <code>CFLAGS</code>、<code>LDFLAGS</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AST_CFLAGS=&quot;-I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/include/ncurses&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/include&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/include/libxml2&quot;</span><br><span class="line">AST_CFLAGS=&quot;$AST_CFLAGS -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel/include&quot;</span><br><span class="line"></span><br><span class="line">AST_LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/ncurses_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libuuid_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/zlib_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel/lib&quot;</span><br><span class="line">AST_LDFLAGS=&quot;$AST_LDFLAGS -lncurses&quot;</span><br></pre></td></tr></table></figure><p>设置 Asterisk 运行时路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AST_RUNTIME_DIR=&quot;/root&quot;</span><br></pre></td></tr></table></figure><p>开始编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CC=mipsel-linux-gcc CXX=mipsel-linux-g++ AR=mipsel-linux-ar RANLIB=mipsel-linux-ranlib \</span><br><span class="line">CFLAGS=$AST_CLFAGS LDFLAGS=$AST_LDFLAGS \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=$AST_RUNTIME_DIR/build_opt/asterisk_build_for_mipsel \</span><br><span class="line">--with-libedit=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libedit_build_for_mipsel \</span><br><span class="line">--with-sqlite3=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/sqlite3_build_for_mipsel \</span><br><span class="line">--with-libxml2=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/libxml2_build_for_mipsel \</span><br><span class="line">--with-crypto=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \</span><br><span class="line">--with-ssl=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/openssl_build_for_mipsel \</span><br><span class="line">--without-bluetooth \</span><br><span class="line">--without-dahdi \</span><br><span class="line">--with-jansson-bundled \</span><br><span class="line">--with-pjproject-bundled \</span><br><span class="line">--without-ldap \</span><br><span class="line">--without-netsnmp \</span><br><span class="line">--without-pri \</span><br><span class="line">--disable-xmldoc</span><br><span class="line"></span><br><span class="line">make menuselect/menuselect menuselect-tree menuselect.makeopts</span><br><span class="line">menuselect/menuselect --enable-all</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install DESTDIR=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel</span><br><span class="line">make samples DESTDIR=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 如果第 19 行报错，则再运行一次即可。</p></blockquote><p>由于指定的运行路径和安装路径有可能不一致，所以需要修复一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel/$AST_RUNTIME_DIR/build_opt/asterisk_build_for_mipsel /tmp/ast_tmp</span><br><span class="line">rm -rf /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel</span><br><span class="line">mv /tmp/ast_tmp /home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel</span><br></pre></td></tr></table></figure><h3 id="bcg729"><a href="#bcg729" class="headerlink" title="bcg729"></a>bcg729</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/bcg729-1.1.1</span><br><span class="line"></span><br><span class="line">CC=mipsel-linux-gcc \</span><br><span class="line">cmake . -DCMAKE_INSTALL_PREFIX=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipsel</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Tips: bcg729 最近的几个版本改为使用 cmake 构建，如果需要用 configure 的构建方式下载旧版本即可。</p></blockquote><h3 id="asterisk-g72x"><a href="#asterisk-g72x" class="headerlink" title="asterisk-g72x"></a>asterisk-g72x</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/MIPSEL_Cross-Compile/build_start/asterisk-g72x-master</span><br><span class="line"></span><br><span class="line">./autogen.sh</span><br><span class="line">CC=mipsel-linux-gcc \</span><br><span class="line">CFLAGS=&quot;-O3 -fomit-frame-pointer -I/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipsel/include&quot; \</span><br><span class="line">LDFLAGS=&quot;-L/home/ubuntu/MIPSEL_Cross-Compile/build_opt/bcg729_build_for_mipsel/lib&quot; \</span><br><span class="line">./configure --build=x86_64-linux-gnu --host=mipsel-none-linux-gnu \</span><br><span class="line">--prefix=/home/ubuntu/MIPSEL_Cross-Compile/build_opt/asterisk_build_for_mipsel \</span><br><span class="line">--with-bcg729 \</span><br><span class="line">--with-asterisk-includes=/home/ubuntu/MIPSEL_Cross-Compile/build_start/asterisk-18.7.1/include</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>Tips: <code>--with-asterisk-includes</code> 参数指定 Asterisk 源代码路径中的头文件。</p></blockquote><h2 id="库安装"><a href="#库安装" class="headerlink" title="库安装"></a>库安装</h2><p>最后，将前面编译出的所有动态链接库（除 asterisk 以及 asterisk-g72x 外）都放置到 Asterisk 的运行目录中。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>将以上描述的过程整理成一个 Makefile 文件，如下：</p><script src="//gist.github.com/0608def14b00121c09490091db93a5df.js?file=makefile_mipsel"></script>]]></content>
      
      
      
        <tags>
            
            <tag> Asterisk </tag>
            
            <tag> Cross Compilation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 SIPp 测试 Asterisk 处理能力</title>
      <link href="/2021/03/05/testing-asterisk-using-sipp/"/>
      <url>/2021/03/05/testing-asterisk-using-sipp/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 SIPp 的使用方法，然后重点介绍如何使用 SIPp 对 Asterisk 服务进行 SIP 注册与通话测试。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文所有操作在 <code>Ubuntu 20.04</code> 和 <code>Debian 10</code> 操作系统上完成。</p><h2 id="SIPp"><a href="#SIPp" class="headerlink" title="SIPp"></a>SIPp</h2><p>SIPp 是一款针对 SIP 协议的开源测试工具，使用此工具可以自定义发送各类 SIP 协议请求以及接收分析 SIP 协议响应，可用于模拟 VoIP 通话进行话音测试。</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>下载并解压源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/SIPp/sipp/releases/download/v3.6.1/sipp-3.6.1.tar.gz -O - | tar -xz -C /tmp</span><br></pre></td></tr></table></figure><p>编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/sipp-3.6.1</span><br><span class="line">./build.sh --common</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><em>SIPp 的详细使用方法请参考<a href="http://sipp.sourceforge.net/doc/reference.html">官方手册</a>。此外可使用 <code>sipp -h</code> 命令查看 SIPp 软件的命令行参数说明。</em></p><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>SIPp 使用 XML 描述语言来描述软件交互行为（情景），可通过命令行参数 <code>-sf</code> 指定自定义的 XML 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sipp -sf &lt;your_xml_file&gt;</span><br></pre></td></tr></table></figure><p>同时 SIPp 也内置了一些 XML 文件来描述一些特定场景的交互过程，可通过 <code>-sn</code> 命令行参数加载内置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sipp -sn &lt;default_xml_file&gt;</span><br></pre></td></tr></table></figure><p>例如，运行 SIPp 内置的 SIP 服务端示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sipp -sn uas</span><br></pre></td></tr></table></figure><p>在同一台电脑上再运行 SIPp 内置的 SIP 客户端示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sipp -sn uac 127.0.0.1</span><br></pre></td></tr></table></figure><p>此时 SIPp 便开始执行测试流程，界面如下：</p><img src="/2021/03/05/testing-asterisk-using-sipp/a.png" class="" title="内置 UAC 测试界面" alt="内置 UAC 测试界面"><p>我们不但可以传递预设参数给 SIPp，可能传递自定义参数，自定义参数保存在 csv 文件中，可通过如下方式传入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sipp -inf &lt;your_csv_file&gt;</span><br></pre></td></tr></table></figure><p>SIPp 使用的 csv 文件<strong>第一行</strong>指定读取方式：</p><ul><li><code>SEQUENTIAL</code> 顺序读取</li><li><code>RANDOM</code> 随即读取</li><li><code>USER</code> 基于用户读取</li></ul><p>从第2行开始便是 SIPp 读取的数据，每个测试实例读取一行，每行中的参数以 <code>;</code> 号隔开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uklar;age;address</span><br></pre></td></tr></table></figure><p>在 XML 文件中引用如上参数则分别使用 <code>[field0]</code>、<code>[field1]</code>、<code>[field2]</code>。</p><h4 id="XML-情景描述"><a href="#XML-情景描述" class="headerlink" title="XML 情景描述"></a>XML 情景描述</h4><p>这里用 SIP 注册为例讲解如何编写情景描述文件。</p><p>SIPp 使用的 XML 描述文件均以如下内容开头：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">scenario</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;sipp.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着便是描述情景的 section：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scenario</span> <span class="attr">name</span>=<span class="string">&quot;My UAC registor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- describe your scenario here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scenario</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有的交互动作均要编写在 <code>&lt;scenario/&gt;</code> section 里。</p><p>根据 SIP 协议示例文档（<a href="https://tools.ietf.org/html/rfc3665">rfc3665</a>）确定交互流程：</p><figure class="highlight plaintext"><figcaption><span>注册交互流程</span></figcaption><table><tr><td class="code"><pre><span class="line">UAC                       SIP Server</span><br><span class="line"> |                            |</span><br><span class="line"> |          REGISTER          |</span><br><span class="line"> |---------------------------&gt;|</span><br><span class="line"> |      401 Unauthorized      |</span><br><span class="line"> |&lt;---------------------------|</span><br><span class="line"> |          REGISTER          |</span><br><span class="line"> |---------------------------&gt;|</span><br><span class="line"> |           200 OK           |</span><br><span class="line"> |&lt;---------------------------|</span><br><span class="line"> |                            |</span><br></pre></td></tr></table></figure><p>根据交互流程编写基本框架：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">send</span> <span class="attr">retrans</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  &lt;![CDATA[</span><br><span class="line"></span><br><span class="line">    REGISTER</span><br><span class="line"></span><br><span class="line">  ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">send</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">recv</span> <span class="attr">response</span>=<span class="string">&quot;401&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">recv</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">send</span> <span class="attr">retrans</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  &lt;![CDATA[</span><br><span class="line">  </span><br><span class="line">    REGISTER</span><br><span class="line"></span><br><span class="line">  ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">send</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">recv</span> <span class="attr">response</span>=<span class="string">&quot;200&quot;</span> <span class="attr">crlf</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">recv</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>&lt;![CDATA[ ... ]]&gt;</code> 用于指定 SIPp 发送的 SIP 协议帧内容，我们可以根据不同的场景自定义帧内容。</p><p>例如，模拟客户端 101 向服务器（asterisk） 192.168.199.59 发送 SIP 注册请求：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line"></span><br><span class="line">  REGISTER sip:192.168.199.59 SIP/2.0</span><br><span class="line">  Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]</span><br><span class="line">  Max-Forwards: 70</span><br><span class="line">  From: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;;tag=[pid]101[call_number]</span><br><span class="line">  To: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;</span><br><span class="line">  Call-ID: [call_id]</span><br><span class="line">  CSeq: 1 REGISTER</span><br><span class="line">  Contact: &lt;sip:101@[local_ip]:[local_port]&gt;;transport=[transport]</span><br><span class="line">  Expires: 3600</span><br><span class="line">  Content-Length: 0</span><br><span class="line"></span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><p>如上，所有 <code>[]</code> 内的字段均可通过命令行参数指定，或 SIPp 自动填入默认值。</p><p>发送 SIP 注册消息后，我们等待服务端响应 <code>401</code> 未授权消息，然后发送携带认证信息的注册请求：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line"></span><br><span class="line">  REGISTER sip:192.168.199.59 SIP/2.0</span><br><span class="line">  Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]</span><br><span class="line">  Max-Forwards: 70</span><br><span class="line">  From: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;;tag=[pid]101[call_number]</span><br><span class="line">  To: &quot;101&quot; &lt;sip:101@192.168.199.59&gt;</span><br><span class="line">  Call-ID: [call_id]</span><br><span class="line">  CSeq: 2 REGISTER</span><br><span class="line">  Contact: &lt;sip:101@[local_ip]:[local_port]&gt;;transport=[transport]</span><br><span class="line">  [authentication username=101 password=1234abcd]</span><br><span class="line">  Expires: 3600</span><br><span class="line">  Content-Length: 0</span><br><span class="line"></span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><p>我们只需在消息帧中加入 <code>[authentication username=USERNAME password=PASSWD]</code>，SIPp 便可根据前一条消息的内容自动计算并填入认证信息。</p><p>需要注意的是，定义前一条消息时（这里是 <code>401</code>），需要加入属性 <code>auth=&quot;true&quot;</code>。</p><p>最后我们等待服务端发送 <code>200 OK</code> 响应以完成 SIP 注册流程。</p><h4 id="批量运行"><a href="#批量运行" class="headerlink" title="批量运行"></a>批量运行</h4><p>SIPp 的主要功能是将定义的情景通过不同的参数实例化出多个测试进程，实现并发测试。</p><p>还是以 SIP 注册为例，我们将之前的单用户注册改造为多用户并发向指定服务器注册，命令行指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sipp -sf ./register.xml &lt;server_ip&gt; -i &lt;local_ip&gt; -users &lt;number_of_users&gt; -inf ./data.csv</span><br></pre></td></tr></table></figure><p>相应参数的解释如下：</p><ul><li><code>server_ip</code>：指定服务端 IP 地址，在 XML 文件中通过 <code>[remote_ip]</code> 引用</li><li><code>local_ip</code>：指定客户端 IP 地址，在 XML 文件中通过 <code>[local_ip]</code> 引用</li><li><code>number_of_users</code>：指定同时存在的用户数量</li></ul><p>假定我们需要同时存在 3 个用户向服务器发起注册，则：</p><p><code>data.csv</code> 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEQUENTIAL</span><br><span class="line">101,[authentication username=101 password=1234abcd]</span><br><span class="line">102,[authentication username=102 password=1234abcd]</span><br><span class="line">103,[authentication username=103 password=1234abcd]</span><br></pre></td></tr></table></figure><p>再修改前面例子中部分参数：</p><ul><li>服务端 IP 地址 <code>192.168.199.59</code> 替换为 <code>[remote_ip]</code></li><li>用户名 <code>101</code> 替换为 <code>[field0]</code></li><li>授权信息 <code>[authentication username=101 password=1234abcd]</code> 替换为 <code>[field1]</code></li></ul><p>启动批量注册测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sipp -sf ./register.xml 192.168.199.59 -i 192.168.199.30 -users 3 -inf ./data.csv</span><br></pre></td></tr></table></figure><h2 id="通话测试"><a href="#通话测试" class="headerlink" title="通话测试"></a>通话测试</h2><p>以下操作流程中涉及到的文件都能<a href="https://gist.github.com/ClarenceYk/9c67e4c7d4d194b32c7a34a95209159a">点击此处</a>获取。</p><p>模拟 SIP 通话场景如下图：</p><figure class="highlight plaintext"><figcaption><span>模拟场景</span></figcaption><table><tr><td class="code"><pre><span class="line">+---------------------------+    +---------------------------+     +----------------------------+</span><br><span class="line">| Host Caller               |    | Asterisk Server           |     | Host Callee                |</span><br><span class="line">|                           |    |                           +&lt;---&gt;+                            |</span><br><span class="line">|   N_Users: 49             +&lt;--&gt;+   N_Users: 98             |     |   N_Users: 48              |</span><br><span class="line">|   Codec  : G729           |    |   Codecs : G711a G729     +&lt;-+  |   Codec  : G711a           |</span><br><span class="line">|   IP     : 192.168.199.30 |    |   IP     : 192.168.199.59 |  |  |   IP     : 192.168.199.227 |</span><br><span class="line">+---------------------------+    +---------------------------+  |  +----------------------------+</span><br><span class="line">                                                                |</span><br><span class="line">                                                                |  +----------------------------+</span><br><span class="line">                                                                |  | Yealink                    |</span><br><span class="line">                                                                |  |                            |</span><br><span class="line">                                                                +-&gt;+   Codec  : G711a           |</span><br><span class="line">                                                                   |   IP     : 192.168.199.35  |</span><br><span class="line">                                                                   +----------------------------+</span><br></pre></td></tr></table></figure><p>在 Asterisk 服务器上创建 <strong>98</strong> 个用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;101..198&#125;; do ext_manage.sh add $i; done</span><br><span class="line">asterisk -rx &quot;core stop now&quot;</span><br><span class="line">asterisk</span><br></pre></td></tr></table></figure><p>在 <code>Host Caller</code> 上生成 <code>test_data.csv</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;SEQUENTIAL&quot; &gt; test_data.csv</span><br><span class="line">for i in &#123;101..149&#125;; do echo &quot;$i;$(expr $i + 49);[authentication username=$i password=1234abcd];[authentication username=$(expr $i + 49) password=1234abcd]&quot; &gt;&gt; test_data.csv; done</span><br></pre></td></tr></table></figure><p>在 <code>Host Callee</code> 上生成 <code>test_data.csv</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;SEQUENTIAL&quot; &gt; test_data.csv</span><br><span class="line">for i in &#123;101..148&#125;; do echo &quot;$i;$(expr $i + 49);[authentication username=$i password=1234abcd];[authentication username=$(expr $i + 49) password=1234abcd]&quot; &gt;&gt; test_data.csv; done</span><br></pre></td></tr></table></figure><p>在 <code>Host Caller</code> 上用 SIPp 注册 <strong>49</strong> 个用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sipp -sf ./my_caller_register.xml 192.168.199.59 -i 192.168.199.30 -users 49 -inf ./test_data.csv</span><br></pre></td></tr></table></figure><p>在 <code>Host Callee</code> 上用 SIPp 注册 <strong>48</strong> 个用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sipp -sf ./my_callee_register.xml 192.168.199.59 -i 192.168.199.227 -users 48 -inf ./test_data.csv</span><br></pre></td></tr></table></figure><p>在 <code>Yealink</code> 上使用账户 <code>198</code> 向服务器注册，并在设置中关闭视频通话，只开启 g711a 话音编码。</p><p>在 <code>Host Callee</code> 上用 SIPp 启动接收 <strong>48</strong> 路通话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sipp -sf ./my_callee_flow.xml 192.168.199.59 -i 192.168.199.227 -users 48 -inf ./test_data.csv</span><br></pre></td></tr></table></figure><p>在 <code>Host Caller</code> 上用 SIPp 启动呼叫 <strong>49</strong> 路通话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sipp -sf ./my_caller_flow.xml 192.168.199.59 -i 192.168.199.30 -users 49 -inf ./test_data.csv</span><br></pre></td></tr></table></figure><p>此时我们可以在 <code>Yealink</code> 上收到呼叫，接听后可通过话音质量来主观感受服务器压力状态。</p><p>同时可查看服务器 CPU 占用状况：</p><img src="/2021/03/05/testing-asterisk-using-sipp/b.png" class="" title="CPU 占用状态" alt="CPU 占用状态">]]></content>
      
      
      
        <tags>
            
            <tag> 操作方法 </tag>
            
            <tag> QEMU </tag>
            
            <tag> ARM64 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 QEMU 启动 ARM aarch64 架构 Ubuntu 虚拟机</title>
      <link href="/2021/03/01/QEMU-%E5%AE%89%E8%A3%85-Ubuntu-ARM64-%E6%9E%B6%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/03/01/QEMU-%E5%AE%89%E8%A3%85-Ubuntu-ARM64-%E6%9E%B6%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文所有操作均在 <code>Ubuntu20.04</code> 操作系统上完成。</p><h2 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h2><p>安装启动 aarch64 ubuntu 所需的依赖程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager qemu</span><br><span class="line">sudo apt install qemu-system-aarch64</span><br><span class="line">sudo apt install qemu-efi-aarch64</span><br><span class="line">sudo apt install qemu-utils</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建启动必备的 flash 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=flash1.img bs=1M count=64</span><br><span class="line">dd if=/dev/zero of=flash0.img bs=1M count=64</span><br><span class="line">dd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=flash0.img conv=notrunc</span><br></pre></td></tr></table></figure><p>下载想要启动的镜像，本文选用 Ubuntu16.04：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ports.ubuntu.com/ubuntu-ports/dists/xenial-updates/main/installer-arm64/current/images/netboot/mini.iso</span><br></pre></td></tr></table></figure><p>创建空硬盘镜像，此镜像用于安装操作系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create ubuntu-image.img 20G</span><br></pre></td></tr></table></figure><p>至此准备工作完成。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>启动系统安装器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 512M -cpu max -smp 4 \</span><br><span class="line">-netdev user,id=vnet,hostfwd=:127.0.0.1:0-:22 -device virtio-net-pci,netdev=vnet \</span><br><span class="line">-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \</span><br><span class="line">-drive file=mini.iso,if=none,id=drive1,cache=writeback -device virtio-blk,drive=drive1,bootindex=1 \</span><br><span class="line">-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash </span><br></pre></td></tr></table></figure><p>根据提示信息完成操作系统安装。</p><p>安装完成之后通过 <code>Ctrl-a x</code> 退出 QEMU 。</p><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><p>这里我们希望将虚拟机接入宿主机所在网络，如下图：</p><figure class="highlight plaintext"><figcaption><span>网络连接图</span></figcaption><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|  Host                                                           |</span><br><span class="line">| +---------------------+                                         |</span><br><span class="line">| |                     |                                         |</span><br><span class="line">| | br0:                |                                         |</span><br><span class="line">| |   192.168.199.32/24 +-----+                                   |</span><br><span class="line">| |                     |     |                                   |</span><br><span class="line">| +----+----------------+     |       +-------------------------+ |</span><br><span class="line">|      |                      |       |  Guest                  | |</span><br><span class="line">|      |                      |       | +---------------------+ | |</span><br><span class="line">| +----+----------------+  +--+---+   | |                     | | |</span><br><span class="line">| |                     |  |      |   | | eth0:               | | |</span><br><span class="line">| | enp3s0:             |  | tap0 |   | |   192.168.199.33/24 | | |</span><br><span class="line">| |   192.168.199.30/24 |  |      +-----+                     | | |</span><br><span class="line">| |                     |  |      |   | +---------------------+ | |</span><br><span class="line">| +---------------------+  +------+   +-------------------------+ |</span><br><span class="line">+-----------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>配置网桥 <code>br0</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link add name br0 type bridge</span><br><span class="line">sudo ip link set dev br0 down</span><br><span class="line">sudo ip addr flush dev br0</span><br><span class="line">sudo ip addr add 192.168.199.32/24 dev br0</span><br><span class="line">sudo ip link set dev br0 up</span><br></pre></td></tr></table></figure><p>配置 tap 设备 <code>tap0</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip tuntap add name tap0 mode tap</span><br><span class="line">sudo ip link set dev tap0 up</span><br></pre></td></tr></table></figure><p>将宿主机网络接口 <code>enp3s0</code> 和 <code>tap0</code> 接入网桥 <code>br0</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set enp3s0 master br0</span><br><span class="line">sudo ip link set tap0 master br0</span><br></pre></td></tr></table></figure><p>启动虚拟机系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 1G -cpu max -smp 4 \</span><br><span class="line">-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-device virtio-net-pci,netdev=mynet0,mac=$(qemu-mac-hasher.py ubuntu1604-arm64) \</span><br><span class="line">-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback \</span><br><span class="line">-device virtio-blk,drive=drive0,bootindex=0 \</span><br><span class="line">-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash \</span><br><span class="line">-device virtio-rng-pci</span><br></pre></td></tr></table></figure><p>以上命令指定 qemu 使用 tap 设备作为虚拟机网络接口并且指定使用刚刚创建的 <code>tap0</code> 接口。</p><p>为了指定虚拟器的 MAC 地址我们使用一个脚本来为每个虚拟机生成特定地址。MAC 地址的生成脚本如下：</p><figure class="highlight python"><figcaption><span>qemu-mac-hasher.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># usage: qemu-mac-hasher.py &lt;VMName&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">crc = <span class="built_in">str</span>(<span class="built_in">hex</span>(zlib.crc32(sys.argv[<span class="number">1</span>].encode(<span class="string">&quot;utf-8&quot;</span>))))[-<span class="number">8</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;52:54:%s%s:%s%s:%s%s:%s%s&quot;</span> % <span class="built_in">tuple</span>(crc))</span><br></pre></td></tr></table></figure><p>虚拟机启动后根据需要配置其网络参数即可。</p><h2 id="优化网络"><a href="#优化网络" class="headerlink" title="优化网络"></a>优化网络</h2><p>以上步骤完成后虚拟机可与宿主机所在网络的其他设备互连（包括宿主机），也可以通过指定的网关连接互联网，但是此时宿主机无法连接互联网，解决方法如下：</p><p>删除 <code>enp3s0</code> 接口的默认网关：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del default dev enp3s0</span><br></pre></td></tr></table></figure><p>为 <code>br0</code> 添加默认网关：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add default via 192.168.199.1 dev br0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作方法 </tag>
            
            <tag> QEMU </tag>
            
            <tag> ARM64 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 LXD 容器化 VoIP 服务</title>
      <link href="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/"/>
      <url>/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/</url>
      
        <content type="html"><![CDATA[<img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/top_pic.jpg" class="" title="top_pic" alt="top_pic"><p>将有繁琐配置的开发环境打包进容器中能减少我们的开发负担，本文将介绍如何把基于 Asterisk 的 VoIP 服务容器化。</p><span id="more"></span><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>如果你的 VoIP 服务开发环境、测试环境和生产环境在同一台物理机上，也许不会察觉到环境搭建的繁琐以及消耗在配置环境上的时间。让我们来设想这样一个场景：客户指定使用某一个 Linux 发行版安装 Asterisk（或者配合 FreePBX）开发一套存在特定需求的 VoIP 服务，基于这个前提你拿到一台新的设备开始工作：</p><ol><li>首先安装配置某个指定 Linux 发行版（花费1、2个小时）；</li><li>接着编译、安装、配置 Asterisk（1个小时）；</li><li>然后安装配置 FreePBX（花费2小时解决无数个问题）；</li><li>最后完成测试（花费1小时）。</li></ol><p>终于在5、6个小时后你搭建好了开发环境，接着发现还有测试环境和生产环境需要搭建，于是你再花上2倍于之前的时间完成了环境搭建工作。总算可以开始开发了，你开始实现某一项功能，为了完成这项功能可能：</p><ol><li>需要变动 Asterisk 的配置；</li><li>需要变动 FreePBX 的接口；</li><li>系统某些环境变量、配置参数需要改动。</li></ol><p>于是你将这些变动都同步执行到测试和生产环境以保证各平台的环境一致，这将耗费开发人员大量的时间。同时，一个项目中面临几十上百项功能的开发需求，很快你就会发现因为环境配置失步导致的开发流程失控，比如开发环境能实现的功能在测试环境失效，在生产环境出现的问题在开发环境无法复现。</p><p>问题总结：</p><ol><li>开发人员在搭建环境和保证各平台环境配置同步的过程中耗费大量时间；</li><li>手动操作进行配置同步难免会出错，出现运行环境失控的情况。</li></ol><p>为了解决这2方面问题，我们可以将服务程序及其所依赖的环境打包进容器中使得整套环境容器化，然后在各个平台分发此容器以保证环境的一致性。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>本次测试的环境是 <code>Debian 10</code>，以下分4个步骤完成 VoIP 服务容器化：</p><ol><li>安装并配置 LXD；</li><li>制作根文件系统，其中安装了 Asterisk 以及 FreePBX；</li><li>将此根文件系统打包作为基础镜像导入 LXD；</li><li>从 LXD 中的基础镜像启动一个实例，并配置网络。</li></ol><h3 id="安装并配置-LXD"><a href="#安装并配置-LXD" class="headerlink" title="安装并配置 LXD"></a>安装并配置 LXD</h3><p>LXD 是一下代开源系统容器、虚拟机管理器。关于 LXD 更为详细的介绍请参考<a href="https://linuxcontainers.org/lxd/docs/master/index">官方文档</a>。</p><p>使用 <code>snap</code> 安装 LXD，如果系统没有 snap 先安装 snap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install snap</span><br><span class="line">sudo snap install core</span><br></pre></td></tr></table></figure><p>安装 <code>LXD</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install lxd</span><br></pre></td></tr></table></figure><p>将用户添加到 lxd 组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G lxd $YOUR_USERNAME</span><br></pre></td></tr></table></figure><h4 id="配置-LXD"><a href="#配置-LXD" class="headerlink" title="配置 LXD"></a>配置 LXD</h4><p>一般情况下直接在命令行中输入 <code>lxd init</code> 然后全部选择都使用默认选项即可。这里我希望使用自定义的存储设备作为 lxd 的 <code>storage pool</code>。</p><p>首先创建一个大小合适的空文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/lxd_storage</span><br><span class="line">dd if=/dev/zero of=$HOME/lxd_storage/disk bs=1M count=51200 # 50G</span><br></pre></td></tr></table></figure><p>创建新的 <code>loop device</code> 并将刚刚创建的空文件关联到此设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">losetup /dev/loop14 $HOME/lxd_storage/disk # 先查看 /dev 目录下是否已有 loop14，有则换一个如：loop15</span><br><span class="line">sudo reboot # 重启生效配置</span><br></pre></td></tr></table></figure><p>初始化 lxd 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uklar@debian:~# lxd init</span><br><span class="line">Would you like to use LXD clustering? (yes/no) [default=no]:</span><br><span class="line">Do you want to configure a new storage pool? (yes/no) [default=yes]:</span><br><span class="line">Name of the new storage pool [default=default]:</span><br><span class="line">Name of the storage backend to use (btrfs, dir) [default=btrfs]:</span><br><span class="line">Would you like to create a new btrfs subvolume under /var/lib/lxd? (yes/no) [default=yes]: no</span><br><span class="line">Create a new BTRFS pool? (yes/no) [default=yes]:</span><br><span class="line">Would you like to use an existing block device? (yes/no) [default=no]: yes</span><br><span class="line">Path to the existing block device: /dev/loop14</span><br><span class="line">Would you like to connect to a MAAS server? (yes/no) [default=no]:</span><br><span class="line">Would you like to create a new local network bridge? (yes/no) [default=yes]:</span><br><span class="line">What should the new bridge be called? [default=lxdbr0]:</span><br><span class="line">What IPv4 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:</span><br><span class="line">What IPv6 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]: none</span><br><span class="line">Would you like LXD to be available over the network? (yes/no) [default=no]:</span><br><span class="line">Would you like stale cached images to be updated automatically? (yes/no) [default=yes] no</span><br><span class="line">Would you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]:</span><br></pre></td></tr></table></figure><h3 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h3><p>这里使用 <code>debootstrap</code> 获取 debian 的根文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install debootstrap</span><br><span class="line">mkdir /tmp/debian</span><br><span class="line">sudo debootstrap buster /tmp/debian</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/debootstrap.png" class="" title="debootstrap" alt="debootstrap"><p>使用 <code>systemd-nspawn</code> 以 <code>chroot</code> 模式切换到 <code>/tmp/debian</code> 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install systemd-container # 此软件包中包含了 systemd-nspawn</span><br><span class="line">sudo systemd-container -D /tmp/debian</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/systemd-nspawn.png" class="" title="systemd-nspawn" alt="systemd-nspawn"><p>做一些基本配置，如设置 root 用户密码、添加普通用户以及配置网络等，然后退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br><span class="line"></span><br><span class="line">useradd -m $USERNAME</span><br><span class="line">passwd $USERNAME</span><br><span class="line"></span><br><span class="line">apt install sudo</span><br><span class="line">usermod -a -G sudo $USERNAME</span><br><span class="line">usermod --shell /bin/bash $USERNAME</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/network/interfaces</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The eth0 network interface</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>接着使用 <code>systemd-nspawn</code> 的容器模式启动 <code>/tmp/debian</code> 以 root 身份登陆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemd-nspawn -D /tmp/debian --boot</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/systemd-nspawn-login-root.png" class="" title="systemd-nspawn-login-root" alt="systemd-nspawn-login-root"><p>在容器中安装 Asterisk 以及 FreePBX，过程请参考：</p><ul><li><a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">Asterisk 安装脚本</a></li><li><a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">FreePBX 安装脚本</a></li></ul><p>配置 hostname：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install dbus</span><br><span class="line">hostnamectl set-hostname debian.voip.net</span><br><span class="line">echo &#x27;127.0.0.1 debian.voip.net&#x27; &gt;&gt;/etc/hosts</span><br></pre></td></tr></table></figure><p>访问服务器 Web 页面验证容器中的 VoIP 服务是否正常运行：</p><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/container-freepbx.png" class="" title="container-freepbx" alt="container-freepbx"><p>从 <code>systemd-nspawn</code> 容器中退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown now</span><br></pre></td></tr></table></figure><h3 id="创建-LXD-镜像"><a href="#创建-LXD-镜像" class="headerlink" title="创建 LXD 镜像"></a>创建 LXD 镜像</h3><p>将刚刚配置完成的根文件系统打包并压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/container/images/voip_base</span><br><span class="line">cd ~/container/images/voip_base</span><br><span class="line">sudo tar czf voip_base.tar.gz -C /tmp/debian .</span><br></pre></td></tr></table></figure><p>为镜像创建 metadata 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;./metadata.yaml</span><br><span class="line">architecture: &quot;x86_64&quot;</span><br><span class="line">creation_date: $(date +%s)</span><br><span class="line">properties:</span><br><span class="line">  architecture: &quot;x86_64&quot;</span><br><span class="line">  description: &quot;Debian(buster) with preinstalled Asterisk13&amp;FreePBX15 ($(date +%Y%m%d))&quot;</span><br><span class="line">  os: &quot;debian&quot;</span><br><span class="line">  release: &quot;buster&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">tar czf metadata.tar.gz metadata.yaml</span><br></pre></td></tr></table></figure><p>将压缩包作为镜像导入 LXD：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc image import \</span><br><span class="line">~/container/images/voip_base/metadata.tar.gz \</span><br><span class="line">~/container/images/voip_base/voip_base.tar.gz \</span><br><span class="line">--alias voip-base</span><br></pre></td></tr></table></figure><p>查看镜像是否成功导入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image list</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/lxc-image-list.png" class="" title="lxc-image-list" alt="lxc-image-list"><h3 id="从镜像启动实例"><a href="#从镜像启动实例" class="headerlink" title="从镜像启动实例"></a>从镜像启动实例</h3><p>有了基础镜像之后，启动一个新的 VoIP 服务实例只需一行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc launch voip-base test</span><br></pre></td></tr></table></figure><p>查看实例运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc list</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/lxc-instance-list.png" class="" title="lxc-instance-list" alt="lxc-instance-list"><p>可以看到 VoIP 服务实例（名字为 test）正在运行，分配的内部 IP 地址是 <code>10.72.18.48</code>。</p><p>可用以下命令登陆到实例中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc exec test bash</span><br></pre></td></tr></table></figure><p>查看各类服务使用的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i -P -n</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/listen-ports.png" class="" title="listen-ports" alt="listen-ports"><h3 id="宿主机网络配置"><a href="#宿主机网络配置" class="headerlink" title="宿主机网络配置"></a>宿主机网络配置</h3><p>让宿主机（IP 为 <code>192.168.0.107</code>）所在网络（<code>192.168.0.0/24</code>）的其他设备能够访问 VoIP 服务（IP 为 <code>10.72.18.48</code>），需要在宿主机上配置网络地址转换（NAT）：</p><ul><li>发送到宿主机 <code>5060</code> 端口的 UDP 包（PJSIP）转发到容器实例</li><li>发送到宿主机 <code>5160</code> 端口的 UDP 包（SIP）转发到容器实例</li><li>发送到宿主机 <code>10000 - 20000</code> 端口的 UDP 包（语音）转发到容器实例</li><li>发送到宿主机 <code>80</code> 端口的 TCP 包（Web 管理服务）转发到容器实例</li></ul><p>以上配置可根据实际需求更改。</p><p>这里使用 <code>iptables</code> 来完成，使用 <code>exit</code> 从实例退出返回宿主机，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5060 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 5160 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p udp --dport 10000:20000 -j DNAT --to 10.72.18.48</span><br><span class="line">sudo iptables -t nat -A PREROUTING --dst 192.168.0.107 -p tcp --dport 80 -j DNAT --to 10.72.18.48</span><br></pre></td></tr></table></figure><p>查看 NAT 配置状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -v -L PREROUTING -n</span><br></pre></td></tr></table></figure><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/iptables-nat.png" class="" title="listen-ports" alt="iptables-nat"><p>现在即可通过宿主机的 IP 访问宿主机上容器化的 VoIP 服务了。</p><h3 id="Asterisk-网络配置"><a href="#Asterisk-网络配置" class="headerlink" title="Asterisk 网络配置"></a>Asterisk 网络配置</h3><p>配置 Asterisk 的 SIP 参数：</p><ul><li><code>externip</code> 为 <code>192.168.0.107</code></li><li><code>localnet</code> 为 <code>10.72.18.0/24</code></li></ul><p>这样 VoIP 服务才能向 SIP 终端正确地发送 <code>contact</code> 参数，否则终端与服务器的 SIP 协议交互会出错。</p><p>直接使用 FreePBX 完成配置（Settings -&gt; Asterisk SIP Settings）：</p><img src="/2020/07/25/create-a-linux-container-of-debian-with-asterisk-freepbx-installed/asterisk-sip-settings.png" class="" title="asterisk-sip-settings" alt="asterisk-sip-settings"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了如何将 VoIP 服务容器化，涉及的内容包括 LXD 的使用、systemd-nspawn 的使用、根文件系统制作、容器镜像制作以及和 VoIP 服务相关的网络配置。通过容器化的操作能让各平台的运行环境保持一致，减少开发人员不必要的时间损耗。至于选择 LXD 作为实现容器化的平台原因有2：</p><ol><li>VoIP 服务软件组成复杂，部署在一个带根文件系统的容器中更为方便；</li><li>LXD 的实现性能较好，关于业界几种容器化工具的性能对比分析请参考论文 <a href="http://www.beei.org/index.php/EEI/article/viewFile/1953/1596">Performance analysis of multi services on container Docker, LXC, and LXD</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LXD </tag>
            
            <tag> VoIP </tag>
            
            <tag> Asterisk </tag>
            
            <tag> FreePBX </tag>
            
            <tag> systemd-nspawn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OSTEP 练习题】测量操作系统切换上下文的耗时</title>
      <link href="/2020/07/11/ostep-measure-cost-of-context-switch/"/>
      <url>/2020/07/11/ostep-measure-cost-of-context-switch/</url>
      
        <content type="html"><![CDATA[<img src="/2020/07/11/ostep-measure-cost-of-context-switch/measure_cost_of_context_switch.svg" class="" title="measure_ctx_switch" alt="measure_ctx_switch"><p>尝试解答 <code>OSTEP</code> <sup><a href="#%E6%B3%A8%E9%87%8A">1</a></sup> 第6章 “Limited Direct Execution” 的练习题 —— 测量操作系统切换上下文的耗时。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>使用的测试平台 CPU 是 Intel i5-6200U，主频 2.3GHz，操作系统是 Arch Linux，内核版本 5.7.7。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>为了尽量准确地测量进程上下文切换耗时，需要有如下几个前提：</p><ol><li>创建 2 个测试进程；</li><li>保证这 2 个进程运行在同一个 CPU 核上（鉴于目前的计算平台一般为多核 CPU）；</li><li>保证正在运行这 2 个测试进程的 CPU 核上没有运行其他用户进程；</li><li>尽量使操作系统在指定时刻执行进程调度（与此同时执行上下文切换）。</li></ol><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>使用 <code>fork</code> 系统调用创建子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// error handling</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// child process</span></span><br><span class="line">    <span class="comment">// do something in child process</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCESS);</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// parent process</span></span><br><span class="line">    <span class="comment">// do something in parent process</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sched-setaffinity"><a href="#sched-setaffinity" class="headerlink" title="sched_setaffinity"></a>sched_setaffinity</h3><p>使用 <code>sched_setaffinity</code> 指定进程运行在 <code>CPU3</code> 这个核心上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(CPU_NUM, &amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set successfully</span></span><br><span class="line"><span class="comment">// do other things</span></span><br></pre></td></tr></table></figure><p>此操作只需在父进程 fork 子进程之前执行即可，子进程默认情况下会和父进程运行在同一个 CPU 核上。</p><h3 id="内核启动参数"><a href="#内核启动参数" class="headerlink" title="内核启动参数"></a>内核启动参数</h3><p>为了保证指定的 CPU 核上只有用于测试的 2 个用户进程，需要设置 <code>isolcpus</code> 这个启动参数给内核。此参数告诉内核在调度其余用户进程时排除指定的 CPU 核心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline</span><br><span class="line"><span class="comment"># BOOT_IMAGE=... isolcpus=3 ...</span></span><br></pre></td></tr></table></figure><p>重新启动计算机，在进入 GRUB 启动界面时选择启动项并按下 <code>e</code>，进入启动项编辑界面，找到 <code>linux</code> 为开头的一行在行尾添加如下启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isolcpus=3 <span class="comment"># 3 代表测试平台中 CPU 的一个核的编号</span></span><br></pre></td></tr></table></figure><p>查看设备 CPU 核心数可在进入系统后命令行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>设置完后可以用 <code>stress</code> 命令测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S stress</span><br><span class="line">stress --cpu 8</span><br></pre></td></tr></table></figure><p>从下图可以看出内核在调度用户进程时绕开了 <code>CPU3</code>（从 0 开始计数）。</p><img src="/2020/07/11/ostep-measure-cost-of-context-switch/stress_cpu.png" class="" title="stress_cpu" alt="stress_cpu"><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>以上几个步骤保证了在 <code>CPU3</code> 核心上只有用于测试的 2 个用户进程，接下来只需要让内核来回切换（调度）这 2 个测试进程即可。</p><p>使用的方法是：创建 2 个 <code>pipe</code>，子进程向 <code>pipe0</code> 写入一个字符然后从 <code>pipe1</code> 读取一个字符，父进程从 <code>pipe0</code> 读取一个字符然后将读取到的字符写入 <code>pipe1</code>，这样重复 N&#x2F;2 次。当子进程在“等待”读取时内核就执行调度切换到父进程，当父进程在“等待”读取时内核执行调度切换到子进程，所以测试进程一次“读写”完成后内核执行了 2 次上下文切换，既总共完成了 N 次切换。更加直观的过程如<a href="#top">题图</a>所示。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在我的平台<sup><a href="#%E6%B3%A8%E9%87%8A">2</a></sup> 上的测试结果为：操作系统上下文切换平均耗时 3.42 微秒。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><script src="//gist.github.com/75ddfa9545480b9a44d329a5bf8c22f1.js?file=measure_cost_of_ctx.c"></script><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><sub>[1] Operating System: Three Easy Pieces - ARPACI-DUSSEAU</sub><br><sub>[2] Intel i5-6200U @ 2.3GHz, Arch Linux, Kernel 5.7.7</sub></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Operating System </tag>
            
            <tag> Context Switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复刻 Linux 操作系统到另一台设备</title>
      <link href="/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/"/>
      <url>/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://rsync.samba.org/">rsync</a> 是一款快速且灵活的文件拷贝工具，既能实现本地拷贝也能完成远程同步。本文将使用 <code>rsync</code> 作为核心工具来介绍如何复刻 Linux 操作系统。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要注意的是源设备和目标设备之间的 CPU 架构需<strong>保持一致</strong>。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ol><li>一台被复刻的设备作为源设备（参考<a href="/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">搭建 IPPBX 基础开发环境</a>）</li><li>一台新设备作为目标设备</li><li>一个 Linux USB 启动盘（制作方法网络上很多这里不多作介绍，我制作的是 <code>Debian10</code> USB 启动盘）</li></ol><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ol><li>rsync</li><li>openssh-server（可选）</li></ol><h2 id="配置源设备"><a href="#配置源设备" class="headerlink" title="配置源设备"></a>配置源设备</h2><p>在<a href="/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">搭建 IPPBX 基础开发环境</a>一文中我们已经搭建好了一个开发环境，其中的 <code>/dev/sdb2</code> 设备里包含了一个完整的用于生产环境的操作系统。现在我们将 <code>/dev/sdb2</code> 用作拷贝源。</p><h3 id="源设备网络"><a href="#源设备网络" class="headerlink" title="源设备网络"></a>源设备网络</h3><p>简单的方法是将源设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和目标设备直接连接的方式，则需要自己配置静态 IP 地址。</p><h3 id="挂载-dev-sdb2"><a href="#挂载-dev-sdb2" class="headerlink" title="挂载 /dev/sdb2"></a>挂载 <code>/dev/sdb2</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/debian_10</span><br><span class="line">sudo mount /dev/sdb2 /mnt/debian_10</span><br></pre></td></tr></table></figure><h3 id="安装-配置-rsync"><a href="#安装-配置-rsync" class="headerlink" title="安装&amp;配置 rsync"></a>安装&amp;配置 rsync</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">enter your passwd:</span><br><span class="line"></span><br><span class="line">apt install rsync</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /etc/rsyncd.conf</span></span><br><span class="line"><span class="string">uid = root</span></span><br><span class="line"><span class="string">gid = root</span></span><br><span class="line"><span class="string">use chroot = no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[all]</span></span><br><span class="line"><span class="string">    path = /</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">rsync --daemon</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="配置目标设备"><a href="#配置目标设备" class="headerlink" title="配置目标设备"></a>配置目标设备</h2><p>将目标设备从 USB 启动盘启动，然后将<a href="#%E8%BD%AF%E4%BB%B6">必备的软件</a>安装好。</p><h3 id="目标设备网络"><a href="#目标设备网络" class="headerlink" title="目标设备网络"></a>目标设备网络</h3><p>简单的方法是将目标设备接到路由器上，由路由器自动分配 IP 地址。也可以采用和源设备直接连接的方式，则需要自己配置静态 IP 地址。</p><h2 id="使用-rsync-复刻系统"><a href="#使用-rsync-复刻系统" class="headerlink" title="使用 rsync 复刻系统"></a>使用 rsync 复刻系统</h2><p>使用 <code>rsync</code> 将源设备上 Linux 系统复刻到目标设备上的方法有两种：</p><ol><li>使用<a href="https://gist.github.com/ClarenceYk/d79d486097350a48ff653ccd028064c8">脚本</a>操作</li><li>手动操作</li></ol><p>推荐使用脚本，用 root 用户执行脚本之后根据提示信息操作即可。如果需要手动操作，则接着往下看（后面的操作均使用 root 用户执行）。</p><h3 id="对目标硬盘分区"><a href="#对目标硬盘分区" class="headerlink" title="对目标硬盘分区"></a>对目标硬盘分区</h3><p>首先查看一下分区信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 119.2G  0 disk</span><br><span class="line">├─sda1   8:1    0     4G  0 part</span><br><span class="line">└─sda2   8:2    0 115.2G  0 part</span><br><span class="line">sdb      8:16   1  14.3G  0 disk</span><br><span class="line">└─sdb1   8:17   1  14.3G  0 part /</span><br></pre></td></tr></table></figure><p>其中 <code>sdb</code> 是 USB 启动盘 <code>sda</code> 是目标设备上的硬盘。对 <code>sda</code> 分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1024 count=1</span><br><span class="line">sfdisk --force /dev/sda &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">1M,4G,S,</span></span><br><span class="line"><span class="string">,,L,*</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">mkswap /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure><p>这里我们将 <code>sda</code> 划了2个分区，第一个是4G的交换分区，剩余的空间划分为系统分区并格式化为 <code>ext4</code> 文件系统（分区方式需和源设备保持一致）。</p><h3 id="从源设备同步文件"><a href="#从源设备同步文件" class="headerlink" title="从源设备同步文件"></a>从源设备同步文件</h3><p>首先将刚刚创建好的系统分区挂载到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/rsync_tmp</span><br><span class="line">mount /dev/sda2 /mnt/rsync_tmp</span><br></pre></td></tr></table></figure><p>检查一下与源设备的连通性（假定源设备的 IP 地址是 <code>192.168.198.140</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 192.168.198.140</span><br></pre></td></tr></table></figure><p>开始同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avHX 192.168.198.140::all/mnt/debian_10/ /mnt/rsync_tmp/</span><br></pre></td></tr></table></figure><p>注意：路径结尾处的 <code>/</code> 必须有。</p><h3 id="重新安装-GRUB-启动器"><a href="#重新安装-GRUB-启动器" class="headerlink" title="重新安装 GRUB 启动器"></a>重新安装 GRUB 启动器</h3><p>从源设备同步完成之后，目标设备上的 GRUB 启动器以及其配置都未更新，所以需要更新。</p><p>首先获取2个分区的 <code>UUID</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ blkid /dev/sda1</span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;XXXX&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> PARTUUID=<span class="string">&quot;XXX&quot;</span></span><br><span class="line">$ blkid /dev/sda2</span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;XXXX&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure><p>将对应分区的 <code>UUID</code> 更新到 <code>/mnt/rsync_tmp/etc/fstab</code> 文件中后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> /proc /mnt/rsync_tmp/proc</span><br><span class="line">mount --<span class="built_in">bind</span> /sys /mnt/rsync_tmp/sys</span><br><span class="line">mount --<span class="built_in">bind</span> /dev /mnt/rsync_tmp/dev</span><br><span class="line">mount --<span class="built_in">bind</span> /run /mnt/rsync_tmp/run</span><br><span class="line"><span class="built_in">chroot</span> /mnt/rsync_tmp</span><br></pre></td></tr></table></figure><p>进入到 <code>chroot</code> 环境后，更新 GRUB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure><h3 id="重启设备"><a href="#重启设备" class="headerlink" title="重启设备"></a>重启设备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>进入 BIOS 中将启动设备设置为硬盘后启动，即可进入完成复刻的 Linux 系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> rsync </tag>
            
            <tag> clone file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 IPPBX 基础开发环境</title>
      <link href="/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/05/06/%E6%90%AD%E5%BB%BA-IPPBX-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>软件开发中应对不同的需求有不同的解决方案，进而产生不同的软件项目。针对不同的软件项目需搭建特定的开发环境以适应各个项目的开发需要。本文以在 Linux 环境中搭建 IPPBX 开发环境为例来介绍如何搭建一个符合需求的开发环境。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>整个开发环境里有如下设备：</p><ol><li>一台开发机，包含2块硬盘</li><li>N 台目标设备（最终业务运行在这些设备上）</li></ol><p>实际的开发场景应该是：开发机随时运行着，其运行状态为：2块硬盘各有一个 Linux 操作系统，其中一个为主系统另一个以类似容器的形式运行在主系统中。主系统中只安装各类开发工具，不运行任何与项目业务相关的服务，所有和项目业务相关的服务都运行在“容器<sup><a href="#%E6%B3%A8%E9%87%8A">1</a></sup>”中。开发人员通过 SSH 远程登陆到主系统中完成开发，或者本地开发完成后将软件服务同步到主系统，维护人员再将新的内容同步到“容器”中。</p><p>实际的系统部署场景应该是：当需要将系统部署到新设备上时，维护人员只需将开发机上2块硬盘中存放“容器”的那块硬盘中的数据“拷贝<sup><a href="#%E6%B3%A8%E9%87%8A">2</a></sup>”到新设备的硬盘中即可。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在着手搭建环境之前需要了解清楚开发环境搭建针对的目标，本例中的目标很简单只有如下2个：</p><ol><li>便于开发工作的进行。</li><li>能方便地将完成了开发工作的系统部署到新设备上。</li></ol><h2 id="拆分需求"><a href="#拆分需求" class="headerlink" title="拆分需求"></a>拆分需求</h2><p>结合前面<code>需求</code>和<code>目标</code>可得到如下细分的功能：</p><ol><li>开发机上需要在其中一块硬盘中安装并运行一个 Linux 操作系统。</li><li>开发机上的另一块硬盘安装一个 Linux 操作系统，此系统能脱离主系统独立运行，同时又能作为“容器”运行在主系统之中。</li><li>需要一个同步方法，能将“容器”同步到新设备的硬盘中。</li></ol><h2 id="选择操作系统及软件工具"><a href="#选择操作系统及软件工具" class="headerlink" title="选择操作系统及软件工具"></a>选择操作系统及软件工具</h2><p>对于开发机的主操作系统这部分没有严格的要求，选择一个适合自己使用习惯的较新的 Linux 发行版即可，这里作为演示我选择的是 <code>Ubuntu20.04</code>。</p><p>容器中运行的操作系统，同时也是最终设备中运行的操作系统，这部分对系统的稳定性以及很多软件的兼容性要求更高一些，所以我们选择 <code>Debian10</code>。</p><p>对于“容器化”的部分，目前有很多容器化技术，如功能非常少但使用非常简单的 <code>chroot</code>（甚至不能作为容器技术🙈）；又如功能非常强大但使用起来有一定门槛的 <code>docker</code>、<code>podman</code> 或者 Ubuntu 推出的 <code>LXC</code> 等；还有介于前面两种之间的 <code>systemd-nspawn</code>。鉴于本例中的使用场景，我们选择 <code>systemd-nspawn</code>，因为其不仅能在我们的<a href="#%E9%9C%80%E6%B1%82">需求</a>范围内很好地隔离主系统与“容器”而且使用方法相对简单。</p><p>对于“同步”这部分，我们选择 <code>rsync</code>，这是一个基于增量传输的文件同步软件，既可用通过单机本地同步也可通过网络同步，能满足我们开发环境中的同步需求。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="主系统"><a href="#主系统" class="headerlink" title="主系统"></a>主系统</h3><p>主操作系统我们选用的是 <code>Ubuntu20.04</code> 安装方法网络上很多，搜索一下即可，这里不再介绍。</p><h3 id="容器中的系统"><a href="#容器中的系统" class="headerlink" title="容器中的系统"></a>容器中的系统</h3><p>本例中我们采用的是 <code>Debian10</code>，安装方法同上。值得注意的是，此系统需安装到开发机的另一块硬盘上，同时在安装前可先取下安装了主系统的硬盘，这样主系统的启动条目就不会出现在“容器”的 grub 启动选项中。此外，分区方式推荐如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdb      8:16   0 232.9G  0 disk</span><br><span class="line">├─sdb1   8:17   0    16G  0 part [SWAP]</span><br><span class="line">└─sdb2   8:18   0 216.8G  0 part</span><br></pre></td></tr></table></figure><p>其中交换分区根据自己的实际需求划分，剩下的空间全部作为 <code>/</code> 分区。</p><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>在主系统中安装软件包 <code>systemd-contianer</code>（此中软件包中包含 <code>systemd-nspawn</code> 工具）以及安装同步工具 <code>rsync</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install systemd-contianer</span><br><span class="line">sudo apt install rsync</span><br></pre></td></tr></table></figure><p><em>注：关于使用 <code>rsync</code> 来同步容器到新设备的方法放在<a href="/2020/05/08/%E5%A4%8D%E5%88%BB-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87">另一篇文章</a>中阐述。</em></p><h2 id="运行“容器”"><a href="#运行“容器”" class="headerlink" title="运行“容器”"></a>运行“容器”</h2><p>将2块装好了操作系统的硬盘都接到主板上，然后启动开发机进入 <code>BIOS</code> 将装有 Ubuntu20.04 操作系统的硬盘设置到启动序列的第一位。进入主系统后，查看硬盘分区，大致如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsblk</span></span><br><span class="line">sda      8:0    0 931.5G  0 disk</span><br><span class="line">├─sda1   8:1    0  15.3G  0 part [SWAP]</span><br><span class="line">├─sda2   8:2    0 122.1G  0 part /</span><br><span class="line">└─sda3   8:3    0 794.2G  0 part /home</span><br><span class="line">sdb      8:16   0 232.9G  0 disk</span><br><span class="line">├─sdb1   8:17   0    16G  0 part</span><br><span class="line">└─sdb2   8:18   0 216.8G  0 part</span><br></pre></td></tr></table></figure><p>其中 <code>sda</code> 中安装了我们的主系统（Ubuntu）也就是当前运行的系统，<code>sdb</code> 中安装了“容器”的系统（Debian）。</p><ul><li>创建挂载点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/debian_10</span><br></pre></td></tr></table></figure><ul><li>挂载 <code>sdb</code> 中的文件系统</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb2 /mnt/debian_10</span><br></pre></td></tr></table></figure><ul><li>使用 <code>systemd-nspawn</code> 进入“容器”环境</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemd-nspawn -D /mnt/debian_10 -b</span></span><br><span class="line">pawning container debian10 on /mntdebian_10.</span><br><span class="line">Press ^] three times within 1s to kill container.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Welcome to Debian GNU/Linux 10 (buster)!</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux 10 debian console</span><br><span class="line"></span><br><span class="line">debian login:</span><br></pre></td></tr></table></figure><p>到此我们就进入了“容器”环境。在容器内部我们可以认为在另一个操作系统里，于是可以执行任何命令以及安装各种软件但是并不影响主系统。例如我们可以<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">安装 Asterisk</a> 与 <a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">FreePBX</a></p><ul><li>退出容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown now</span><br></pre></td></tr></table></figure><p>或者在 1s 内按下 <code>^]</code> 3次。（<code>control 键</code> + <code>] 键</code>）</p><h2 id="容器中安装平台环境"><a href="#容器中安装平台环境" class="headerlink" title="容器中安装平台环境"></a>容器中安装平台环境</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure><h3 id="Asterisk"><a href="#Asterisk" class="headerlink" title="Asterisk"></a>Asterisk</h3><p>参考 Asterisk 自动安装<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_asterisk-sh">脚本</a>。</p><p><em>注意：此脚本仅在 <code>Ubuntu18.04</code> 以及 <code>Debian10</code> 中测试通过。</em></p><h3 id="FreePBX"><a href="#FreePBX" class="headerlink" title="FreePBX"></a>FreePBX</h3><p>参考 FreePBX 自动安装<a href="https://gist.github.com/ClarenceYk/2995d607e1b7678fe0c37665546217aa#file-install_freepbx-sh">脚本</a>。</p><p><em>注意：此脚本仅在 <code>Ubuntu18.04</code> 以及 <code>Debian10</code> 中测试通过。</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>搭建 IPPBX 基础开发环境</code> 中的操作系统、工具软件选择以及容器的制作与运行。下一篇将接着介绍如何将容器<code>同步</code>到新设备上。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><sub>[1] 这里的容器不是指完整的容器技术，仅仅采用了 Linux 容器的概念。</sub></p><p><sub>[2] 只借用“拷贝”的概念，实际操作要更复杂一些。</sub></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> systemd-nspawn </tag>
            
            <tag> rsync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简明架构</title>
      <link href="/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>最近为一个项目开发软件，在实做过程中发现软件需求比较复杂：涉及多种对内对外应用接口，需要操作的数据和需要维护的状态种类多，各种操作较繁杂还牵扯到同步问题。在一边开发功能一边重构的过程中发现一套能很好适应当前开发需求的软件组织方式，本想写一篇总结文章，但在搜索整理资料的时候发现有前辈在 2012 年的一篇博客中已经提出了这样的软件设计模式（或称架构），于是在这里翻译这篇文章供参考。</p><p><em><strong>原文地址：</strong></em> <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></p><img src="/2020/03/28/%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%84/w.jpg" class="" title="Architecture" alt="Architecture"><span id="more"></span><p>以下为译文。</p><p>在过去的几年间我们已经看到过各种各样关于系统架构的设想，如下：</p><ul><li>来自 Alistair Cockburn 的<a href="http://alistair.cockburn.us/Hexagonal+architecture">六边形架构</a>（也称接口与适配），此架构被 Steve Freeman 与 Nat Pryce 在其合著的《测试驱动的面向对象软件开发》一书中采纳</li><li>来自 Jeffrey Palermo 的<a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">洋葱架构</a></li><li>我去年在博客中提出的<a href="http://blog.cleancoders.com/2011-09-30-Screaming-Architecture">令人惊叹的架构</a></li><li>由 James Coplien 和 Trygve Reenskaug 提出的 <a href="http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/">DCI</a></li><li>Ivar Jacobson 在其所著的《实例驱动的面向对象软件工程》一书中提出的 <a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350">BCE</a></li></ul><p>虽然以上这些架构都在细节上有所不同，但在宏观上非常相似。它们有同一个的目标，关注对软件的拆分，通过将软件分解为不同的层次，以达到拆分的目的。每种架构都至少有一层用于描述业务规则，其他层次用于创建接口。</p><p>使用这些架构所产生的系统都有以下特点：</p><ol><li>独立于框架。架构不依赖于功能丰富的软件库。这让你能够将软件框架作为工具使用，而不用为了使用框架将其塞入系统以满足框架的限制。</li><li>可测试。业务规则能够在没有界面、数据库、Web 服务器或其他元素的情况下被测试。</li><li>独立于界面。可以在不改变系统其余部分的情况下很容易地修改界面。例如，可以将 Web 界面改为命令行界面却不改变业务规则。</li><li>独立于数据库。你可以随时弃用 Oracle 或 SQL Server 的数据库改为使用 Mongo、BigTable、CouchDB 或者其他数据库。因为你的业务规则不与数据库绑定。</li><li>独立于任意外部机构。事实上你的业务规则根本对外部世界一无所知。</li></ol><h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>图中每一个同心圆表示不同领域的软件。通常，项目开发得越久软件所处的层级越高。外层圆是机制，内层是策略。</p><p>使这个架构能够正常运转而起到决定性作用的规则是<strong>依赖规则</strong>。这个规则描述了源代码的<strong>依赖关系</strong>只能由<strong>外部指向内部</strong>，处于内圈的代码对处于外圈的代码一无所知。特别的，在外圈定义的对象的名称必不能被处于内圈的代码提及。这些对象包括：函数、类、变量或者其他有名称的软件实体。</p><p>出于同样的原因，在外圈使用的格式化数据不应该在内圈被使用，特别是由某种软件框架产生的格式化数据。我们不希望外圈的任何事物影响到内圈。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>实体封装了企业范围内的业务规则。实体可以是携带方法的对象也可以是由数据结构和函数组成的集合。实体只要能被企业中不同的应用程序使用即可，具体是什么则无关紧要。</p><p>如果你没有开发企业级软件而是在写单个应用程序，那么这些实体可以是应用程序的业务对象，其中封装了最普遍最高层次的规则。如果架构的外围发生了改变那么实体将会是最后一个需要修改的。例如，你不希望当页面导航或者安全保护方面产生了变更而影响到实体。总的来说，任意指定程序的操作变更都不应影响实体层。</p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>处于这一层的软件包含面向应用程序的业务规则，封装和实现所有系统用例。这些用例编排数据流动包括流向实体和从实体流入，以及引导实体使用企业业务规则来实现用例的目的。</p><p>同样，我们不希望这一层的变更影响实体。也不希望这一层受到外部变更的影响，比如数据库、UI 或者任意软件框架，此层与这些情况无关。</p><p>可以预期，应用程序操作的变更会影响用例进而影响处于此层的软件。如果用例本身发生了变化，那么处于此层的代码一定会受到影响。</p><h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><p>处于此层的软件通常是一组适配器。适配器的作用是将方便于用例和实体使用的数据格式转换为方便外部机构使用的数据格式。外部机构包括数据库、Web 等。比如在此层中会完全包含图形用户界面的 MVC 架构，表示器、视图以及控制器都属于此层。模型一般表示为数据结构，从控制器传给用例，再从用例返回到表示器和视图。</p><p>类似的，数据从方便用例和实体使用的形式转换到方便持久化框架（如数据库）使用的形式也发生在此层。从这一层向内的所有代码都对数据库不了解。如果数据是 SQL 数据库那么所有的 SQL 语句都应该被限制在此层用于与数据库交互的部分。</p><p>当然此层还有另一种必备的适配器，用于将来自外部服务的数据格式转换为用例和实体使用的内部数据格式。</p><h2 id="框架和驱动"><a href="#框架和驱动" class="headerlink" title="框架和驱动"></a>框架和驱动</h2><p>最外一层通常是由软件框架与工具组成，例如数据库、Web 开发框架等。一般你不需要在此层写大量代码而是写一些“胶水”代码用于与紧邻的内层通信。</p><p>这一层是所有具体细节出现的地方，例如 Web、数据库都充满各种细节需要关注，将这类事物放到最外层可以最大可能地减少对整体系统的影响。</p><h2 id="仅有四层？"><a href="#仅有四层？" class="headerlink" title="仅有四层？"></a>仅有四层？</h2><p>不是，此图只是概念展示。在实际操作中你会发现所需的不止四层，也没有规定一定只能有四层。无论怎样<strong>依赖原则</strong>始终有效，即源代码总是向内依赖。越往内越抽象。最外圈是最低层次包含最具体的细节，越往内软件越为抽象封装更高层次的策略，最中心的圈也就最一般化。</p><h2 id="跨越边界"><a href="#跨越边界" class="headerlink" title="跨越边界"></a>跨越边界</h2><p>在图示中的右下角可以看到一个示例展示了我们如何跨越不同层次的边界。可以看到控制器和表示器通过它们隔壁层的用例来互相通信。注意控制的流向，它从控制器开始，通过用例最后在表示器中执行以结束。在看源代码的依赖方向，它们都向内指向用例，这就产生了矛盾。</p><p>通常我们使用<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置原则</a>解决这个显而易见的冲突。诸如 Java 一类的编程语言我们可以通过组织一组接口和类继承关系使得在适当的时候让源代码的依赖方向和控制方向相反以实现跨越边界。</p><p>例如，考虑当用例需要调用表示器的情况。这种调用方式必不能直接实现，因为这样违反了依赖原则：内部事物对外部一无所知。因此我们让用例定义以及调用接口（interface）也就是图中内圈的 Use Case Output Port，而让外圈的表示器实现这个接口（interface）。</p><p>这个技巧可以用在整个架构中所有需要跨越边界的地方。我们利用面向对象编程语言的动态多态性这个特点创建与控制流向相反的源代码依赖。这样不论控制流动的方向是什么我们都能让设计符合<strong>依赖原则</strong>。</p><h2 id="哪些数据会跨越边界"><a href="#哪些数据会跨越边界" class="headerlink" title="哪些数据会跨越边界"></a>哪些数据会跨越边界</h2><p>一般跨越边界的是简单的数据结构。可以根据自己的需要选择基本数据结构或者简单的数据传输对象或者函数调用时传入的参数，也可以将数据打包进哈稀表或者构建到对象里，关键在于用于跨越边界的数据要足够简单和具备独立性。我们并不希望让<strong>实体</strong>或数据库的原始数据行跨越边界，同样不希望跨越边界的结构里包含任意会违背<strong>依赖原则</strong>的数据。</p><p>比如，许多数据库框架会用便于使用的数据格式作为查询的响应，我们把这样的数据称为 RowStructure。我们不希望跨越边界时传递这样的结构，这样可能会违背<strong>依赖原则</strong>因为这有几率迫使内部的代码必须了解外部的数据定义。</p><p>因此，我们传递的数据跨越边界时，最常用是便于内层使用的格式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遵循这些简单的规则并不费劲，并且可以省去开发过程中很多麻烦。将整体软件分层并配合<strong>依赖原则</strong>，你可以创建一个具备极好测试性的系统，这会带来非常多的好处。当系统外部任意部分成为了整体系统的瓶颈，如数据库或者 Web 开发框架，你能只花很小的代价就将其撤换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Software Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Go 语言控制 GPIO</title>
      <link href="/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/"/>
      <url>/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/</url>
      
        <content type="html"><![CDATA[<p>GPIO 也就是通用输入&#x2F;输出外设，在嵌入式开发中会经常遇到的一种外部设备。通过使用软件控制 GPIO 可实现对外输出电平信号；通过读取 GPIO 管脚上的信号可在软件中获取外部信息。操作 GPIO 外设的方法很多，这里将介绍一种在 Linux 环境中通过 <code>mmap</code> 系统调用来完成控制的方法。</p><span id="more"></span><h2 id="软硬件环境"><a href="#软硬件环境" class="headerlink" title="软硬件环境"></a>软硬件环境</h2><ul><li>CPU: iMX6Q(ARM)</li><li>Kernel: Linux 4.19.72</li><li>OS: Ubuntu18.04</li></ul><h2 id="GPIO-控制流程简介"><a href="#GPIO-控制流程简介" class="headerlink" title="GPIO 控制流程简介"></a>GPIO 控制流程简介</h2><p>iMX6Q 芯片手册上有如下描述:</p><img src="/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/IMX6DQRM_28_4_3_0.png" class="" title="GPIO Programming" alt="GPIO Programming"><p>由此可知读取 GPIO 某一个管脚上的信号分为3个步骤:</p><ol><li>配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。</li><li>配置管脚方向寄存器，设置此管脚为输入。</li><li>从管脚数据寄存器中读取值。</li></ol><p>反之，如果要向外输出信号则为以下3步骤:</p><ol><li>配置管脚复用寄存器，以将此管脚设置为 GPIO 模式。</li><li>配置管脚方向寄存器，设置此管脚为输出。</li><li>向管脚数据寄存器写入值。</li></ol><h2 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h2><p>iMX6Q 有7组 GPIO 每组有8个 32-bit 的寄存器，每个寄存器上 1-bit 控制着其对应的1个管脚的配置，也就是每组 GPIO 有32个管脚，每个管脚有8个配置项。关于 iMX6Q GPIO 更为详细的介绍可参阅 <a href="https://www.kosagi.com/w/index.php?title=Definitive_GPIO_guide">Definitive GPIO guide</a>。</p><p>对于只使用输入&#x2F;输出功能的情况，8个寄存器中我们只需关心数据寄存器和方向寄存器这2个（对于管脚复用寄存器，因为默认状态下几乎所有管脚都是 GPIO 模式所以基本不用关心，具体情况请参考芯片手册）。</p><p>GPIO 控制寄存器的基地址为 <code>0x0209C000</code>，地址宽度为 <code>0x4000</code> 也就是第一组 GPIO 的控制寄存器在地址 <code>0x0209C000</code> 上，第二组在 <code>0x020A0000</code>，以此类推。每一个寄存器是 32-bit 大小所以，第一组 GPIO 的数据寄存器在 <code>0x0209C000</code> 方向寄存器在 <code>0x0209C004</code>，如下图:</p><img src="/2020/03/18/%E7%94%A8-Go-%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6-GPIO/IMX6DQRM_28_5_0.png" class="" title="GPIO register" alt="GPIO register"><p>由此可以在代码中做如下定义:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    gpioBaseAddr  <span class="type">uint32</span> = <span class="number">0x0209C000</span></span><br><span class="line">    gpioAddrWidth <span class="type">uint32</span> = <span class="number">0x4000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于指定的某一组 GPIO 的寄存器地址可这样获得:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGPIOMMapper</span><span class="params">(group <span class="type">int</span>)</span></span> ([]<span class="type">uint32</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    gaddr := gpioBaseAddr + (<span class="type">uint32</span>(group)<span class="number">-1</span>)*gpioAddrWidth</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存地址转换"><a href="#内存地址转换" class="headerlink" title="内存地址转换"></a>内存地址转换</h2><p>当程序运行起来后操作系统为每一个进程分配了一个虚拟地址空间，而寄存器的地址在实地址空间中，所以需要使用内存地址转换将实地址映射到虚拟地址空间，这样我们才能通过内存地址访问 GPIO 寄存器。</p><p>执行终端命令 <code>man mmap</code> 可查阅关于 mmap 详细的资料，这里我们通过 Go 语言 <code>unix</code> 包中封装的 <code>Mmap</code> 函数来使用 mmap 系统调用，如下:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGPIOMMapper</span><span class="params">(group <span class="type">int</span>)</span></span> ([]<span class="type">uint32</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b, err := unix.Mmap(<span class="type">int</span>(memMapFile.Fd()), <span class="type">int64</span>(gaddr), <span class="number">8</span>, unix.PROT_READ|unix.PROT_WRITE, unix.MAP_SHARED)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中指定映射的地址长度为8字节，原因是这里我们只使用前2个寄存器。<code>memMapFile</code> 可由如下函数获得:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initGPIOMemMap</span><span class="params">()</span></span> *os.File &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;/dev/mem&quot;</span>, os.O_RDWR, <span class="number">0600</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="keyword">return</span> file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成地址转换之后 <code>unix.Mmap</code> 函数返回一个 <code>byte</code> 类型的切片，而每个寄存器是 32-bit 宽度，也就是一个寄存器对应 4 个 byte，这样操作起来比较麻烦。为了简化操作可以将 <code>[]byte</code> 转换为 <code>[]uint32</code> 类型:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byte2uint32</span><span class="params">(b []<span class="type">byte</span>)</span></span> []<span class="type">uint32</span> &#123;</span><br><span class="line">    sl := reflect.SliceHeader&#123;&#125;</span><br><span class="line">    sl.Cap = <span class="built_in">len</span>(b) / <span class="number">4</span></span><br><span class="line">    sl.Len = <span class="built_in">len</span>(b) / <span class="number">4</span></span><br><span class="line">    sl.Data = <span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">uint32</span>)(unsafe.Pointer(&amp;sl))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-GPIO-外设输出或读取值"><a href="#通过-GPIO-外设输出或读取值" class="headerlink" title="通过 GPIO 外设输出或读取值"></a>通过 GPIO 外设输出或读取值</h2><p>完成以上操作之后，假定得到的内存映射保存在 <code>var mapper []uint32</code> 中。如果我们要设置管脚 10 为输出，并且对外输出高电平，则可通过以下操作完成:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方向寄存器中第 10 bit 为1表示管脚10为输出</span></span><br><span class="line">mapper[<span class="number">1</span>] = mapper[<span class="number">1</span>] | <span class="type">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 设置数据寄存器中第 10 bit 为1表示管脚10输出高电平</span></span><br><span class="line">mapper[<span class="number">0</span>] = mapper[<span class="number">0</span>] | <span class="type">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>如果我们要设置管脚 10 为输入，并且读取管脚上的电平信息，则可通过以下操作完成:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方向寄存器中第 10 bit 为0表示管脚10为输入</span></span><br><span class="line">mapper[<span class="number">1</span>] = mapper[<span class="number">1</span>] &amp; ^<span class="type">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 读取数据寄存器中第 10 bit 的值</span></span><br><span class="line">value := mapper[<span class="number">0</span>] &amp; <span class="type">uint32</span>(<span class="number">0x00000001</span>&lt;&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 GPIO 的基本操作、iMX6Q GPIO 外设寄存器的分布以及 Go 语言中使用内存映射的方法，最后实现了使用 Go 语言对 GPIO 进行控制。对于以上的过程我们可以进一步将其封装成 <code>struct</code> 方便使用，类似如下:</p><figure class="highlight go"><figcaption><span>gpio_imx6q.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GPIOPin <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group   <span class="type">int</span></span><br><span class="line">    Pin     <span class="type">int</span></span><br><span class="line">    mmapper []<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span></span> SetDir(dir <span class="type">string</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span></span> Direction() <span class="type">string</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span></span> Set(v <span class="type">string</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pin *GPIOPin)</span></span> Read() <span class="type">string</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了内存映射之外，还可以使用其他方法操作 GPIO，例如通过 <code>sysfs</code> 文件系统或者使用 <code>/dev/gpiochip</code> 设备文件等，这里就不做过多介绍了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GPIO </tag>
            
            <tag> memory map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q 2GB 内存支持</title>
      <link href="/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/"/>
      <url>/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>iMX6Q SABRESD 开发板的板载 DDR 内存大小为 1GB 其配套的 codebase 也只针对 1GB 内存大小适配。我们的运行平台上配备了 2GB 内存，直接使用原有 codebase 将只能使用其中一半内存空间。以下将介绍如何让系统识别并使用 2GB 内存。</p><span id="more"></span><h2 id="系统启动过程现象"><a href="#系统启动过程现象" class="headerlink" title="系统启动过程现象"></a>系统启动过程现象</h2><p>系统启动过程中可看到 U-Boot 输出如下信息:</p><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2019.10-rc1-00134-gacda5922db-dirty (Mar 16 2020 - 15:27:54 +0800)</span><br><span class="line"></span><br><span class="line">CPU:   Freescale i.MX6Q rev1.6 996 MHz (running at 792 MHz)</span><br><span class="line">CPU:   Automotive temperature grade (-40C to 125C) at 36C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Model: Freescale i.MX6 Quad SABRE Smart Device Board</span><br><span class="line">Board: MX6-SabreSD</span><br><span class="line">I2C:   ready</span><br><span class="line">DRAM:  1 GiB</span><br><span class="line">PMIC:  PFUZE100 ID=0x10</span><br><span class="line">MMC:   FSL_SDHC: 0, FSL_SDHC: 3</span><br></pre></td></tr></table></figure><p>其中 <code>DRAM:  1 GiB</code> 这一行表示 U-Boot 识别到的内存空间大小为 1GB。</p><p>进入操作系统之后，终端执行如下命令:</p><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@arm:~$ <span class="built_in">cat</span> /proc/meminfo</span><br><span class="line">MemTotal:        1031138 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可知操作系统识别到的内存空间大小也是 1GB。</p><h2 id="识别内存大小的过程"><a href="#识别内存大小的过程" class="headerlink" title="识别内存大小的过程"></a>识别内存大小的过程</h2><p>查看 U-Boot 源码，初始化函数 <code>board_init_f</code> 会执行一系列初始化操作:</p><figure class="highlight c"><figcaption><span>u-boot/common/board_f.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">hang();</span><br></pre></td></tr></table></figure><p><code>init_sequence_f</code> 是一个数组，所有初始化函数都放在这个数组中，其中有2个函数:</p><figure class="highlight c"><figcaption><span>imx6q/u-boot/common/board_f.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    announce_dram_init,</span><br><span class="line">    dram_init,<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>announce_dram_init</code> 函数只有一行代码作用是输出 <code>DRAM:</code>。真正需要我们关心的是 <code>dram_init</code>，这个函数继续调用了另一个函数 <code>imx_ddr_size</code>，接着往下追发现如下注释信息:</p><figure class="highlight c"><figcaption><span>u-boot/arch/arm/mach-imx/cpu.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * imx_ddr_size - return size in bytes of DRAM according MMDC config</span></span><br><span class="line"><span class="comment"> * The MMDC MDCTL register holds the number of bits for row, col, and data</span></span><br><span class="line"><span class="comment"> * width and the MMDC MDMISC register holds the number of banks. Combine</span></span><br><span class="line"><span class="comment"> * all these bits to determine the meme size the MMDC has been configured for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">imx_ddr_size</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">esd_mmdc_regs</span> *<span class="title">mem</span> =</span> (<span class="keyword">struct</span> esd_mmdc_regs *)MEMCTL_BASE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到函数 <code>imx_ddr_size</code> 根据 <code>MMDC</code> 的配置返回内存空间大小，配置信息存储在寄存器 <code>MMDC_MDCTL</code> 中。</p><h2 id="适配-2GB-内存"><a href="#适配-2GB-内存" class="headerlink" title="适配 2GB 内存"></a>适配 2GB 内存</h2><p>从前面的代码中可看到寄存器 <code>MMDC_MDCTL</code> 的地址在定义 <code>MEMCTL_BASE</code> 中，接着查看 MEMCTL_BASE 的定义，可得到如下信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MEMCTL_BASE</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">MMDC_P0_BASE_ADDR</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">AIPS2_OFF_BASE_ADDR + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">ATZ2_BASE_ADDR + 0x80000 + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">AIPS2_ARB_BASE_ADDR + 0x80000 + 0x30000</span><br><span class="line"> |</span><br><span class="line"> v</span><br><span class="line">0x02100000 + 0x80000 + 0x30000 = 0x021b0000</span><br></pre></td></tr></table></figure><p>所以 MMDC_MDCTL 寄存器地址为 <code>0x021b0000</code>。此处代码是从寄存器中读取配置的值，那么一定会有其他的代码去配置这个寄存器的值，继续查找可发现:</p><figure class="highlight c"><figcaption><span>u-boot/board/freescale/mx6sabresd/mx6sabresd.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> mx6q_dcd_table[] = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">0x021b0040</span>, <span class="number">0x00000027</span>,</span><br><span class="line">    <span class="number">0x021b0000</span>, <span class="number">0x831A0000</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始 codebase 中向寄存器 MMDC_MDCTL 配置了值 <code>0x831A0000</code> 以及向寄存器 MMDC_MDASP 配置了值 <code>0x00000027</code>。</p><p>接着从 iMX6Q 芯片参考手册中可查到寄存器 MMDC_MDCTL 数据位的分配:</p><img src="/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/IMX6DQRM_44_12_1_0.png" class="" title="寄存器 MMDC_MDCTL" alt="寄存器 MMDC_MDCTL"><p>从而得知原始代码中，寄存器 MMDC_MDCTL 配置的含义为：</p><ul><li>使能 CS0</li><li>关闭 CS1</li><li>行地址宽度 14bit</li><li>列地址宽度 10bit</li><li>burst 长度 8</li><li>数据总线大小 64bit</li></ul><p>我们运行平台上的内存芯片和 iMX6Q SABRESD 开发板上的内存芯片是一样的封装，只是容量是后者的2倍，也就是<code>行地址宽度</code>多了1bit，所以将 MMDC_MDCTL 寄存器的值配置为 <code>0x841A0000</code>。</p><p>对于寄存器 <code>MMDC_MDASP</code>，芯片手册中描述如下:</p><blockquote><p>MMDCx_MDASP[CS0_END] should be set to DDR_CS_SIZE&#x2F;32MB + 0x7 (DDR base address begins at 0x10000000)</p><footer><strong>Freescale</strong><cite>i.MX 6Dual/6Quad Applications Processor Reference Manual</cite></footer></blockquote><p>所以寄存器 MMDC_MDASP 的值应该配置为 <code>内存大小/32MB + 0x7</code> 也就是 <code>0x00000047</code>，最后配置如下:</p><figure class="highlight c"><figcaption><span>u-boot/board/freescale/mx6sabresd/mx6sabresd.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> mx6q_dcd_table[] = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="number">0x021b0040</span>, <span class="number">0x00000047</span>,</span><br><span class="line">    <span class="number">0x021b0000</span>, <span class="number">0x841A0000</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备树修改"><a href="#设备树修改" class="headerlink" title="设备树修改"></a>设备树修改</h2><p>将 U-Boot 以及内核设备树与内存大小相关的地方修改为 2GB:</p><figure class="highlight dts"><figcaption><span>u-boot/arch/arm/dts/imx6qdl-sabresd.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">memory@10000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x10000000</span> <span class="number">0x80000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>最后，将以上修改保存到设备中，启动系统之后可以看到 U-Boot 以及操作系统均识别到 2GB 内存空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 U-Boot 在启动时识别内存大小的过程，以及 iMX6Q 关于内存信息的几个寄存器的配置，最终实现让系统平台识别并且使用 2GB 内存空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> 内存拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统中 Watchdog 的应用</title>
      <link href="/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何在 Linux 系统的用户层使用 Watchdog。</p><span id="more"></span><h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><ul><li>硬件环境: iMX6Q SABRE-SD 开发板</li><li>操作系统内核: Linux 4.19.72-armv7</li><li>操作系统发行版: Ubuntu18.04</li></ul><h2 id="开启-Watchdog"><a href="#开启-Watchdog" class="headerlink" title="开启 Watchdog"></a>开启 Watchdog</h2><p>在<a href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6#Linux-%E5%86%85%E6%A0%B8">编译内核</a>时开启 <code>Watchdog</code>:</p><figure class="highlight bash"><figcaption><span>./tools/rebuild.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核配置选项位置</span></span><br><span class="line">Device Drivers -&gt; Watchdog Timer Support</span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/compile-kernel-watchdog.png"></p><p><em>开启 <code>Disable watchdog shutdown on close</code> 这一项。</em></p><p>内核文档中关于此选项的解释如下:</p><blockquote><p>When the device is closed, the watchdog is disabled, unless the “MagicClose” feature is supported (see below).  This is not always such a good idea, since if there is a bug in the watchdog daemon and it crashes the system will not reboot.  Because of this, some of the drivers support the configuration option “Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT.  If it is set to Y when compiling the kernel, there is no way of disabling the watchdog once it has been started.  So, if the watchdog daemon crashes, the system will reboot after the timeout has passed. Watchdog devices also usually support the nowayout module parameter so that this option can be controlled at runtime.</p><p>Magic Close feature:</p><p>If a driver supports “Magic Close”, the driver will not disable the watchdog unless a specific magic character ‘V’ has been sent to &#x2F;dev&#x2F;watchdog just before closing the file.  If the userspace daemon closes the file without sending this special character, the driver will assume that the daemon (and userspace in general) died, and will stop pinging the watchdog without disabling it first.  This will then cause a reboot if the watchdog is not re-opened in sufficient time.</p><footer><strong>Christer Weingel</strong><cite><a href="https://www.kernel.org/doc/Documentation/watchdog/watchdog-api.txt">The Linux Watchdog driver API.</a></cite></footer></blockquote><p>简单来说，开启此选项之后一旦我们打开了 Watchdog 设备，只要程序没对此 Watchdog 做文档中指定的操作，那么 Watchdog 就会重启系统。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>操作系统内核会将 CPU 芯片上的 Watchdog 外设抽象为文件系统中的一个字符设备:</p><figure class="highlight bash"><figcaption><span>ubuntu@arm:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/watchdog*</span><br><span class="line"><span class="comment"># /dev/watchdog  /dev/watchdog0</span></span><br></pre></td></tr></table></figure><p>上面命令列出来系统中的 Watchdog 设备（<code>/dev/watchdog</code>、<code>/dev/watchdog0</code> 在底层指向同一个硬件）。使用其中任一设备都可以。</p><ol start="0"><li>打开设备</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_open</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchdog_fd = open(watchdog_dev, O_RDWR);</span><br></pre></td></tr></table></figure><p>根据头文件 <code>linux/watchdog.h</code> 中的定义，我们可以通过得到的<code>文件描述符</code>对 watchdog 设备做后面这些操作。</p><ol><li>设置 watchdog 超时时间</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_settimeout</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &amp;seconds);</span><br></pre></td></tr></table></figure><ol start="2"><li>feed watchdog</li></ol><figure class="highlight c"><figcaption><span>api_watchdog_feed</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_KEEPALIVE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>可以将上面的这些操作<a href="https://gist.github.com/ClarenceYk/c71502b63378e3fbcd763fdaa658803d">封装成函数接口</a>，在函数内部做一些错误处理。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">wait_time</span> =</span> &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (api_watchdog_init(WATCHDOG_DEV, WATCHDOG_TIMEOUT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Watchdog opened!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">api_watchdog_feed();</span><br><span class="line">nanosleep(&amp;wait_time, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，先初始化 watchdog 然后每秒 feed watchdog 一次，此时系统如常运行。当 kill 此程序后，由于前面在内核开启了 <code>Disable watchdog shutdown on close</code> 选项 watchdog 会继续工作，同时没有继续 feed 的操作所以系统进入重启流程。</p><h2 id="引入外部-Kick-信号"><a href="#引入外部-Kick-信号" class="headerlink" title="引入外部 Kick 信号"></a>引入外部 Kick 信号</h2><p>以一个具体的应用场景为例，如下:</p><figure class="highlight plaintext"><figcaption><span>硬件连接</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------   GPIO  --------</span><br><span class="line">| CPU | &lt;------ | FPGA |</span><br><span class="line">-------         --------</span><br></pre></td></tr></table></figure><p>FPGA 通过 CPU 的 GPIO 外设向开发板输入一个周期性翻转信号。CPU 在每一个周期开始时重置 watchdog，我们可以检测 GPIO 的上升沿或者下降沿获得周期开始的信息。</p><p>对 GPIO 的操作在 Linux 环境中有很多方法实现，这里我们使用 <a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 库来实现对 GPIO 上升沿信号的检测。</p><p><code>libgpiod</code> 中封装了很多便于使用的 API。在当前使用场景中，只需调用函数 <code>gpiod_ctxless_event_monitor</code> 就可实现我们想要的功能，其函数签名以及相应的文档注释如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wait for events on a single GPIO line.</span></span><br><span class="line"><span class="comment"> * @param device Name, path, number or label of the gpiochip.</span></span><br><span class="line"><span class="comment"> * @param event_type Type of events to listen for.</span></span><br><span class="line"><span class="comment"> * @param offset GPIO line offset to monitor.</span></span><br><span class="line"><span class="comment"> * @param active_low The active state of this line - true if low.</span></span><br><span class="line"><span class="comment"> * @param consumer Name of the consumer.</span></span><br><span class="line"><span class="comment"> * @param timeout Maximum wait time for each iteration.</span></span><br><span class="line"><span class="comment"> * @param poll_cb Callback function to call when waiting for events.</span></span><br><span class="line"><span class="comment"> * @param event_cb Callback function to call for each line event.</span></span><br><span class="line"><span class="comment"> * @param data User data passed to the callback.</span></span><br><span class="line"><span class="comment"> * @return 0 if no errors were encountered, -1 if an error occurred.</span></span><br><span class="line"><span class="comment"> * @note The way the ctxless event loop works is described in detail in</span></span><br><span class="line"><span class="comment"> *       ::gpiod_ctxless_event_monitor_multiple - this is just a wrapper aound</span></span><br><span class="line"><span class="comment"> *       this routine which calls it for a single GPIO line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_ctxless_event_monitor</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *device, <span class="type">int</span> event_type,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">bool</span> active_low,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *consumer,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout,</span></span><br><span class="line"><span class="params">                                gpiod_ctxless_event_poll_cb poll_cb,</span></span><br><span class="line"><span class="params">                                gpiod_ctxless_event_handle_cb event_cb,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data)</span> GPIOD_API;</span><br></pre></td></tr></table></figure><p>如上可以看出几个关键参数，通过 <code>device</code>、<code>offset</code> 参数指定使用的 GPIO 管脚，<code>event_type</code> 指定检测事件（如，上升沿事件），<code>event_cb</code> 是触发指定事件后调用的回调函数，其调用方法大致如下:</p><figure class="highlight c"><figcaption><span>上升沿检测</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WDOG_GPIO_SIG_CHIP &quot;/dev/gpiochip6&quot;</span></span><br><span class="line"><span class="comment">// WDOG_GPIO_SIG_PORT 7</span></span><br><span class="line">gpiod_ctxless_event_monitor(WDOG_GPIO_SIG_CHIP, GPIOD_CTXLESS_EVENT_RISING_EDGE,</span><br><span class="line">                        WDOG_GPIO_SIG_PORT, <span class="literal">false</span>, <span class="string">&quot;wdog&quot;</span>, &amp;timeout,</span><br><span class="line">                        <span class="literal">NULL</span>, gpio6_port7_rising_edge_handle_cb, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>接下来只需要再定义回调函数即可，回调函数的函数签名如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Simple event callback signature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The callback function takes the following arguments: event type (int),</span></span><br><span class="line"><span class="comment"> * GPIO line offset (unsigned int), event timestamp (const struct timespec *)</span></span><br><span class="line"><span class="comment"> * and a pointer to user data (void *).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This callback is called by the ctxless event loop functions for each GPIO</span></span><br><span class="line"><span class="comment"> * event. If the callback returns ::GPIOD_CTXLESS_EVENT_CB_RET_ERR, it should</span></span><br><span class="line"><span class="comment"> * also set errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*gpiod_ctxless_event_handle_cb)</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="keyword">struct</span> timespec *, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure><p>所以我们定义的上升沿事件回调函数大致如下:</p><figure class="highlight c"><figcaption><span>定义回调函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio6_port7_rising_edge_handle_cb</span><span class="params">(<span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *timestamp, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    wdog_count ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wdog_count &gt;= WDOG_FEED_PERIOD / FPGA_WDOG_SIG_PERIOD) &#123;</span><br><span class="line">        api_watchdog_feed();</span><br><span class="line">        wdog_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GPIOD_CTXLESS_EVENT_CB_RET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键在于 <code>api_watchdog_feed()</code>。</p><p>以上就实现了外部 Kick 信号的引入。</p><h2 id="配置-systemd-服务"><a href="#配置-systemd-服务" class="headerlink" title="配置 systemd 服务"></a>配置 systemd 服务</h2><p>我们希望 watchdog 程序随着系统自动启动，所以配置如下的 systemd 服务:</p><figure class="highlight plaintext"><figcaption><span>wdog_fpga.service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Watchdog systemd service.</span><br><span class="line">ConditionKernelCommandLine=!disable_wdog</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/wdog_fpga</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>其中我们定义了 <code>ConditionKernelCommandLine</code> 参数为 <code>!disable_wdog</code>。这样当系统启动之后 systemd 会检测内核启动命令行参数中是否存在<code>disable_wdog</code>，如果不存在则启动 watchdog，反之依然。这样配置的好处是，我们可以在系统启动之前配置是否开启 watchdog。</p><h2 id="U-Boot-环境设置内核命令行参数"><a href="#U-Boot-环境设置内核命令行参数" class="headerlink" title="U-Boot 环境设置内核命令行参数"></a>U-Boot 环境设置内核命令行参数</h2><p>如果我们不想开启 watchdog，则在 U-Boot 启动后暂停引导内核，然后将 <code>disable_wdog</code> 参数设置到内核命令行参数中，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs ... 其他参数 ... disable_wdog</span><br></pre></td></tr></table></figure><p>然后再引导内核启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run bootcmd</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本介绍了如何在 Linux 操作系统中使用 watchdog，分为以下方面的工作:</p><ul><li>内核选项配置</li><li>部分 API 介绍</li><li>设备操作接口封装</li><li>实际应用场景示例</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Watchdog </tag>
            
            <tag> Embedded System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q SABRE-SD 开发板软件烧录</title>
      <link href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/"/>
      <url>/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 <code>iMX6Q SABRE-SD</code> 开发板的软件烧录流程。</p><span id="more"></span><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0"><li><p>使开发板进入工厂模式<br>具体操作请参考此<a href="/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D">文档</a>。</p></li><li><p>开发板系统软件<br>制作开发板系统软件请参考此<a href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">文档</a>。</p></li></ol><h2 id="烧录流程"><a href="#烧录流程" class="headerlink" title="烧录流程"></a>烧录流程</h2><p>烧录过程中会使用 <code>utp_com</code> 向开发板发送指令，开发板收到指令后执行。</p><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><ol start="0"><li>分区脚本</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">END &gt;/tmp/mkmmc.sh</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">node=\$1</span></span><br><span class="line"><span class="string"># partition size in MB</span></span><br><span class="line"><span class="string">BOOT_ROM_SIZE=10</span></span><br><span class="line"><span class="string"># wait for the SD/MMC device node ready</span></span><br><span class="line"><span class="string">while [ ! -e \$&#123;node&#125; ]</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">sleep 1</span></span><br><span class="line"><span class="string">echo &quot;wait for \$&#123;node&#125; appear&quot;</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string"># destroy the partition table</span></span><br><span class="line"><span class="string">dd if=/dev/zero of=\$&#123;node&#125; bs=1024 count=1</span></span><br><span class="line"><span class="string"># call sfdisk to create partition table</span></span><br><span class="line"><span class="string">sfdisk --force \$&#123;node&#125; &lt;&lt;EOF</span></span><br><span class="line"><span class="string">1M,,L,*</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">END</span></span><br></pre></td></tr></table></figure><ol><li>发送并执行分区脚本</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f /tmp/mkmmc.sh</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ sh \$FILE /dev/mmcblk3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="建立-U-Boot-分区"><a href="#建立-U-Boot-分区" class="headerlink" title="建立 U-Boot 分区"></a>建立 U-Boot 分区</h3><ol start="0"><li>boot 分区写使能</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo 0 &gt; /sys/block/mmcblk3boot0/force_ro&quot;</span></span><br></pre></td></tr></table></figure><ol><li>发送 SPL、U-Boot 并写入</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;SPL 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ dd if=\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=1&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;U-Boot 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ dd if=\$FILE of=/dev/mmcblk3boot0 bs=1024 seek=69&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>boot 分区只读使能</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo 1 &gt; /sys/block/mmcblk3boot0/force_ro&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使能 boot 分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mmc bootpart enable 1 1 /dev/mmcblk3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建系统分区"><a href="#创建系统分区" class="headerlink" title="创建系统分区"></a>创建系统分区</h3><ol start="0"><li>建立 EXT4 分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ while [ ! -e /dev/mmcblk3p1 ]; do sleep 1; echo \&quot;waiting...\&quot;; done&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkfs.ext4 -L rootfs /dev/mmcblk3p1&quot;</span></span><br></pre></td></tr></table></figure><ol><li>挂载系统分区</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkdir -p /mnt/rootfs&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mount /dev/mmcblk3p1 /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h3><ol start="0"><li>写入根文件系统</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;pipe tar -x[文件压缩方式] -C /mnt/rootfs&quot;</span> -f &lt;rootfs 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;frf&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ chown root:root /mnt/rootfs&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ chmod 755 /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><ol><li>设置 <code>uname_r</code></li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo &#x27;uname_r=&lt;内核版本信息&gt;&#x27; &gt;&gt; /mnt/rootfs/boot/uEnv.txt&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>写入内核、设备树、内核模块</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;kernel 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ cp \$FILE /mnt/rootfs/boot/vmlinuz-&lt;内核版本信息&gt;&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;dtb 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ mkdir -p /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ tar xf \$FILE -C /mnt/rootfs/boot/dtbs/&lt;内核版本信息&gt;/&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;send&quot;</span> -f &lt;modules 文件路径&gt;</span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ tar xf \$FILE -C /mnt/rootfs/&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>更新 fstab</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo &#x27;/dev/mmcblk2p1  /  auto  errors=remount-ro  0  1&#x27; &gt;&gt; /mnt/rootfs/etc/fstab&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>同步，取消挂载</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/utp_com$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ sync&quot;</span></span><br><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ umount /mnt/rootfs&quot;</span></span><br></pre></td></tr></table></figure><h2 id="启动开发板"><a href="#启动开发板" class="headerlink" title="启动开发板"></a>启动开发板</h2><p>将开发板的<a href="/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">启动拨码开关</a>拨至 <code>11100110</code>，然后上电启动可看到串口输出:</p><figure class="highlight bash"><figcaption><span>串口输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu 18.04.3 LTS arm ttymxc0</span><br><span class="line"></span><br><span class="line">default username:password is [ubuntu:temppwd]</span><br><span class="line"></span><br><span class="line">arm login: </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>iMX6Q SABRE-SD</code> 开发板的软件烧录流程，总结为以下4个步骤:</p><ul><li>创建分区表</li><li>建立 U-Boot 分区</li><li>创建系统分区</li><li>安装操作系统</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX6Q SABRE-SD 开发板系统软件</title>
      <link href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/"/>
      <url>/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍适用于 <code>iMX6Q SABRE-SD</code> 开发板的启动加载器（U-Boot）、Linux 内核以及根文件系统的制作。</p><span id="more"></span><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="ARM-交叉编译工具链"><a href="#ARM-交叉编译工具链" class="headerlink" title="ARM 交叉编译工具链"></a>ARM 交叉编译工具链</h2><ol start="0"><li>下载 &amp; 解压</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz</span><br><span class="line">tar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz</span><br></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=`<span class="built_in">pwd</span>`/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line"><span class="variable">$&#123;CC&#125;</span>gcc --version</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>终端输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc (Linaro GCC 6.5-2018.12) 6.5.0</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h2 id="启动加载器-U-Boot"><a href="#启动加载器-U-Boot" class="headerlink" title="启动加载器: U-Boot"></a>启动加载器: U-Boot</h2><ol start="0"><li>下载源码</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/u-boot/u-boot</span><br><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line">git checkout v2019.07 -b tmp</span><br></pre></td></tr></table></figure><ol><li>打补丁</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/u-boot$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://raw.githubusercontent.com/eewiki/u-boot-patches/master/v2019.07-rc4/0001-mx6sabresd-fixes.patch</span><br><span class="line">patch -p1 &lt; 0001-mx6sabresd-fixes.patch</span><br></pre></td></tr></table></figure><ol start="2"><li>修改代码</li></ol><p>用编辑器打开文件 <code>~/u-boot/include/configs/mx6sabre_common.h</code>，找到如下代码:</p><figure class="highlight c"><figcaption><span>vi ~/u-boot/include/configs/mx6sabre_common.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv interface mmc;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv mmcdev 0;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run mmcboot;&quot;</span> \</span></span><br><span class="line"><span class="meta">......</span></span><br></pre></td></tr></table></figure><p>添加2行代码，结果如下:</p><figure class="highlight c"><figcaption><span>vi ~/u-boot/include/configs/mx6sabre_common.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv interface mmc;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv mmcdev 3;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run mmcboot;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv mmcdev 0;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run mmcboot;&quot;</span> \</span></span><br><span class="line"><span class="meta">......</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置 &amp; 编译</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/u-boot$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span> distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span> mx6sabresd_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CC&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h2><p>内核我们采用 <code>4.19</code> 长期支持版。</p><ol start="0"><li>下载源码</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RobertCNelson/armv7-multiplatform</span><br><span class="line"><span class="built_in">cd</span> armv7-multiplatform/</span><br><span class="line">git checkout origin/v4.19.x -b tmp</span><br></pre></td></tr></table></figure><ol><li>编译</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~/armv7-multiplatform$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build_kernel.sh</span><br></pre></td></tr></table></figure><h2 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h2><p>根文件系统我们采用 <code>Ubuntu18.04 LTS</code>。</p><ol start="0"><li>下载</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br></pre></td></tr></table></figure><ol><li>验证</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sha256sum</span> ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br><span class="line"><span class="comment"># 输出信息: b28b356d75153bfb3beb5c96bf8eabe92025cf5e665e1a564b469bc70e5a363b  ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span></span><br></pre></td></tr></table></figure><ol start="2"><li>解压</li></ol><figure class="highlight bash"><figcaption><span>netop@mfgtools:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf ubuntu-18.04.3-minimal-armhf-2020-02-10.tar.xz</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>iMX6Q SABRE-SD</code> 开发板系统软件的制作。通过这些操作可得到以下文件:</p><ol start="0"><li>启动加载器, <code>目录: ~/u-boot/</code></li></ol><ul><li>SPL</li><li>u-boot.img</li></ul><ol><li>内核相关，<code>目录: ~/armv7-multiplatform/deploy</code></li></ol><ul><li>4.19.xx-armv7-xxx.zImage</li><li>4.19.xx-armv7-xxx-dtbs.tar.gz</li><li>4.19.xx-armv7-xxx-modules.tar.gz</li></ul><ol start="2"><li>根文件系统，<code>目录: ~/imx6q/ubuntu-18.04.3-minimal-armhf-2020-02-10</code></li></ol><ul><li>armhf-rootfs-ubuntu-bionic.tar</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> U-Boot </tag>
            
            <tag> Linux kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iMX USB loader &amp; UTP 使用方法介绍</title>
      <link href="/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 Freescale 提供的工具软件 iMX USB loader 以及 UTP 的使用方法。</p><span id="more"></span><p>在使用 iMX6Q SabreSD 开发板时，如果我们对 Linux 内核或者根文件系统进行了定制则需要将新的软件部署到开发板。将软件部署到开发板的方法与开发板的启动方式有关，如果我们需要开发板从 eMMC 启动则需要将软件部署到 eMMC 存储器，使用 Freescale 提供的 <code>iMX USB loader</code> 和 <code>UTP</code> 2个工具能帮助我们完成这项工作。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="开发板设置"><a href="#开发板设置" class="headerlink" title="开发板设置"></a>开发板设置</h2><p>在操作之前需要将开发板设置到下载模式，iMX6Q SabreSD 的说明文档中提到:</p><blockquote><table><thead><tr><th>Mode</th><th>Switch</th></tr></thead><tbody><tr><td>download mode(MFGTool mode)</td><td>(SW6) 00001100 (from 1-8 bit)</td></tr><tr><td>eMMC (MMC3) boot</td><td>(SW6) 11100110 (from 1-8 bit)</td></tr><tr><td>MMC4 (SD2) boot</td><td>(SW6) 10000010 (from 1-8 bit)</td></tr><tr><td>MMC2 (SD3) boot</td><td>(SW6) 01000010 (from 1-8 bit)</td></tr></tbody></table><p><em><strong>Freescale</strong></em> – <em>Android User Guide</em></p></blockquote><p>所以我们将开发板的启动拨码开关拨到如下位置:</p><p><img src="/2020/02/18/iMX-USB-loader-UTP-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/imx-usb-loader-boot-switch.jpg"></p><p>将开发板的 USB 接到电脑端，使用 <code>lsusb</code> 命令可看到如下信息:</p><figure class="highlight bash"><figcaption><span>查看 USB 设备信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># Bus 001 Device 003: ID 15a2:0054 Freescale Semiconductor, Inc. i.MX 6Dual/6Quad SystemOnChip in RecoveryMode</span></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure><p>可看到电脑端成功识别了开发板，记录下 <code>ID</code> 信息:</p><ul><li>ID: 15a2:0054</li></ul><p><em>在开始后面步骤之前请将开发板串口与电脑端连接，方便通过串口查看调试信息。</em></p><h2 id="iMX-USB-loader-安装配置"><a href="#iMX-USB-loader-安装配置" class="headerlink" title="iMX USB loader 安装配置"></a>iMX USB loader 安装配置</h2><ol start="0"><li>安装 <code>libusb</code>。</li></ol><figure class="highlight bash"><figcaption><span>install libusb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><ol><li>获取 iMX USB loader <a href="https://github.com/boundarydevices/imx_usb_loader">源代码</a>。</li></ol><figure class="highlight bash"><figcaption><span>git clone</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/boundarydevices/imx_usb_loader.git</span><br></pre></td></tr></table></figure><ol start="2"><li>编译</li></ol><figure class="highlight bash"><figcaption><span>compile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> imx_usb_loader</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置文件</li></ol><p>查看文件 <code>imx_usb.conf</code> 根据刚刚记录下来的 <code>ID</code> 值找到取对应的开发板配置文件:</p><figure class="highlight plaintext"><figcaption><span>imx_usb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">0x15a2:0x0054, mx6_usb_work.conf</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>将文件 <code>mx6_usb_work.conf</code> 的内容修改为如下:</p><figure class="highlight plaintext"><figcaption><span>mx6_usb_work.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mx6_qsb</span><br><span class="line">hid,1024,0x910000,0x10000000,1G,0x00900000,0x40000</span><br><span class="line"></span><br><span class="line">firmware/u-boot.imx: dcd</span><br><span class="line">firmware/zImage: load 0x12000000</span><br><span class="line">firmware/fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot: load 0x12C00000</span><br><span class="line">firmware/zImage-imx6q-sabresd.dtb: load 0x18000000</span><br><span class="line">firmware/u-boot.imx: clear_dcd,load,plug,jump header</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 USB loader</li></ol><p>创建 <code>firmware</code> 目录:</p><figure class="highlight bash"><figcaption><span>创建目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> firmware </span><br></pre></td></tr></table></figure><p>将<a href="/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83#%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA-MFGTool">生成的镜像文件</a>拷贝到 <code>firmware</code> 目录中后执行:</p><figure class="highlight bash"><figcaption><span>运行 imx_usb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./imx_usb </span><br></pre></td></tr></table></figure><p>等待半分钟左右，可通过串口看到输出的启动信息:</p><figure class="highlight bash"><figcaption><span>串口输出信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Starting UTP</span><br><span class="line">uuc 0.5 [built Jan  9 2020 12:41:11]</span><br><span class="line">UTP: Waiting <span class="keyword">for</span> device to appear</span><br><span class="line">UTP: file/device node /dev/utp already exists</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此时开发板通过 USB 将自己模拟成一个 <code>sg</code> 设备，在电脑端可以通过以下命令查看此设备:</p><figure class="highlight bash"><figcaption><span>查看 sg 设备</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/sg*</span><br><span class="line"><span class="comment"># /dev/sg0  /dev/sg1</span></span><br></pre></td></tr></table></figure><p>其中 <code>/dev/sg1</code> 就是开发板。通过此设备我们便可用 <code>UTP</code> 工具与开发板通信。</p><h2 id="UTP-安装配置"><a href="#UTP-安装配置" class="headerlink" title="UTP 安装配置"></a>UTP 安装配置</h2><ol start="0"><li>安装 <code>libsgutils2</code>。</li></ol><figure class="highlight bash"><figcaption><span>install libsgutils2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsgutils2-dev</span><br></pre></td></tr></table></figure><ol><li>获取 UTP <a href="https://github.com/ixonos/utp_com">源代码</a>。</li></ol><figure class="highlight bash"><figcaption><span>git clone</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ixonos/utp_com.git</span><br></pre></td></tr></table></figure><ol start="2"><li>编译</li></ol><figure class="highlight bash"><figcaption><span>compile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> utp_com</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 utp_com 与开发板通信</li></ol><figure class="highlight bash"><figcaption><span>使用 utp_com</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./utp_com -d /dev/sg1 -c <span class="string">&quot;$ echo hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>通过串口可看到开发板的输出信息:</p><figure class="highlight bash"><figcaption><span>串口输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UTP: received <span class="built_in">command</span> <span class="string">&#x27;$ echo hello, world!&#x27;</span></span><br><span class="line">UTP: executing <span class="string">&quot;echo hello, world!&quot;</span></span><br><span class="line">hello, world!</span><br><span class="line">UTP: sending Success to kernel <span class="keyword">for</span> <span class="built_in">command</span> $ <span class="built_in">echo</span> hello, world!.</span><br><span class="line">utp_poll: pass returned.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们完成了 <code>imx_usb</code> 和 <code>utp_com</code> 的安装配置，使用 imx_usb 向开发板下载固件，以及使用 utp_com 与开发板通信向其发送并执行指令。具体工作如下:</p><ul><li>开发板下载模式配置</li><li>iMX USB loader 安装配置</li><li>UTP com 安装配置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> mfgtool </tag>
            
            <tag> imx_usb </tag>
            
            <tag> utp_com </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 iMX6Q SabreSD Yocto 项目开发环境</title>
      <link href="/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 <a href="">iMX6Q SabreSD</a> 开发板的 <a href="">Yocto Project</a> 开发环境搭建，以及使用 Yocto 编译此开发板的烧录工具（MFGTool）镜像。</p><span id="more"></span><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统: Ubuntu14.04</li></ul><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight bash"><figcaption><span>Yocto Project 的依赖包</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \</span><br><span class="line">build-essential chrpath socat</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>其他依赖包</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev xterm sed cvs subversion coreutils texi2html \</span><br><span class="line">docbook-utils python-pysqlite2 help2man make gcc g++ desktop-file-utils \</span><br><span class="line">libgl1-mesa-dev libglu1-mesa-dev mercurial autoconf automake groff curl lzop asciidoc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>u-boot 工具</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install u-boot-tools</span><br></pre></td></tr></table></figure><h2 id="安装-repo-工具"><a href="#安装-repo-工具" class="headerlink" title="安装 repo 工具"></a>安装 <code>repo</code> 工具</h2><p><code>repo</code> 是一个基于 <code>git</code> 的工具。使用 repo 可以方便地管理存在多个软件源的项目。安装 repo 分为以下几个步骤:</p><ol start="0"><li>在 <code>home</code> 目录下创建一个 <code>bin</code> 目录。</li></ol><figure class="highlight bash"><figcaption><span>安装 repo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line">curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></table></figure><ol><li>将下面2行加入 <code>.bashrc</code> 文件末尾，确保 <code>~/bin</code> 在 <code>PATH</code> 变量中。</li></ol><figure class="highlight bash"><figcaption><span>环境变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:~/bin</span><br><span class="line"><span class="built_in">export</span> MACHINE=imx6qsabresd</span><br></pre></td></tr></table></figure><h2 id="构建-Yocto-项目"><a href="#构建-Yocto-项目" class="headerlink" title="构建 Yocto 项目"></a>构建 Yocto 项目</h2><p><code>Freescale Yocto Project BSP Release</code> 目录包含如下内容:</p><ul><li><code>sources</code> 目录包含一些用于构建的配方</li><li>一个或多个 <code>build</code> 目录</li><li>一些用于配置开发环境的脚本</li></ul><p>以下步骤创建了一个 <code>fsl-release-bsp</code> 目录用于构建 Yocto 项目:</p><figure class="highlight bash"><figcaption><span>创建目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fsl-release-bsp</span><br><span class="line"><span class="built_in">cd</span> fsl-release-bsp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>配置 git 信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git config --global user.name &quot;Your Name&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;ClarenceYk&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email &quot;Your Email&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>同步源代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo init -u git://git.freescale.com/imx/fsl-arm-yocto-bsp.git -b imx-4.1.15-1.0.0_ga</span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>上面采用了 <code>imx-4.1.15-1.0.0_ga</code> 分支，可根据实际需求使用<a href="http://git.freescale.com/git/cgit.cgi/imx/fsl-arm-yocto-bsp.git/">其他分支代码</a>，如下:</p><p><img src="/2020/02/17/%E6%90%AD%E5%BB%BA-iMX6Q-SabreSD-Yocto-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/fsl-arm-yocto-bsp-git.jpg"></p><h2 id="编译构建-MFGTool"><a href="#编译构建-MFGTool" class="headerlink" title="编译构建 MFGTool"></a>编译构建 MFGTool</h2><p>向开发板烧录系统镜像可使用 MFGTool 完成。编译 MFGTool 镜像文件的配方分别是 <code>linux-imx-mfgtool</code> 和 <code>u-boot-mfgtool</code>。编译命令如下:</p><figure class="highlight bash"><figcaption><span>编译 MFGTool</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fsl-release-bsp</span><br><span class="line"><span class="built_in">source</span> fsl-setup-release.sh -b build-mfgtools -e x11</span><br><span class="line">bitbake fsl-image-mfgtool-initramfs</span><br></pre></td></tr></table></figure><p><em>编译过程需下载大量的源代码，为确保过程顺利建议使用 VPN 或者采用其他加速网络访问的方式。</em></p><p>成功编译之后，在目录 <code>~/fsl-mfgtools-bsp/build-mfgtools/tmp/deploy/images/imx6qsabresd</code> 下会产生如下文件:</p><ul><li>u-boot.imx（u-boot）</li><li>zImage（内核）</li><li>zImage-imx6q-sabresd.dtb（设备树）</li><li>fsl-image-mfgtool-initramfs-imx6qsabresd.cpio.gz.u-boot（内存文件系统）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，我们完成了 <code>Freescale iMX6Q Yocto Project</code> 开发环境搭建，其中包含如下方面的工作:</p><ul><li>安装项目依赖软件</li><li>安装 repo</li><li>配置 git</li><li>构建 Yocto 项目</li><li>编译 MFGTool 镜像</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> mfgtool </tag>
            
            <tag> yocto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 安装及配置 Ubuntu14.04 服务器版</title>
      <link href="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/"/>
      <url>/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>本文将以安装 Ubuntu14.04 操作系统到虚拟机中为例来介绍 VirtualBox 的使用。</p><span id="more"></span><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>操作系统: Windows 10</li><li>VirtualBox: 6.0</li></ul><h2 id="下载及安装-VirtualBox"><a href="#下载及安装-VirtualBox" class="headerlink" title="下载及安装 VirtualBox"></a>下载及安装 VirtualBox</h2><p>本文创建时使用的 VirtualBox 版本为 <code>6.0</code>，你可根据自己的需要选择其他或者最新版本。</p><ol start="0"><li>访问 Oracle VirtualBox <a href="https://www.virtualbox.org/">主页</a>。</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualbox.png"></p><ol><li>点击<code>下载</code>按钮，下载安装程序后双击此程序安装 VirtualBox。</li></ol><p><em>此处可一路点击<code>下一步</code>直至安装完成，然后重启计算机。</em></p><h2 id="下载-Ubuntu14-04-服务器版镜像文件"><a href="#下载-Ubuntu14-04-服务器版镜像文件" class="headerlink" title="下载 Ubuntu14.04 服务器版镜像文件"></a>下载 Ubuntu14.04 服务器版镜像文件</h2><ol start="0"><li>访问 Ubuntu 镜像<a href="http://releases.ubuntu.com/">发布页</a>，点击如下图<a href="http://releases.ubuntu.com/trusty/">链接</a>。</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/ubuntu-trusty.jpg"></p><ol><li>在如下页面中找到并下载<em><strong>服务器版本</strong></em>镜像。</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/ubuntu-trusty-image.jpg"></p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>接下来开始创建虚拟机。</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualbox-new.jpg"></p><ol start="0"><li>点击新建，选项配置如下：</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-config.jpg"></p><ul><li>名称: 自定义，如 <code>ubuntu1404-mfgtools</code> 表示此虚拟机操作系统为 <code>ubuntu14.04</code> 用于制作 <code>mfgtools</code></li><li>文件夹: 自定义，此虚拟机相关文件存放位置</li><li>类型: Linux</li><li>版本: Ubuntu (64-bit)</li><li>内存大小: 不影响主机性能的情况下取最大</li></ul><p>其他选项如上图，配置完成后点击<code>创建</code>。</p><ol><li>创建虚拟磁盘:</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-disk.jpg"></p><ul><li>文件大小: 根据需求配置</li><li>固定或动态大小: 同上</li></ul><p>配置完成点击<code>创建</code>。</p><h2 id="设置启动镜像"><a href="#设置启动镜像" class="headerlink" title="设置启动镜像"></a>设置启动镜像</h2><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings.jpg"></p><ol start="0"><li>点击<code>设置</code>，选择<code>存储</code>：</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-storage.jpg"></p><ol><li>依次点击如下所示选项：</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-storage-sel-image.jpg"></p><p>然后在弹出的选项中点击<code>选择一个虚拟光盘文件</code>，然后在弹出的选项框中选择之前下载的<code>系统镜像</code>文件。</p><ol start="2"><li>选择<code>系统</code>，将<code>启动顺序</code>改为如下图般:</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-system-boot.jpg"></p><p>配置完成后点击<code>确认</code>。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol start="0"><li>主界面点击<code>启动</code>，进入系统安装界面。</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install.jpg"></p><ol><li>根据提示操作，完成安装后如下图：</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install-complete.jpg"></p><p>选择 <code>Continue</code> 结束安装。关闭窗口。</p><ol start="2"><li>回到主界面点击<code>设置</code>，选择<code>系统</code>并将<code>启动顺序</code>改为如下图般:</li></ol><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-system-boot-1.jpg"></p><p>点击 <code>ok</code> 保存设置。</p><h2 id="额外的配置"><a href="#额外的配置" class="headerlink" title="额外的配置"></a>额外的配置</h2><p>完成前面的步骤后一个可用的虚拟机已经创建完成，后面的步骤可以让虚拟机使用起来更方便。</p><ol start="0"><li>设置端口转发</li></ol><p>回到主界面点击<code>设置</code>，选择<code>网络</code>并点击<code>高级</code>选项卡:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-network.jpg"></p><p>点击<code>端口转发</code>之后，添加如下配置:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-settings-port.jpg"></p><p>其中<code>子系统IP</code>填为虚拟机的 <code>IP</code> 地址。</p><p><em>这一步的作用是将虚拟机的 <code>22</code> 端口转发到主机的 <code>2200</code> 端口上，方面我们使用 <code>SSH</code> 连接虚拟机。</em></p><ol><li>安装增强功能</li></ol><figure class="highlight bash"><figcaption><span>登录虚拟机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh -p &lt;端口&gt; &lt;用户&gt;@&lt;主机地址&gt;</span></span><br><span class="line">ssh -p 2200 <span class="built_in">test</span>@192.168.1.101</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>安装依赖软件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>点击如下图所示的<code>安装增强功能</code>:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-install-enhance.jpg"></p><figure class="highlight bash"><figcaption><span>挂载光盘</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /mnt/cdrom</span><br><span class="line">sudo mount /dev/cdrom /mnt/cdrom/</span><br><span class="line"><span class="comment"># mount: block device /dev/sr0 is write-protected, mounting read-only</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>运行安装程序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/cdrom/</span><br><span class="line">sudo ./VBoxLinuxAdditions.run</span><br><span class="line">sudo shutdown -h 0 -r</span><br></pre></td></tr></table></figure><ol start="2"><li>共享文件夹</li></ol><figure class="highlight bash"><figcaption><span>加入 vboxsf 组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo usermod -a -G vboxsf &lt;用户&gt;</span></span><br><span class="line">sudo usermod -a -G vboxsf <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>回到<code>设置</code>，选择<code>共享文件夹</code>并点击如下所示按钮:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-new-share.jpg"></p><p>如下般设置:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-new-share-settings.jpg"></p><p><em>挂载点不用填。</em></p><figure class="highlight bash"><figcaption><span>重启虚拟机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h 0 -r</span><br></pre></td></tr></table></figure><ol start="3"><li>USB 设备支持</li></ol><p>访问 VirtualBox 官网下载<a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0">拓展包</a>。<em>注意，请找到对应自己版本的拓展包。</em></p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-extension-pack.jpg"></p><p>回到 VirtualBox 主界面，选择<code>管理</code>-&gt;<code>全局设定</code>-&gt;<code>拓展</code>:</p><p><img src="/2020/02/15/VirtualBox-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-Ubuntu14-04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88/virtualmachine-extension-pack-sel.jpg"></p><p>选择刚刚下载的拓展包，安装。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们就在虚拟机中安装好了 Ubuntu 操作系统，并做了以下设置:</p><ul><li>将虚拟机的<code>22</code>端口转发到主机<code>2200</code>端口。</li><li>创建一个共享文件夹用于虚拟机与主机间的文件共享。</li><li>安装了拓展包使虚拟机支持 USB2.0 以及 USB3.0 设备。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iMX6Q </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
