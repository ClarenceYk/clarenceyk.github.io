<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"clarenceyk.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文将介绍如何在 Linux 系统的用户层使用 Watchdog。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 系统中 Watchdog 的应用">
<meta property="og:url" content="https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Old Stone">
<meta property="og:description" content="本文将介绍如何在 Linux 系统的用户层使用 Watchdog。">
<meta property="og:locale">
<meta property="og:image" content="https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/compile-kernel-watchdog.png">
<meta property="article:published_time" content="2020-02-22T02:08:56.000Z">
<meta property="article:modified_time" content="2020-02-23T09:43:09.000Z">
<meta property="article:author" content="uklar">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Watchdog">
<meta property="article:tag" content="Embedded System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/compile-kernel-watchdog.png">

<link rel="canonical" href="https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Linux 系统中 Watchdog 的应用 | Old Stone</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Old Stone</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://clarenceyk.github.io/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="uklar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Old Stone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 系统中 Watchdog 的应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 10:08:56" itemprop="dateCreated datePublished" datetime="2020-02-22T10:08:56+08:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-23 17:43:09" itemprop="dateModified" datetime="2020-02-23T17:43:09+08:00">2020-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文将介绍如何在 Linux 系统的用户层使用 Watchdog。</p>
<span id="more"></span>

<h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><ul>
<li>硬件环境: iMX6Q SABRE-SD 开发板</li>
<li>操作系统内核: Linux 4.19.72-armv7</li>
<li>操作系统发行版: Ubuntu18.04</li>
</ul>
<h2 id="开启-Watchdog"><a href="#开启-Watchdog" class="headerlink" title="开启 Watchdog"></a>开启 Watchdog</h2><p>在<a href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6#Linux-%E5%86%85%E6%A0%B8">编译内核</a>时开启 <code>Watchdog</code>:</p>
<figure class="highlight bash"><figcaption><span>./tools/rebuild.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核配置选项位置</span></span><br><span class="line">Device Drivers -&gt; Watchdog Timer Support</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/22/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD-Watchdog-%E7%9A%84%E5%BA%94%E7%94%A8/compile-kernel-watchdog.png"></p>
<p><em>开启 <code>Disable watchdog shutdown on close</code> 这一项。</em></p>
<p>内核文档中关于此选项的解释如下:</p>
<blockquote><p>When the device is closed, the watchdog is disabled, unless the “MagicClose” feature is supported (see below).  This is not always such a good idea, since if there is a bug in the watchdog daemon and it crashes the system will not reboot.  Because of this, some of the drivers support the configuration option “Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT.  If it is set to Y when compiling the kernel, there is no way of disabling the watchdog once it has been started.  So, if the watchdog daemon crashes, the system will reboot after the timeout has passed. Watchdog devices also usually support the nowayout module parameter so that this option can be controlled at runtime.</p>
<p>Magic Close feature:</p>
<p>If a driver supports “Magic Close”, the driver will not disable the watchdog unless a specific magic character ‘V’ has been sent to &#x2F;dev&#x2F;watchdog just before closing the file.  If the userspace daemon closes the file without sending this special character, the driver will assume that the daemon (and userspace in general) died, and will stop pinging the watchdog without disabling it first.  This will then cause a reboot if the watchdog is not re-opened in sufficient time.</p>
<footer><strong>Christer Weingel</strong><cite><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/watchdog/watchdog-api.txt">The Linux Watchdog driver API.</a></cite></footer></blockquote>

<p>简单来说，开启此选项之后一旦我们打开了 Watchdog 设备，只要程序没对此 Watchdog 做文档中指定的操作，那么 Watchdog 就会重启系统。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>操作系统内核会将 CPU 芯片上的 Watchdog 外设抽象为文件系统中的一个字符设备:</p>
<figure class="highlight bash"><figcaption><span>ubuntu@arm:~$</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/watchdog*</span><br><span class="line"><span class="comment"># /dev/watchdog  /dev/watchdog0</span></span><br></pre></td></tr></table></figure>

<p>上面命令列出来系统中的 Watchdog 设备（<code>/dev/watchdog</code>、<code>/dev/watchdog0</code> 在底层指向同一个硬件）。使用其中任一设备都可以。</p>
<ol start="0">
<li>打开设备</li>
</ol>
<figure class="highlight c"><figcaption><span>api_watchdog_open</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchdog_fd = open(watchdog_dev, O_RDWR);</span><br></pre></td></tr></table></figure>

<p>根据头文件 <code>linux/watchdog.h</code> 中的定义，我们可以通过得到的<code>文件描述符</code>对 watchdog 设备做后面这些操作。</p>
<ol>
<li>设置 watchdog 超时时间</li>
</ol>
<figure class="highlight c"><figcaption><span>api_watchdog_settimeout</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &amp;seconds);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>feed watchdog</li>
</ol>
<figure class="highlight c"><figcaption><span>api_watchdog_feed</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(watchdog_fd, WDIOC_KEEPALIVE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>可以将上面的这些操作<a target="_blank" rel="noopener" href="https://gist.github.com/ClarenceYk/c71502b63378e3fbcd763fdaa658803d">封装成函数接口</a>，在函数内部做一些错误处理。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">wait_time</span> =</span> &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (api_watchdog_init(WATCHDOG_DEV, WATCHDOG_TIMEOUT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Watchdog opened!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		api_watchdog_feed();</span><br><span class="line">		nanosleep(&amp;wait_time, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，先初始化 watchdog 然后每秒 feed watchdog 一次，此时系统如常运行。当 kill 此程序后，由于前面在内核开启了 <code>Disable watchdog shutdown on close</code> 选项 watchdog 会继续工作，同时没有继续 feed 的操作所以系统进入重启流程。</p>
<h2 id="引入外部-Kick-信号"><a href="#引入外部-Kick-信号" class="headerlink" title="引入外部 Kick 信号"></a>引入外部 Kick 信号</h2><p>以一个具体的应用场景为例，如下:</p>
<figure class="highlight plaintext"><figcaption><span>硬件连接</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------   GPIO  --------</span><br><span class="line">| CPU | &lt;------ | FPGA |</span><br><span class="line">-------         --------</span><br></pre></td></tr></table></figure>

<p>FPGA 通过 CPU 的 GPIO 外设向开发板输入一个周期性翻转信号。CPU 在每一个周期开始时重置 watchdog，我们可以检测 GPIO 的上升沿或者下降沿获得周期开始的信息。</p>
<p>对 GPIO 的操作在 Linux 环境中有很多方法实现，这里我们使用 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 库来实现对 GPIO 上升沿信号的检测。</p>
<p><code>libgpiod</code> 中封装了很多便于使用的 API。在当前使用场景中，只需调用函数 <code>gpiod_ctxless_event_monitor</code> 就可实现我们想要的功能，其函数签名以及相应的文档注释如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wait for events on a single GPIO line.</span></span><br><span class="line"><span class="comment"> * @param device Name, path, number or label of the gpiochip.</span></span><br><span class="line"><span class="comment"> * @param event_type Type of events to listen for.</span></span><br><span class="line"><span class="comment"> * @param offset GPIO line offset to monitor.</span></span><br><span class="line"><span class="comment"> * @param active_low The active state of this line - true if low.</span></span><br><span class="line"><span class="comment"> * @param consumer Name of the consumer.</span></span><br><span class="line"><span class="comment"> * @param timeout Maximum wait time for each iteration.</span></span><br><span class="line"><span class="comment"> * @param poll_cb Callback function to call when waiting for events.</span></span><br><span class="line"><span class="comment"> * @param event_cb Callback function to call for each line event.</span></span><br><span class="line"><span class="comment"> * @param data User data passed to the callback.</span></span><br><span class="line"><span class="comment"> * @return 0 if no errors were encountered, -1 if an error occurred.</span></span><br><span class="line"><span class="comment"> * @note The way the ctxless event loop works is described in detail in</span></span><br><span class="line"><span class="comment"> *       ::gpiod_ctxless_event_monitor_multiple - this is just a wrapper aound</span></span><br><span class="line"><span class="comment"> *       this routine which calls it for a single GPIO line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_ctxless_event_monitor</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *device, <span class="type">int</span> event_type,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">bool</span> active_low,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *consumer,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout,</span></span><br><span class="line"><span class="params">                                gpiod_ctxless_event_poll_cb poll_cb,</span></span><br><span class="line"><span class="params">                                gpiod_ctxless_event_handle_cb event_cb,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data)</span> GPIOD_API;</span><br></pre></td></tr></table></figure>

<p>如上可以看出几个关键参数，通过 <code>device</code>、<code>offset</code> 参数指定使用的 GPIO 管脚，<code>event_type</code> 指定检测事件（如，上升沿事件），<code>event_cb</code> 是触发指定事件后调用的回调函数，其调用方法大致如下:</p>
<figure class="highlight c"><figcaption><span>上升沿检测</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WDOG_GPIO_SIG_CHIP &quot;/dev/gpiochip6&quot;</span></span><br><span class="line"><span class="comment">// WDOG_GPIO_SIG_PORT 7</span></span><br><span class="line">gpiod_ctxless_event_monitor(WDOG_GPIO_SIG_CHIP, GPIOD_CTXLESS_EVENT_RISING_EDGE,</span><br><span class="line">                        WDOG_GPIO_SIG_PORT, <span class="literal">false</span>, <span class="string">&quot;wdog&quot;</span>, &amp;timeout,</span><br><span class="line">                        <span class="literal">NULL</span>, gpio6_port7_rising_edge_handle_cb, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>接下来只需要再定义回调函数即可，回调函数的函数签名如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Simple event callback signature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The callback function takes the following arguments: event type (int),</span></span><br><span class="line"><span class="comment"> * GPIO line offset (unsigned int), event timestamp (const struct timespec *)</span></span><br><span class="line"><span class="comment"> * and a pointer to user data (void *).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This callback is called by the ctxless event loop functions for each GPIO</span></span><br><span class="line"><span class="comment"> * event. If the callback returns ::GPIOD_CTXLESS_EVENT_CB_RET_ERR, it should</span></span><br><span class="line"><span class="comment"> * also set errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*gpiod_ctxless_event_handle_cb)</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="keyword">struct</span> timespec *, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们定义的上升沿事件回调函数大致如下:</p>
<figure class="highlight c"><figcaption><span>定义回调函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio6_port7_rising_edge_handle_cb</span><span class="params">(<span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *timestamp, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    wdog_count ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wdog_count &gt;= WDOG_FEED_PERIOD / FPGA_WDOG_SIG_PERIOD) &#123;</span><br><span class="line">        api_watchdog_feed();</span><br><span class="line">        wdog_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GPIOD_CTXLESS_EVENT_CB_RET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键在于 <code>api_watchdog_feed()</code>。</p>
<p>以上就实现了外部 Kick 信号的引入。</p>
<h2 id="配置-systemd-服务"><a href="#配置-systemd-服务" class="headerlink" title="配置 systemd 服务"></a>配置 systemd 服务</h2><p>我们希望 watchdog 程序随着系统自动启动，所以配置如下的 systemd 服务:</p>
<figure class="highlight plaintext"><figcaption><span>wdog_fpga.service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Watchdog systemd service.</span><br><span class="line">ConditionKernelCommandLine=!disable_wdog</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/wdog_fpga</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>其中我们定义了 <code>ConditionKernelCommandLine</code> 参数为 <code>!disable_wdog</code>。这样当系统启动之后 systemd 会检测内核启动命令行参数中是否存在<code>disable_wdog</code>，如果不存在则启动 watchdog，反之依然。这样配置的好处是，我们可以在系统启动之前配置是否开启 watchdog。</p>
<h2 id="U-Boot-环境设置内核命令行参数"><a href="#U-Boot-环境设置内核命令行参数" class="headerlink" title="U-Boot 环境设置内核命令行参数"></a>U-Boot 环境设置内核命令行参数</h2><p>如果我们不想开启 watchdog，则在 U-Boot 启动后暂停引导内核，然后将 <code>disable_wdog</code> 参数设置到内核命令行参数中，如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs ... 其他参数 ... disable_wdog</span><br></pre></td></tr></table></figure>

<p>然后再引导内核启动:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run bootcmd</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本介绍了如何在 Linux 操作系统中使用 watchdog，分为以下方面的工作:</p>
<ul>
<li>内核选项配置</li>
<li>部分 API 介绍</li>
<li>设备操作接口封装</li>
<li>实际应用场景示例</li>
</ul>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/username">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Watchdog/" rel="tag"># Watchdog</a>
              <a href="/tags/Embedded-System/" rel="tag"># Embedded System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/19/iMX6Q-SABRE-SD-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BD%AF%E4%BB%B6%E7%83%A7%E5%BD%95/" rel="prev" title="iMX6Q SABRE-SD 开发板软件烧录">
      <i class="fa fa-chevron-left"></i> iMX6Q SABRE-SD 开发板软件烧录
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/16/iMX6Q-2GB-%E5%86%85%E5%AD%98%E6%94%AF%E6%8C%81/" rel="next" title="iMX6Q 2GB 内存支持">
      iMX6Q 2GB 内存支持 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">操作环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%90%AF-Watchdog"><span class="nav-number">2.</span> <span class="nav-text">开启 Watchdog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8-Kick-%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">引入外部 Kick 信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-systemd-%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.</span> <span class="nav-text">配置 systemd 服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#U-Boot-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%86%85%E6%A0%B8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">U-Boot 环境设置内核命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">uklar</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ClarenceYk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ClarenceYk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="far fa-keyboard"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">uklar</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
